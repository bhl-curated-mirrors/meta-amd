From c810d12c79ee2ac62d26f00f282a7b8376265772 Mon Sep 17 00:00:00 2001
From: Ramesh Garidapuri <ramesh.garidapuri@amd.com>
Date: Thu, 9 Nov 2023 10:07:28 +0530
Subject: [PATCH] amd-xgbe: PPS: periodic output support

Signed-off-by: Raju Rangoju <Raju.Rangoju@amd.com>
Change-Id: I3a4a25c512a409fd22c5181919e817d2c0599cec
---
 drivers/net/ethernet/amd/xgbe/xgbe-common.h  | 40 ++++++++++++-
 drivers/net/ethernet/amd/xgbe/xgbe-dev.c     | 59 ++++++++++++++++++++
 drivers/net/ethernet/amd/xgbe/xgbe-drv.c     |  3 +-
 drivers/net/ethernet/amd/xgbe/xgbe-ptp.c     | 41 ++++++++++++--
 drivers/net/ethernet/amd/xgbe/xgbe-ptp.c.rej | 53 ++++++++++++++++++
 drivers/net/ethernet/amd/xgbe/xgbe.h         | 12 ++++
 6 files changed, 200 insertions(+), 8 deletions(-)
 create mode 100644 drivers/net/ethernet/amd/xgbe/xgbe-ptp.c.rej

diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-common.h b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
index 9234dbbe2347..bd045df414bf 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
@@ -332,11 +332,18 @@
 #define MAC_TSSR			0x0d20
 #define MAC_TXSNR			0x0d30
 #define MAC_TXSSR			0x0d34
+#define MAC_AUXCR			0x0d40
+#define MAC_ATSNR			0x0d48
+#define MAC_ATSSR			0x0d4C
 #define MAC_TICNR                       0x0d58
 #define MAC_TICSNR                      0x0d5C
 #define MAC_TECNR                       0x0d60
 #define MAC_TECSNR                      0x0d64
-
+#define MAC_PPSCR			0x0d70
+#define MAC_PPSx_TTSR(x)		(0x0d80 + ((x) * 0x10))
+#define MAC_PPSx_TTNSR(x)		(0x0d84 + ((x) * 0x10))
+#define MAC_PPSx_INTERVAL(x)		(0x0d88 + ((x) * 0x10))
+#define MAC_PPSx_WIDTH(x)		(0x0d8C + ((x) * 0x10))
 #define MAC_QTFCR_INC			4
 #define MAC_MACA_INC			4
 #define MAC_HTR_INC			4
@@ -561,8 +568,29 @@
 #define MAC_TSCR_TXTSSTSM_WIDTH		1
 #define MAC_TSSR_TXTSC_INDEX		15
 #define MAC_TSSR_TXTSC_WIDTH		1
+#define MAC_TSSR_ATSSTN_INDEX		16 //Auxiliary Timestamp Snapshot Trigger Identifier.
+#define MAC_TSSR_ATSSTN_WIDTH		4
+
+#define MAC_TSSR_ATSNS_INDEX		25 //Number of Auxiliary Timestamp Snapshots.
+#define MAC_TSSR_ATSNS_WIDTH		5
+
+#define MAC_TSSR_ATSSTM_INDEX		24 //Auxiliary Timestamp Snapshot Trigger Missed.
+#define MAC_TSSR_ATSSTM_WIDTH		1
+
+#define MAC_TSSR_ATSSTN_INDEX		16 //Auxiliary Timestamp Snapshot Trigger Identifier.
+#define MAC_TSSR_ATSSTN_WIDTH		4
+#define MAC_TSSR_AUXTSTRIG_INDEX	2 //Auxiliary Timestamp Trigger Snapshot.
+#define MAC_TSSR_AUXTSTRIG_WIDTH	1
 #define MAC_TXSNR_TXTSSTSMIS_INDEX	31
 #define MAC_TXSNR_TXTSSTSMIS_WIDTH	1
+#define MAC_AUXCR_ATSEN3_INDEX		7
+#define MAC_AUXCR_ATSEN3_WIDTH		1
+#define MAC_AUXCR_ATSEN2_INDEX		6
+#define MAC_AUXCR_ATSEN2_WIDTH		1
+#define MAC_AUXCR_ATSEN1_INDEX		5
+#define MAC_AUXCR_ATSEN1_WIDTH		1
+#define MAC_AUXCR_ATSEN0_INDEX		4
+#define MAC_AUXCR_ATSEN0_WIDTH		1
 #define MAC_TICSNR_TSICSNS_INDEX	8
 #define MAC_TICSNR_TSICSNS_WIDTH	8
 #define MAC_TECSNR_TSECSNS_INDEX	8
@@ -597,8 +625,14 @@
 #define MAC_VR_SNPSVER_WIDTH		8
 #define MAC_VR_USERVER_INDEX		16
 #define MAC_VR_USERVER_WIDTH		8
-
-/* MMC register offsets */
+#define MAC_PPSCR_PPSEN0_INDEX		4
+#define MAC_PPSCR_PPSEN0_WIDTH		1
+#define MAC_PPSCR_PPSCTRL0_INDEX	0
+#define MAC_PPSCR_PPSCTRL0_WIDTH	4
+#define MAC_PPSx_TTNSR_TRGTBUSY0_INDEX	31
+#define MAC_PPSx_TTNSR_TRGTBUSY0_WIDTH	1
+
+ /* MMC register offsets */
 #define MMC_CR				0x0800
 #define MMC_RISR			0x0804
 #define MMC_TISR			0x0808
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index cd0c3f4bb457..951ff0030fc6 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@ -1694,6 +1694,64 @@ static void xgbe_config_tstamp(struct xgbe_prv_data *pdata,
 	XGMAC_IOWRITE(pdata, MAC_TSCR, value);
 }
 
+#define PPS_MAXIDX(x)                   ((((x) + 1) * 8) - 1)
+#define PPS_MINIDX(x)                   ((x) * 8)
+#define PPSx_MASK(x)                    GENMASK(PPS_MAXIDX(x), PPS_MINIDX(x))
+#define PPSCMDx(x, val)                 \
+        GENMASK(PPS_MINIDX(x) + 3, PPS_MINIDX(x)) & \
+        ((val) << PPS_MINIDX(x))
+#define PPSEN0                          BIT(4)
+#define TRGTMODSELx(x, val)             \
+        GENMASK(PPS_MAXIDX(x) - 1, PPS_MAXIDX(x) - 2) & \
+        ((val) << (PPS_MAXIDX(x) - 2))
+
+
+static int xgbe_pps_config(struct xgbe_prv_data *pdata, struct xgbe_pps_config *cfg, int index, int on)
+{
+	unsigned int value = 0;
+	unsigned int tnsec;
+	u64 period;
+
+	tnsec = XGMAC_IOREAD(pdata, MAC_PPSx_TTNSR(index));
+	if (XGMAC_GET_BITS(tnsec, MAC_PPSx_TTNSR, TRGTBUSY0))
+		return -EBUSY;
+
+	value = XGMAC_IOREAD(pdata, MAC_PPSCR);
+
+	value &= ~PPSx_MASK(index);
+
+	if (!on) {
+		value |= PPSCMDx(index, 0x5);
+		value |= PPSEN0;
+		XGMAC_IOWRITE(pdata, MAC_PPSCR, value);
+		return 0;
+	}
+
+	XGMAC_IOWRITE(pdata, MAC_PPSx_TTSR(index), cfg->start.tv_sec);
+	XGMAC_IOWRITE(pdata, MAC_PPSx_TTNSR(index), cfg->start.tv_nsec);
+
+	period = cfg->period.tv_sec * NSEC_PER_SEC;
+	period += cfg->period.tv_nsec;
+	do_div(period, XGBE_V2_TSTAMP_SSINC);
+
+	if (period <= 1)
+		return -EINVAL;
+
+	XGMAC_IOWRITE(pdata, MAC_PPSx_INTERVAL(index), period - 1);
+	period >>= 1;
+	if (period <= 1)
+		return -EINVAL;
+
+	XGMAC_IOWRITE(pdata, MAC_PPSx_WIDTH(index), period - 1);
+
+	value |= PPSCMDx(index, 0x2);
+	value |= TRGTMODSELx(index, 0x2);
+	value |= PPSEN0;
+
+	XGMAC_IOWRITE(pdata, MAC_PPSCR, value);
+	return 0;
+}
+
 static void xgbe_tx_start_xmit(struct xgbe_channel *channel,
 			       struct xgbe_ring *ring)
 {
@@ -3756,6 +3814,7 @@ void xgbe_init_function_ptrs_dev(struct xgbe_hw_if *hw_if)
 	hw_if->update_tstamp_time = xgbe_update_tstamp_time;
 	hw_if->get_tstamp_time = xgbe_get_tstamp_time;
 	hw_if->get_tx_tstamp = xgbe_get_tx_tstamp;
+	hw_if->pps_config = xgbe_pps_config;
 
 	/* For Data Center Bridging config */
 	hw_if->config_tc = xgbe_config_tc;
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index a6ff112c55aa..64a33aac486c 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@ -480,7 +480,7 @@ static void xgbe_isr_task(struct tasklet_struct *t)
 	struct xgbe_channel *channel;
 	unsigned int dma_isr, dma_ch_isr;
 	unsigned int mac_isr, mac_tssr, mac_mdioisr;
-	unsigned int i;
+	unsigned int i, nauxtssnp;
 
 	/* The DMA interrupt status register also reports MAC and MTL
 	 * interrupts. So for polling mode, we just need to check for
@@ -797,6 +797,7 @@ void xgbe_get_all_hw_features(struct xgbe_prv_data *pdata)
 	hw_feat->tx_ch_cnt    = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, TXCHCNT);
 	hw_feat->pps_out_num  = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, PPSOUTNUM);
 	hw_feat->aux_snap_num = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, AUXSNAPNUM);
+	printk("%s pps_out_num  %u aux_snap_num %u\n", __func__, hw_feat->pps_out_num, hw_feat->aux_snap_num);
 
 	/* Translate the Hash Table size into actual number */
 	switch (hw_feat->hash_table_size) {
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-ptp.c b/drivers/net/ethernet/amd/xgbe/xgbe-ptp.c
index 48b77463eda3..4150796eeafc 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-ptp.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-ptp.c
@@ -222,16 +222,47 @@ static int xgbe_settime(struct ptp_clock_info *info,
 }
 
 static int xgbe_enable(struct ptp_clock_info *info,
-		       struct ptp_clock_request *request, int on)
+		struct ptp_clock_request *req, int on)
 {
-	return -EOPNOTSUPP;
+	struct xgbe_prv_data *pdata = container_of(info,
+			struct xgbe_prv_data,
+			ptp_clock_info);
+	struct xgbe_pps_config *pps_cfg;
+	unsigned long flags;
+	int ret;
+
+	switch (req->type) {
+		case PTP_CLK_REQ_PEROUT:
+			/* Reject requests with unsupported flags */
+			if (req->perout.flags)
+				return -EOPNOTSUPP;
+
+			pps_cfg = &pdata->pps[req->perout.index];
+
+			pps_cfg->start.tv_sec = req->perout.start.sec;
+			pps_cfg->start.tv_nsec = req->perout.start.nsec;
+			pps_cfg->period.tv_sec = req->perout.period.sec;
+			pps_cfg->period.tv_nsec = req->perout.period.nsec;
+
+			spin_lock_irqsave(&pdata->tstamp_lock, flags);
+			ret = pdata->hw_if.pps_config(pdata, pps_cfg, req->perout.index, on);
+			spin_unlock_irqrestore(&pdata->tstamp_lock, flags);
+			break;
+
+		case PTP_CLK_REQ_EXTTS:
+		case PTP_CLK_REQ_PPS:
+		default:
+			break;
+	}
+	dev_dbg(pdata->dev, "rq->type %d on %d\n", req->type, on);
+	return 0;
 }
 
 void xgbe_ptp_register(struct xgbe_prv_data *pdata)
 {
 	struct ptp_clock_info *info = &pdata->ptp_clock_info;
 	struct ptp_clock *clock;
-	u64 dividend;
+	
 
 	snprintf(info->name, sizeof(info->name), "%s",
 		 netdev_name(pdata->netdev));
@@ -239,8 +270,10 @@ void xgbe_ptp_register(struct xgbe_prv_data *pdata)
 	info->max_adj = pdata->ptpclk_rate;
 	info->adjfine = xgbe_adjfine;
 	info->adjtime = xgbe_adjtime;
-	info->gettime64 = xgbe_gettimex;
+	info->gettimex64 = xgbe_gettimex;
 	info->settime64 = xgbe_settime;
+	info->n_per_out = pdata->hw_feat.pps_out_num;
+	info->n_ext_ts = pdata->hw_feat.aux_snap_num;
 	info->enable = xgbe_enable;
 
 	clock = ptp_clock_register(info, pdata->dev);
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-ptp.c.rej b/drivers/net/ethernet/amd/xgbe/xgbe-ptp.c.rej
new file mode 100644
index 000000000000..d486e85f9d61
--- /dev/null
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-ptp.c.rej
@@ -0,0 +1,53 @@
+--- drivers/net/ethernet/amd/xgbe/xgbe-ptp.c
++++ drivers/net/ethernet/amd/xgbe/xgbe-ptp.c
+@@ -222,17 +222,46 @@ static int xgbe_settime(struct ptp_clock_info *info,
+ }
+ 
+ static int xgbe_enable(struct ptp_clock_info *info,
+-		       struct ptp_clock_request *request, int on)
++		       struct ptp_clock_request *req, int on)
+ {
+-	return -EOPNOTSUPP;
++	struct xgbe_prv_data *pdata = container_of(info,
++						struct xgbe_prv_data,
++						ptp_clock_info);
++	struct xgbe_pps_config *pps_cfg;
++	unsigned long flags;
++	int ret;
++
++	switch (req->type) {
++	case PTP_CLK_REQ_PEROUT:
++		/* Reject requests with unsupported flags */
++		if (req->perout.flags)
++			return -EOPNOTSUPP;
++
++		pps_cfg = &pdata->pps[req->perout.index];
++
++		pps_cfg->start.tv_sec = req->perout.start.sec;
++		pps_cfg->start.tv_nsec = req->perout.start.nsec;
++		pps_cfg->period.tv_sec = req->perout.period.sec;
++		pps_cfg->period.tv_nsec = req->perout.period.nsec;
++
++		spin_lock_irqsave(&pdata->tstamp_lock, flags);
++		ret = pdata->hw_if.pps_config(pdata, pps_cfg, req->perout.index, on);
++		spin_unlock_irqrestore(&pdata->tstamp_lock, flags);
++		break;
++
++	case PTP_CLK_REQ_EXTTS:
++	case PTP_CLK_REQ_PPS:
++	default:
++	       break;
++	}
++	dev_dbg(pdata->dev, "rq->type %d on %d\n", req->type, on);
++	return 0;
+ }
+ 
+ void xgbe_ptp_register(struct xgbe_prv_data *pdata)
+ {
+ 	struct ptp_clock_info *info = &pdata->ptp_clock_info;
+ 	struct ptp_clock *clock;
+-	struct cyclecounter *cc = &pdata->tstamp_cc;
+-	u64 dividend;
+ 
+ 	snprintf(info->name, sizeof(info->name), "%s",
+ 		 netdev_name(pdata->netdev));
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe.h b/drivers/net/ethernet/amd/xgbe/xgbe.h
index a23ae9fe28d0..3421d1a639ae 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@ -767,6 +767,12 @@ struct xgbe_ext_stats {
 	u64 rx_vxlan_csum_errors;
 };
 
+struct xgbe_pps_config {
+        bool available;
+        struct timespec64 start;
+        struct timespec64 period;
+};
+
 struct xgbe_hw_if {
 	int (*tx_complete)(struct xgbe_ring_desc *);
 
@@ -859,6 +865,9 @@ struct xgbe_hw_if {
 				   unsigned int nsec);
 	u64 (*get_tstamp_time)(struct xgbe_prv_data *);
 	u64 (*get_tx_tstamp)(struct xgbe_prv_data *);
+	u64 (*get_aux_snp)(struct xgbe_prv_data *);
+	u64 (*feature_enable)(struct xgbe_prv_data *);
+	int (*pps_config)(struct xgbe_prv_data *, struct xgbe_pps_config *, int index, int on);
 
 	/* For Data Center Bridging config */
 	void (*config_tc)(struct xgbe_prv_data *);
@@ -1245,6 +1254,9 @@ struct xgbe_prv_data {
 	struct sk_buff *tx_tstamp_skb;
 	u64 tx_tstamp;
 
+	/* Pulse Per Second output */
+	struct xgbe_pps_config pps[4];
+
 	/* DCB support */
 	struct ieee_ets *ets;
 	struct ieee_pfc *pfc;
-- 
2.34.1

