From dfe4633047fbf7db958b81ab03fd22f1f4fe7e38 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Tue, 7 May 2019 14:50:05 -0500
Subject: [PATCH 2435/2940] drm/amd/display: Add DCN2 DIO

Add support for the DIO (Display IO)  block of DCN2, which entails our
stream and link encoders.

HW Blocks:

    +--------+
    |  DIO   |
    +--------+

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../amd/display/dc/dcn10/dcn10_link_encoder.h | 174 +++++++
 .../display/dc/dcn10/dcn10_stream_encoder.h   |  40 ++
 .../amd/display/dc/dcn20/dcn20_link_encoder.c | 438 +++++++++++++++++
 .../amd/display/dc/dcn20/dcn20_link_encoder.h | 165 +++++++
 .../display/dc/dcn20/dcn20_stream_encoder.c   | 440 ++++++++++++++++++
 .../display/dc/dcn20/dcn20_stream_encoder.h   |  97 ++++
 .../drm/amd/display/dc/inc/hw/link_encoder.h  |  14 +
 .../amd/display/dc/inc/hw/stream_encoder.h    |  24 +
 .../dc/virtual/virtual_stream_encoder.c       |   5 +
 9 files changed, 1397 insertions(+)
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.h

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.h
index b74b80a247ec..33b2af1a181c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_link_encoder.h
@@ -72,6 +72,9 @@
 struct dcn10_link_enc_aux_registers {
 	uint32_t AUX_CONTROL;
 	uint32_t AUX_DPHY_RX_CONTROL0;
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+	uint32_t AUX_DPHY_TX_CONTROL;
+#endif
 };
 
 struct dcn10_link_enc_hpd_registers {
@@ -103,6 +106,23 @@ struct dcn10_link_enc_registers {
 	uint32_t DP_DPHY_HBR2_PATTERN_CONTROL;
 	uint32_t DP_SEC_CNTL1;
 	uint32_t TMDS_CTL_BITS;
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	/* DCCG  */
+	uint32_t CLOCK_ENABLE;
+	/* DIG */
+	uint32_t DIG_LANE_ENABLE;
+	/* UNIPHY */
+	uint32_t CHANNEL_XBAR_CNTL;
+	/* indirect registers */
+	uint32_t RAWLANE0_DIG_PCS_XF_RX_OVRD_IN_2;
+	uint32_t RAWLANE0_DIG_PCS_XF_RX_OVRD_IN_3;
+	uint32_t RAWLANE1_DIG_PCS_XF_RX_OVRD_IN_2;
+	uint32_t RAWLANE1_DIG_PCS_XF_RX_OVRD_IN_3;
+	uint32_t RAWLANE2_DIG_PCS_XF_RX_OVRD_IN_2;
+	uint32_t RAWLANE2_DIG_PCS_XF_RX_OVRD_IN_3;
+	uint32_t RAWLANE3_DIG_PCS_XF_RX_OVRD_IN_2;
+	uint32_t RAWLANE3_DIG_PCS_XF_RX_OVRD_IN_3;
+#endif
 };
 
 #define LE_SF(reg_name, field_name, post_fix)\
@@ -208,12 +228,166 @@ struct dcn10_link_enc_registers {
 	type AUX_LS_READ_EN;\
 	type AUX_RX_RECEIVE_WINDOW
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+
+#define DCN20_LINK_ENCODER_DPCS_REG_FIELD_LIST(type) \
+		type RDPCS_PHY_DP_TX0_DATA_EN;\
+		type RDPCS_PHY_DP_TX1_DATA_EN;\
+		type RDPCS_PHY_DP_TX2_DATA_EN;\
+		type RDPCS_PHY_DP_TX3_DATA_EN;\
+		type RDPCS_PHY_DP_TX0_PSTATE;\
+		type RDPCS_PHY_DP_TX1_PSTATE;\
+		type RDPCS_PHY_DP_TX2_PSTATE;\
+		type RDPCS_PHY_DP_TX3_PSTATE;\
+		type RDPCS_PHY_DP_TX0_MPLL_EN;\
+		type RDPCS_PHY_DP_TX1_MPLL_EN;\
+		type RDPCS_PHY_DP_TX2_MPLL_EN;\
+		type RDPCS_PHY_DP_TX3_MPLL_EN;\
+		type RDPCS_TX_FIFO_LANE0_EN;\
+		type RDPCS_TX_FIFO_LANE1_EN;\
+		type RDPCS_TX_FIFO_LANE2_EN;\
+		type RDPCS_TX_FIFO_LANE3_EN;\
+		type RDPCS_EXT_REFCLK_EN;\
+		type RDPCS_TX_FIFO_EN;\
+		type UNIPHY_LINK_ENABLE;\
+		type UNIPHY_CHANNEL0_INVERT;\
+		type UNIPHY_CHANNEL1_INVERT;\
+		type UNIPHY_CHANNEL2_INVERT;\
+		type UNIPHY_CHANNEL3_INVERT;\
+		type UNIPHY_LINK_ENABLE_HPD_MASK;\
+		type UNIPHY_LANE_STAGGER_DELAY;\
+		type RDPCS_SRAMCLK_BYPASS;\
+		type RDPCS_SRAMCLK_EN;\
+		type RDPCS_SRAMCLK_CLOCK_ON;\
+		type DPCS_TX_FIFO_EN;\
+		type RDPCS_PHY_DP_TX0_DISABLE;\
+		type RDPCS_PHY_DP_TX1_DISABLE;\
+		type RDPCS_PHY_DP_TX2_DISABLE;\
+		type RDPCS_PHY_DP_TX3_DISABLE;\
+		type RDPCS_PHY_DP_TX0_CLK_RDY;\
+		type RDPCS_PHY_DP_TX1_CLK_RDY;\
+		type RDPCS_PHY_DP_TX2_CLK_RDY;\
+		type RDPCS_PHY_DP_TX3_CLK_RDY;\
+		type RDPCS_PHY_DP_TX0_REQ;\
+		type RDPCS_PHY_DP_TX1_REQ;\
+		type RDPCS_PHY_DP_TX2_REQ;\
+		type RDPCS_PHY_DP_TX3_REQ;\
+		type RDPCS_PHY_DP_TX0_ACK;\
+		type RDPCS_PHY_DP_TX1_ACK;\
+		type RDPCS_PHY_DP_TX2_ACK;\
+		type RDPCS_PHY_DP_TX3_ACK;\
+		type RDPCS_PHY_DP_TX0_RESET;\
+		type RDPCS_PHY_DP_TX1_RESET;\
+		type RDPCS_PHY_DP_TX2_RESET;\
+		type RDPCS_PHY_DP_TX3_RESET;\
+		type RDPCS_PHY_RESET;\
+		type RDPCS_PHY_CR_MUX_SEL;\
+		type RDPCS_PHY_REF_RANGE;\
+		type RDPCS_PHY_DP4_POR;\
+		type RDPCS_SRAM_BYPASS;\
+		type RDPCS_SRAM_EXT_LD_DONE;\
+		type RDPCS_PHY_DP_TX0_TERM_CTRL;\
+		type RDPCS_PHY_DP_TX1_TERM_CTRL;\
+		type RDPCS_PHY_DP_TX2_TERM_CTRL;\
+		type RDPCS_PHY_DP_TX3_TERM_CTRL;\
+		type RDPCS_PHY_DP_REF_CLK_MPLLB_DIV;\
+		type RDPCS_PHY_DP_MPLLB_MULTIPLIER;\
+		type RDPCS_PHY_DP_MPLLB_SSC_EN;\
+		type RDPCS_PHY_DP_MPLLB_DIV5_CLK_EN;\
+		type RDPCS_PHY_DP_MPLLB_TX_CLK_DIV;\
+		type RDPCS_PHY_DP_MPLLB_WORD_DIV2_EN;\
+		type RDPCS_PHY_DP_MPLLB_FRACN_EN;\
+		type RDPCS_PHY_DP_MPLLB_PMIX_EN;\
+		type RDPCS_PHY_DP_MPLLB_FRACN_QUOT;\
+		type RDPCS_PHY_DP_MPLLB_FRACN_DEN;\
+		type RDPCS_PHY_DP_MPLLB_FRACN_REM;\
+		type RDPCS_PHY_DP_MPLLB_SSC_UP_SPREAD;\
+		type RDPCS_PHY_DP_MPLLB_SSC_STEPSIZE;\
+		type RDPCS_PHY_DP_MPLLB_SSC_PEAK;\
+		type RDPCS_PHY_DP_MPLLB_DIV_CLK_EN;\
+		type RDPCS_PHY_DP_MPLLB_DIV_MULTIPLIER;\
+		type RDPCS_PHY_TX_VBOOST_LVL;\
+		type RDPCS_PHY_HDMIMODE_ENABLE;\
+		type RDPCS_PHY_DP_REF_CLK_EN;\
+		type RDPCS_PLL_UPDATE_DATA;\
+		type RDPCS_SRAM_INIT_DONE;\
+		type RDPCS_TX_CR_ADDR;\
+		type RDPCS_TX_CR_DATA;\
+		type RDPCS_PHY_HDMI_MPLLB_HDMI_DIV;\
+		type RDPCS_PHY_DP_MPLLB_STATE;\
+		type RDPCS_PHY_DP_TX0_WIDTH;\
+		type RDPCS_PHY_DP_TX0_RATE;\
+		type RDPCS_PHY_DP_TX1_WIDTH;\
+		type RDPCS_PHY_DP_TX1_RATE;\
+		type RDPCS_PHY_DP_TX2_WIDTH;\
+		type RDPCS_PHY_DP_TX2_RATE;\
+		type RDPCS_PHY_DP_TX3_WIDTH;\
+		type RDPCS_PHY_DP_TX3_RATE;\
+		type DPCS_SYMCLK_CLOCK_ON;\
+		type DPCS_SYMCLK_GATE_DIS;\
+		type DPCS_SYMCLK_EN;\
+		type RDPCS_SYMCLK_DIV2_CLOCK_ON;\
+		type RDPCS_SYMCLK_DIV2_GATE_DIS;\
+		type RDPCS_SYMCLK_DIV2_EN;\
+		type DPCS_TX_DATA_SWAP;\
+		type DPCS_TX_DATA_ORDER_INVERT;\
+		type DPCS_TX_FIFO_RD_START_DELAY;\
+		type RDPCS_TX_FIFO_RD_START_DELAY;\
+		type RDPCS_REG_FIFO_ERROR_MASK;\
+		type RDPCS_TX_FIFO_ERROR_MASK;\
+		type RDPCS_DPALT_DISABLE_TOGGLE_MASK;\
+		type RDPCS_DPALT_4LANE_TOGGLE_MASK;\
+		type RDPCS_PHY_DPALT_DISABLE_ACK;\
+		type RDPCS_PHY_DP_MPLLB_V2I;\
+		type RDPCS_PHY_DP_MPLLB_FREQ_VCO;\
+		type RDPCS_PHY_DP_MPLLB_CP_INT;\
+		type RDPCS_PHY_DP_MPLLB_CP_PROP;\
+		type RDPCS_PHY_RX_REF_LD_VAL;\
+		type RDPCS_PHY_RX_VCO_LD_VAL;\
+		type DPCSTX_DEBUG_CONFIG; \
+		type RDPCSTX_DEBUG_CONFIG
+
+#define DCN20_LINK_ENCODER_REG_FIELD_LIST(type) \
+	type DIG_LANE0EN;\
+	type DIG_LANE1EN;\
+	type DIG_LANE2EN;\
+	type DIG_LANE3EN;\
+	type DIG_CLK_EN;\
+	type SYMCLKA_CLOCK_ENABLE;\
+	type DPHY_FEC_EN;\
+	type DPHY_FEC_READY_SHADOW;\
+	type DPHY_FEC_ACTIVE_STATUS;\
+	DCN20_LINK_ENCODER_DPCS_REG_FIELD_LIST(type);\
+	type VCO_LD_VAL_OVRD;\
+	type VCO_LD_VAL_OVRD_EN;\
+	type REF_LD_VAL_OVRD;\
+	type REF_LD_VAL_OVRD_EN;\
+	type AUX_RX_START_WINDOW; \
+	type AUX_RX_HALF_SYM_DETECT_LEN; \
+	type AUX_RX_TRANSITION_FILTER_EN; \
+	type AUX_RX_ALLOW_BELOW_THRESHOLD_PHASE_DETECT; \
+	type AUX_RX_ALLOW_BELOW_THRESHOLD_START; \
+	type AUX_RX_ALLOW_BELOW_THRESHOLD_STOP; \
+	type AUX_RX_PHASE_DETECT_LEN; \
+	type AUX_RX_DETECTION_THRESHOLD; \
+	type AUX_TX_PRECHARGE_LEN; \
+	type AUX_TX_PRECHARGE_SYMBOLS; \
+	type AUX_MODE_DET_CHECK_DELAY;\
+	type DPCS_DBG_CBUS_DIS
+#endif
+
 struct dcn10_link_enc_shift {
 	DCN_LINK_ENCODER_REG_FIELD_LIST(uint8_t);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	DCN20_LINK_ENCODER_REG_FIELD_LIST(uint8_t);
+#endif
 };
 
 struct dcn10_link_enc_mask {
 	DCN_LINK_ENCODER_REG_FIELD_LIST(uint32_t);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	DCN20_LINK_ENCODER_REG_FIELD_LIST(uint32_t);
+#endif
 };
 
 struct dcn10_link_encoder {
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_stream_encoder.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_stream_encoder.h
index 46c93ffc28d2..bc2b4af9543b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_stream_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_stream_encoder.h
@@ -82,6 +82,7 @@
 	SRI(DP_PIXEL_FORMAT, DP, id), \
 	SRI(DP_SEC_CNTL, DP, id), \
 	SRI(DP_SEC_CNTL2, DP, id), \
+	SRI(DP_SEC_CNTL6, DP, id), \
 	SRI(DP_STEER_FIFO, DP, id), \
 	SRI(DP_VID_M, DP, id), \
 	SRI(DP_VID_N, DP, id), \
@@ -125,6 +126,7 @@ struct dcn10_stream_enc_registers {
 	uint32_t DP_PIXEL_FORMAT;
 	uint32_t DP_SEC_CNTL;
 	uint32_t DP_SEC_CNTL2;
+	uint32_t DP_SEC_CNTL6;
 	uint32_t DP_STEER_FIFO;
 	uint32_t DP_VID_M;
 	uint32_t DP_VID_N;
@@ -153,12 +155,21 @@ struct dcn10_stream_enc_registers {
 	uint32_t HDMI_ACR_48_1;
 	uint32_t DP_DB_CNTL;
 	uint32_t DP_MSA_MISC;
+	uint32_t DP_MSA_VBID_MISC;
 	uint32_t DP_MSA_COLORIMETRY;
 	uint32_t DP_MSA_TIMING_PARAM1;
 	uint32_t DP_MSA_TIMING_PARAM2;
 	uint32_t DP_MSA_TIMING_PARAM3;
 	uint32_t DP_MSA_TIMING_PARAM4;
 	uint32_t HDMI_DB_CONTROL;
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	uint32_t DP_DSC_CNTL;
+	uint32_t DP_DSC_BYTES_PER_PIXEL;
+	uint32_t DME_CONTROL;
+	uint32_t DP_SEC_METADATA_TRANSMISSION;
+	uint32_t HDMI_METADATA_PACKET_CONTROL;
+	uint32_t DP_SEC_FRAMING4;
+#endif
 };
 
 
@@ -271,6 +282,7 @@ struct dcn10_stream_enc_registers {
 	SE_SF(DP0_DP_SEC_CNTL, DP_SEC_GSP7_ENABLE, mask_sh),\
 	SE_SF(DP0_DP_SEC_CNTL2, DP_SEC_GSP7_PPS, mask_sh),\
 	SE_SF(DP0_DP_SEC_CNTL2, DP_SEC_GSP7_SEND, mask_sh),\
+	SE_SF(DP0_DP_SEC_CNTL6, DP_SEC_GSP7_LINE_NUM, mask_sh),\
 	SE_SF(DP0_DP_DB_CNTL, DP_DB_DISABLE, mask_sh),\
 	SE_SF(DP0_DP_MSA_COLORIMETRY, DP_MSA_MISC0, mask_sh),\
 	SE_SF(DP0_DP_MSA_TIMING_PARAM1, DP_MSA_HTOTAL, mask_sh),\
@@ -424,6 +436,7 @@ struct dcn10_stream_enc_registers {
 	type DP_SEC_ATP_ENABLE;\
 	type DP_SEC_AIP_ENABLE;\
 	type DP_SEC_ACM_ENABLE;\
+	type DP_SEC_GSP7_LINE_NUM;\
 	type AFMT_AUDIO_SAMPLE_SEND;\
 	type AFMT_AUDIO_CLOCK_EN;\
 	type TMDS_PIXEL_ENCODING;\
@@ -447,12 +460,39 @@ struct dcn10_stream_enc_registers {
 	type DP_VID_M_DOUBLE_VALUE_EN;\
 	type DIG_SOURCE_SELECT
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+#define SE_REG_FIELD_LIST_DCN2_0(type) \
+	type DP_DSC_MODE;\
+	type DP_DSC_SLICE_WIDTH;\
+	type DP_DSC_BYTES_PER_PIXEL;\
+	type DP_VBID6_LINE_REFERENCE;\
+	type DP_VBID6_LINE_NUM;\
+	type METADATA_ENGINE_EN;\
+	type METADATA_HUBP_REQUESTOR_ID;\
+	type METADATA_STREAM_TYPE;\
+	type DP_SEC_METADATA_PACKET_ENABLE;\
+	type DP_SEC_METADATA_PACKET_LINE_REFERENCE;\
+	type DP_SEC_METADATA_PACKET_LINE;\
+	type HDMI_METADATA_PACKET_ENABLE;\
+	type HDMI_METADATA_PACKET_LINE_REFERENCE;\
+	type HDMI_METADATA_PACKET_LINE;\
+	type DOLBY_VISION_EN;\
+	type DP_PIXEL_COMBINE;\
+	type DP_SST_SDP_SPLITTING
+#endif
+
 struct dcn10_stream_encoder_shift {
 	SE_REG_FIELD_LIST_DCN1_0(uint8_t);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	SE_REG_FIELD_LIST_DCN2_0(uint8_t);
+#endif
 };
 
 struct dcn10_stream_encoder_mask {
 	SE_REG_FIELD_LIST_DCN1_0(uint32_t);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	SE_REG_FIELD_LIST_DCN2_0(uint32_t);
+#endif
 };
 
 struct dcn10_stream_encoder {
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.c
new file mode 100644
index 000000000000..290ebaacbabe
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.c
@@ -0,0 +1,438 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+
+#include "core_types.h"
+#include "link_encoder.h"
+#include "dcn20_link_encoder.h"
+#include "stream_encoder.h"
+#include "i2caux_interface.h"
+#include "dc_bios_types.h"
+
+#include "gpio_service_interface.h"
+
+#define CTX \
+	enc10->base.ctx
+#define DC_LOGGER \
+	enc10->base.ctx->logger
+
+#define REG(reg)\
+	(enc10->link_regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	enc10->link_shift->field_name, enc10->link_mask->field_name
+
+#define IND_REG(index) \
+	(enc10->link_regs->index)
+
+
+static struct mpll_cfg dcn2_mpll_cfg[] = {
+	// RBR
+	{
+		.hdmimode_enable = 1,
+		.ref_range = 3,
+		.ref_clk_mpllb_div = 2,
+		.mpllb_ssc_en = 1,
+		.mpllb_div5_clk_en = 1,
+		.mpllb_multiplier = 226,
+		.mpllb_fracn_en = 1,
+		.mpllb_fracn_quot = 39321,
+		.mpllb_fracn_rem = 3,
+		.mpllb_fracn_den = 5,
+		.mpllb_ssc_up_spread = 0,
+		.mpllb_ssc_peak = 38221,
+		.mpllb_ssc_stepsize = 49314,
+		.mpllb_div_clk_en = 0,
+		.mpllb_div_multiplier = 0,
+		.mpllb_hdmi_div = 0,
+		.mpllb_tx_clk_div = 2,
+		.tx_vboost_lvl = 4,
+		.mpllb_pmix_en = 1,
+		.mpllb_word_div2_en = 0,
+		.mpllb_ana_v2i = 2,
+		.mpllb_ana_freq_vco = 2,
+		.mpllb_ana_cp_int = 7,
+		.mpllb_ana_cp_prop = 18,
+		.hdmi_pixel_clk_div = 0,
+	},
+	// HBR
+	{
+		.hdmimode_enable = 1,
+		.ref_range = 3,
+		.ref_clk_mpllb_div = 2,
+		.mpllb_ssc_en = 1,
+		.mpllb_div5_clk_en = 1,
+		.mpllb_multiplier = 184,
+		.mpllb_fracn_en = 0,
+		.mpllb_fracn_quot = 0,
+		.mpllb_fracn_rem = 0,
+		.mpllb_fracn_den = 1,
+		.mpllb_ssc_up_spread = 0,
+		.mpllb_ssc_peak = 31850,
+		.mpllb_ssc_stepsize = 41095,
+		.mpllb_div_clk_en = 0,
+		.mpllb_div_multiplier = 0,
+		.mpllb_hdmi_div = 0,
+		.mpllb_tx_clk_div = 1,
+		.tx_vboost_lvl = 4,
+		.mpllb_pmix_en = 1,
+		.mpllb_word_div2_en = 0,
+		.mpllb_ana_v2i = 2,
+		.mpllb_ana_freq_vco = 3,
+		.mpllb_ana_cp_int = 7,
+		.mpllb_ana_cp_prop = 18,
+		.hdmi_pixel_clk_div = 0,
+	},
+	//HBR2
+	{
+		.hdmimode_enable = 1,
+		.ref_range = 3,
+		.ref_clk_mpllb_div = 2,
+		.mpllb_ssc_en = 1,
+		.mpllb_div5_clk_en = 1,
+		.mpllb_multiplier = 184,
+		.mpllb_fracn_en = 0,
+		.mpllb_fracn_quot = 0,
+		.mpllb_fracn_rem = 0,
+		.mpllb_fracn_den = 1,
+		.mpllb_ssc_up_spread = 0,
+		.mpllb_ssc_peak = 31850,
+		.mpllb_ssc_stepsize = 41095,
+		.mpllb_div_clk_en = 0,
+		.mpllb_div_multiplier = 0,
+		.mpllb_hdmi_div = 0,
+		.mpllb_tx_clk_div = 0,
+		.tx_vboost_lvl = 4,
+		.mpllb_pmix_en = 1,
+		.mpllb_word_div2_en = 0,
+		.mpllb_ana_v2i = 2,
+		.mpllb_ana_freq_vco = 3,
+		.mpllb_ana_cp_int = 7,
+		.mpllb_ana_cp_prop = 18,
+		.hdmi_pixel_clk_div = 0,
+	},
+	//HBR3
+	{
+		.hdmimode_enable = 1,
+		.ref_range = 3,
+		.ref_clk_mpllb_div = 2,
+		.mpllb_ssc_en = 1,
+		.mpllb_div5_clk_en = 1,
+		.mpllb_multiplier = 292,
+		.mpllb_fracn_en = 0,
+		.mpllb_fracn_quot = 0,
+		.mpllb_fracn_rem = 0,
+		.mpllb_fracn_den = 1,
+		.mpllb_ssc_up_spread = 0,
+		.mpllb_ssc_peak = 47776,
+		.mpllb_ssc_stepsize = 61642,
+		.mpllb_div_clk_en = 0,
+		.mpllb_div_multiplier = 0,
+		.mpllb_hdmi_div = 0,
+		.mpllb_tx_clk_div = 0,
+		.tx_vboost_lvl = 4,
+		.mpllb_pmix_en = 1,
+		.mpllb_word_div2_en = 0,
+		.mpllb_ana_v2i = 2,
+		.mpllb_ana_freq_vco = 0,
+		.mpllb_ana_cp_int = 7,
+		.mpllb_ana_cp_prop = 18,
+		.hdmi_pixel_clk_div = 0,
+	},
+};
+
+void enc2_fec_set_enable(struct link_encoder *enc, bool enable)
+{
+	struct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);
+	REG_UPDATE(DP_DPHY_CNTL, DPHY_FEC_EN, enable);
+}
+
+void enc2_fec_set_ready(struct link_encoder *enc, bool ready)
+{
+	struct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);
+
+	REG_UPDATE(DP_DPHY_CNTL, DPHY_FEC_READY_SHADOW, ready);
+}
+
+bool enc2_fec_is_active(struct link_encoder *enc)
+{
+	uint32_t active = 0;
+	struct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);
+
+	REG_GET(DP_DPHY_CNTL, DPHY_FEC_ACTIVE_STATUS, &active);
+
+	return (active != 0);
+}
+
+
+static bool update_cfg_data(
+		struct dcn10_link_encoder *enc10,
+		const struct dc_link_settings *link_settings,
+		struct dpcssys_phy_seq_cfg *cfg)
+{
+	int i;
+
+	cfg->load_sram_fw = false;
+
+	for (i = 0; i < link_settings->lane_count; i++)
+		cfg->lane_en[i] = true;
+
+	switch (link_settings->link_rate) {
+	case LINK_RATE_LOW:
+		cfg->mpll_cfg = dcn2_mpll_cfg[0];
+		break;
+	case LINK_RATE_HIGH:
+		cfg->mpll_cfg = dcn2_mpll_cfg[1];
+		break;
+	case LINK_RATE_HIGH2:
+		cfg->mpll_cfg = dcn2_mpll_cfg[2];
+		break;
+	case LINK_RATE_HIGH3:
+		cfg->mpll_cfg = dcn2_mpll_cfg[3];
+		break;
+	default:
+		DC_LOG_ERROR("%s: No supported link rate found %X!\n",
+				__func__, link_settings->link_rate);
+		return false;
+	}
+
+	return true;
+}
+
+static void dcn20_link_encoder_enable_dp_output(
+	struct link_encoder *enc,
+	const struct dc_link_settings *link_settings,
+	enum clock_source_id clock_source)
+{
+	struct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);
+	struct dcn20_link_encoder *enc20 = (struct dcn20_link_encoder *) enc10;
+	struct dpcssys_phy_seq_cfg *cfg = &enc20->phy_seq_cfg;
+
+	if (!enc->ctx->dc->debug.avoid_vbios_exec_table) {
+		dcn10_link_encoder_enable_dp_output(enc, link_settings, clock_source);
+		return;
+	}
+
+	if (!update_cfg_data(enc10, link_settings, cfg))
+		return;
+
+	enc1_configure_encoder(enc10, link_settings);
+
+	dcn10_link_encoder_setup(enc, SIGNAL_TYPE_DISPLAY_PORT);
+
+}
+
+#define AUX_REG(reg)\
+	(enc10->aux_regs->reg)
+
+#define AUX_REG_READ(reg_name) \
+		dm_read_reg(CTX, AUX_REG(reg_name))
+
+#define AUX_REG_WRITE(reg_name, val) \
+			dm_write_reg(CTX, AUX_REG(reg_name), val)
+void enc2_hw_init(struct link_encoder *enc)
+{
+	struct dcn10_link_encoder *enc10 = TO_DCN10_LINK_ENC(enc);
+
+/*
+	00 - DP_AUX_DPHY_RX_DETECTION_THRESHOLD__1to2 : 1/2
+	01 - DP_AUX_DPHY_RX_DETECTION_THRESHOLD__3to4 : 3/4
+	02 - DP_AUX_DPHY_RX_DETECTION_THRESHOLD__7to8 : 7/8
+	03 - DP_AUX_DPHY_RX_DETECTION_THRESHOLD__15to16 : 15/16
+	04 - DP_AUX_DPHY_RX_DETECTION_THRESHOLD__31to32 : 31/32
+	05 - DP_AUX_DPHY_RX_DETECTION_THRESHOLD__63to64 : 63/64
+	06 - DP_AUX_DPHY_RX_DETECTION_THRESHOLD__127to128 : 127/128
+	07 - DP_AUX_DPHY_RX_DETECTION_THRESHOLD__255to256 : 255/256
+*/
+
+/*
+	AUX_REG_UPDATE_5(AUX_DPHY_RX_CONTROL0,
+	AUX_RX_START_WINDOW = 1 [6:4]
+	AUX_RX_RECEIVE_WINDOW = 1 default is 2 [10:8]
+	AUX_RX_HALF_SYM_DETECT_LEN  = 1 [13:12] default is 1
+	AUX_RX_TRANSITION_FILTER_EN = 1 [16] default is 1
+	AUX_RX_ALLOW_BELOW_THRESHOLD_PHASE_DETECT [17] is 0  default is 0
+	AUX_RX_ALLOW_BELOW_THRESHOLD_START [18] is 1  default is 1
+	AUX_RX_ALLOW_BELOW_THRESHOLD_STOP [19] is 1  default is 1
+	AUX_RX_PHASE_DETECT_LEN,  [21,20] = 0x3 default is 3
+	AUX_RX_DETECTION_THRESHOLD [30:28] = 1
+*/
+	AUX_REG_WRITE(AUX_DPHY_RX_CONTROL0, 0x103d1110);
+
+	AUX_REG_WRITE(AUX_DPHY_TX_CONTROL, 0x21c7a);
+
+	//AUX_DPHY_TX_REF_CONTROL'AUX_TX_REF_DIV HW default is 0x32;
+	// Set AUX_TX_REF_DIV Divider to generate 2 MHz reference from refclk
+	// 27MHz -> 0xd
+	// 100MHz -> 0x32
+	// 48MHz -> 0x18
+
+	// Set TMDS_CTL0 to 1.  This is a legacy setting.
+	REG_UPDATE(TMDS_CTL_BITS, TMDS_CTL0, 1);
+
+	dcn10_aux_initialize(enc10);
+}
+
+static const struct link_encoder_funcs dcn20_link_enc_funcs = {
+	.validate_output_with_stream =
+		dcn10_link_encoder_validate_output_with_stream,
+	.hw_init = enc2_hw_init,
+	.setup = dcn10_link_encoder_setup,
+	.enable_tmds_output = dcn10_link_encoder_enable_tmds_output,
+	.enable_dp_output = dcn20_link_encoder_enable_dp_output,
+	.enable_dp_mst_output = dcn10_link_encoder_enable_dp_mst_output,
+	.disable_output = dcn10_link_encoder_disable_output,
+	.dp_set_lane_settings = dcn10_link_encoder_dp_set_lane_settings,
+	.dp_set_phy_pattern = dcn10_link_encoder_dp_set_phy_pattern,
+	.update_mst_stream_allocation_table =
+		dcn10_link_encoder_update_mst_stream_allocation_table,
+	.psr_program_dp_dphy_fast_training =
+			dcn10_psr_program_dp_dphy_fast_training,
+	.psr_program_secondary_packet = dcn10_psr_program_secondary_packet,
+	.connect_dig_be_to_fe = dcn10_link_encoder_connect_dig_be_to_fe,
+	.enable_hpd = dcn10_link_encoder_enable_hpd,
+	.disable_hpd = dcn10_link_encoder_disable_hpd,
+	.is_dig_enabled = dcn10_is_dig_enabled,
+	.destroy = dcn10_link_encoder_destroy,
+	.fec_set_enable = enc2_fec_set_enable,
+	.fec_set_ready = enc2_fec_set_ready,
+	.fec_is_active = enc2_fec_is_active,
+	.get_dig_frontend = dcn10_get_dig_frontend,
+};
+
+void dcn20_link_encoder_construct(
+	struct dcn20_link_encoder *enc20,
+	const struct encoder_init_data *init_data,
+	const struct encoder_feature_support *enc_features,
+	const struct dcn10_link_enc_registers *link_regs,
+	const struct dcn10_link_enc_aux_registers *aux_regs,
+	const struct dcn10_link_enc_hpd_registers *hpd_regs,
+	const struct dcn10_link_enc_shift *link_shift,
+	const struct dcn10_link_enc_mask *link_mask)
+{
+	struct bp_encoder_cap_info bp_cap_info = {0};
+	const struct dc_vbios_funcs *bp_funcs = init_data->ctx->dc_bios->funcs;
+	enum bp_result result = BP_RESULT_OK;
+	struct dcn10_link_encoder *enc10 = &enc20->enc10;
+
+	enc10->base.funcs = &dcn20_link_enc_funcs;
+	enc10->base.ctx = init_data->ctx;
+	enc10->base.id = init_data->encoder;
+
+	enc10->base.hpd_source = init_data->hpd_source;
+	enc10->base.connector = init_data->connector;
+
+	enc10->base.preferred_engine = ENGINE_ID_UNKNOWN;
+
+	enc10->base.features = *enc_features;
+
+	enc10->base.transmitter = init_data->transmitter;
+
+	/* set the flag to indicate whether driver poll the I2C data pin
+	 * while doing the DP sink detect
+	 */
+
+/*	if (dal_adapter_service_is_feature_supported(as,
+		FEATURE_DP_SINK_DETECT_POLL_DATA_PIN))
+		enc10->base.features.flags.bits.
+			DP_SINK_DETECT_POLL_DATA_PIN = true;*/
+
+	enc10->base.output_signals =
+		SIGNAL_TYPE_DVI_SINGLE_LINK |
+		SIGNAL_TYPE_DVI_DUAL_LINK |
+		SIGNAL_TYPE_LVDS |
+		SIGNAL_TYPE_DISPLAY_PORT |
+		SIGNAL_TYPE_DISPLAY_PORT_MST |
+		SIGNAL_TYPE_EDP |
+		SIGNAL_TYPE_HDMI_TYPE_A;
+
+	/* For DCE 8.0 and 8.1, by design, UNIPHY is hardwired to DIG_BE.
+	 * SW always assign DIG_FE 1:1 mapped to DIG_FE for non-MST UNIPHY.
+	 * SW assign DIG_FE to non-MST UNIPHY first and MST last. So prefer
+	 * DIG is per UNIPHY and used by SST DP, eDP, HDMI, DVI and LVDS.
+	 * Prefer DIG assignment is decided by board design.
+	 * For DCE 8.0, there are only max 6 UNIPHYs, we assume board design
+	 * and VBIOS will filter out 7 UNIPHY for DCE 8.0.
+	 * By this, adding DIGG should not hurt DCE 8.0.
+	 * This will let DCE 8.1 share DCE 8.0 as much as possible
+	 */
+
+	enc10->link_regs = link_regs;
+	enc10->aux_regs = aux_regs;
+	enc10->hpd_regs = hpd_regs;
+	enc10->link_shift = link_shift;
+	enc10->link_mask = link_mask;
+
+	switch (enc10->base.transmitter) {
+	case TRANSMITTER_UNIPHY_A:
+		enc10->base.preferred_engine = ENGINE_ID_DIGA;
+	break;
+	case TRANSMITTER_UNIPHY_B:
+		enc10->base.preferred_engine = ENGINE_ID_DIGB;
+	break;
+	case TRANSMITTER_UNIPHY_C:
+		enc10->base.preferred_engine = ENGINE_ID_DIGC;
+	break;
+	case TRANSMITTER_UNIPHY_D:
+		enc10->base.preferred_engine = ENGINE_ID_DIGD;
+	break;
+	case TRANSMITTER_UNIPHY_E:
+		enc10->base.preferred_engine = ENGINE_ID_DIGE;
+	break;
+	case TRANSMITTER_UNIPHY_F:
+		enc10->base.preferred_engine = ENGINE_ID_DIGF;
+	break;
+	case TRANSMITTER_UNIPHY_G:
+		enc10->base.preferred_engine = ENGINE_ID_DIGG;
+	break;
+	default:
+		ASSERT_CRITICAL(false);
+		enc10->base.preferred_engine = ENGINE_ID_UNKNOWN;
+	}
+
+	/* default to one to mirror Windows behavior */
+	enc10->base.features.flags.bits.HDMI_6GB_EN = 1;
+
+	result = bp_funcs->get_encoder_cap_info(enc10->base.ctx->dc_bios,
+						enc10->base.id, &bp_cap_info);
+
+	/* Override features with DCE-specific values */
+	if (result == BP_RESULT_OK) {
+		enc10->base.features.flags.bits.IS_HBR2_CAPABLE =
+				bp_cap_info.DP_HBR2_EN;
+		enc10->base.features.flags.bits.IS_HBR3_CAPABLE =
+				bp_cap_info.DP_HBR3_EN;
+		enc10->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;
+	} else {
+		DC_LOG_WARNING("%s: Failed to get encoder_cap_info from VBIOS with error code %d!\n",
+				__func__,
+				result);
+	}
+	if (enc10->base.ctx->dc->debug.hdmi20_disable) {
+		enc10->base.features.flags.bits.HDMI_6GB_EN = 0;
+	}
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.h b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.h
new file mode 100644
index 000000000000..c67755779079
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_link_encoder.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *  and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_LINK_ENCODER__DCN20_H__
+#define __DC_LINK_ENCODER__DCN20_H__
+
+#include "dcn10/dcn10_link_encoder.h"
+
+#define DCN2_AUX_REG_LIST(id)\
+	AUX_REG_LIST(id), \
+	SRI(AUX_DPHY_TX_CONTROL, DP_AUX, id)
+
+#define UNIPHY_MASK_SH_LIST(mask_sh)\
+	LE_SF(UNIPHYA_CHANNEL_XBAR_CNTL, UNIPHY_LINK_ENABLE, mask_sh)
+
+#define LINK_ENCODER_MASK_SH_LIST_DCN20(mask_sh)\
+	LINK_ENCODER_MASK_SH_LIST_DCN10(mask_sh),\
+	LE_SF(DP0_DP_DPHY_CNTL, DPHY_FEC_EN, mask_sh),\
+	LE_SF(DP0_DP_DPHY_CNTL, DPHY_FEC_READY_SHADOW, mask_sh),\
+	LE_SF(DP0_DP_DPHY_CNTL, DPHY_FEC_ACTIVE_STATUS, mask_sh),\
+	LE_SF(DIG0_DIG_LANE_ENABLE, DIG_LANE0EN, mask_sh),\
+	LE_SF(DIG0_DIG_LANE_ENABLE, DIG_LANE1EN, mask_sh),\
+	LE_SF(DIG0_DIG_LANE_ENABLE, DIG_LANE2EN, mask_sh),\
+	LE_SF(DIG0_DIG_LANE_ENABLE, DIG_LANE3EN, mask_sh),\
+	LE_SF(DIG0_DIG_LANE_ENABLE, DIG_CLK_EN, mask_sh),\
+	LE_SF(DIG0_TMDS_CTL_BITS, TMDS_CTL0, mask_sh), \
+	UNIPHY_MASK_SH_LIST(mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_RX_CONTROL0, AUX_RX_START_WINDOW, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_RX_CONTROL0, AUX_RX_HALF_SYM_DETECT_LEN, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_RX_CONTROL0, AUX_RX_TRANSITION_FILTER_EN, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_RX_CONTROL0, AUX_RX_ALLOW_BELOW_THRESHOLD_PHASE_DETECT, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_RX_CONTROL0, AUX_RX_ALLOW_BELOW_THRESHOLD_START, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_RX_CONTROL0, AUX_RX_ALLOW_BELOW_THRESHOLD_STOP, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_RX_CONTROL0, AUX_RX_PHASE_DETECT_LEN, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_RX_CONTROL0, AUX_RX_DETECTION_THRESHOLD, mask_sh), \
+	LE_SF(DP_AUX0_AUX_DPHY_TX_CONTROL, AUX_TX_PRECHARGE_LEN, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_TX_CONTROL, AUX_TX_PRECHARGE_SYMBOLS, mask_sh),\
+	LE_SF(DP_AUX0_AUX_DPHY_TX_CONTROL, AUX_MODE_DET_CHECK_DELAY, mask_sh)
+
+#define UNIPHY_DCN2_REG_LIST(id) \
+	SRI(CLOCK_ENABLE, SYMCLK, id), \
+	SRI(CHANNEL_XBAR_CNTL, UNIPHY, id)
+
+struct mpll_cfg {
+	uint32_t mpllb_ana_v2i;
+	uint32_t mpllb_ana_freq_vco;
+	uint32_t mpllb_ana_cp_int;
+	uint32_t mpllb_ana_cp_prop;
+	uint32_t mpllb_multiplier;
+	uint32_t ref_clk_mpllb_div;
+	bool mpllb_word_div2_en;
+	bool mpllb_ssc_en;
+	bool mpllb_div5_clk_en;
+	bool mpllb_div_clk_en;
+	bool mpllb_fracn_en;
+	bool mpllb_pmix_en;
+	uint32_t mpllb_div_multiplier;
+	uint32_t mpllb_tx_clk_div;
+	uint32_t mpllb_fracn_quot;
+	uint32_t mpllb_fracn_den;
+	uint32_t mpllb_ssc_peak;
+	uint32_t mpllb_ssc_stepsize;
+	uint32_t mpllb_ssc_up_spread;
+	uint32_t mpllb_fracn_rem;
+	uint32_t mpllb_hdmi_div;
+	// TODO: May not mpll params, need to figure out.
+	uint32_t tx_vboost_lvl;
+	uint32_t hdmi_pixel_clk_div;
+	uint32_t ref_range;
+	uint32_t ref_clk;
+	bool hdmimode_enable;
+};
+
+struct dpcssys_phy_seq_cfg {
+	bool program_fuse;
+	bool bypass_sram;
+	bool lane_en[4];
+	bool use_calibration_setting;
+	struct mpll_cfg mpll_cfg;
+	bool load_sram_fw;
+#if 0
+
+	bool hdmimode_enable;
+	bool silver2;
+	bool ext_refclk_en;
+	uint32_t dp_tx0_term_ctrl;
+	uint32_t dp_tx1_term_ctrl;
+	uint32_t dp_tx2_term_ctrl;
+	uint32_t dp_tx3_term_ctrl;
+	uint32_t fw_data[0x1000];
+	uint32_t dp_tx0_width;
+	uint32_t dp_tx1_width;
+	uint32_t dp_tx2_width;
+	uint32_t dp_tx3_width;
+	uint32_t dp_tx0_rate;
+	uint32_t dp_tx1_rate;
+	uint32_t dp_tx2_rate;
+	uint32_t dp_tx3_rate;
+	uint32_t dp_tx0_eq_main;
+	uint32_t dp_tx0_eq_pre;
+	uint32_t dp_tx0_eq_post;
+	uint32_t dp_tx1_eq_main;
+	uint32_t dp_tx1_eq_pre;
+	uint32_t dp_tx1_eq_post;
+	uint32_t dp_tx2_eq_main;
+	uint32_t dp_tx2_eq_pre;
+	uint32_t dp_tx2_eq_post;
+	uint32_t dp_tx3_eq_main;
+	uint32_t dp_tx3_eq_pre;
+	uint32_t dp_tx3_eq_post;
+	bool data_swap_en;
+	bool data_order_invert_en;
+	uint32_t ldpcs_fifo_start_delay;
+	uint32_t rdpcs_fifo_start_delay;
+	bool rdpcs_reg_fifo_error_mask;
+	bool rdpcs_tx_fifo_error_mask;
+	bool rdpcs_dpalt_disable_mask;
+	bool rdpcs_dpalt_4lane_mask;
+#endif
+};
+
+struct dcn20_link_encoder {
+	struct dcn10_link_encoder enc10;
+	struct dpcssys_phy_seq_cfg phy_seq_cfg;
+};
+
+void enc2_fec_set_enable(struct link_encoder *enc, bool enable);
+void enc2_fec_set_ready(struct link_encoder *enc, bool ready);
+bool enc2_fec_is_active(struct link_encoder *enc);
+void enc2_hw_init(struct link_encoder *enc);
+
+
+void dcn20_link_encoder_construct(
+	struct dcn20_link_encoder *enc20,
+	const struct encoder_init_data *init_data,
+	const struct encoder_feature_support *enc_features,
+	const struct dcn10_link_enc_registers *link_regs,
+	const struct dcn10_link_enc_aux_registers *aux_regs,
+	const struct dcn10_link_enc_hpd_registers *hpd_regs,
+	const struct dcn10_link_enc_shift *link_shift,
+	const struct dcn10_link_enc_mask *link_mask);
+
+#endif /* __DC_LINK_ENCODER__DCN20_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
new file mode 100644
index 000000000000..c38c85c8e3b9
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -0,0 +1,440 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *  and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dc_bios_types.h"
+#include "dcn20_stream_encoder.h"
+#include "reg_helper.h"
+#include "hw_shared.h"
+
+#define DC_LOGGER \
+		enc1->base.ctx->logger
+
+
+#define REG(reg)\
+	(enc1->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	enc1->se_shift->field_name, enc1->se_mask->field_name
+
+
+#define CTX \
+	enc1->base.ctx
+
+
+static void enc2_update_hdmi_info_packet(
+	struct dcn10_stream_encoder *enc1,
+	uint32_t packet_index,
+	const struct dc_info_packet *info_packet)
+{
+	uint32_t cont, send, line;
+
+	if (info_packet->valid) {
+		enc1_update_generic_info_packet(
+			enc1,
+			packet_index,
+			info_packet);
+
+		/* enable transmission of packet(s) -
+		 * packet transmission begins on the next frame */
+		cont = 1;
+		/* send packet(s) every frame */
+		send = 1;
+		/* select line number to send packets on */
+		line = 2;
+	} else {
+		cont = 0;
+		send = 0;
+		line = 0;
+	}
+
+	/* DP_SEC_GSP[x]_LINE_REFERENCE - keep default value REFER_TO_DP_SOF */
+
+	/* choose which generic packet control to use */
+	switch (packet_index) {
+	case 0:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC0_CONT, cont,
+				HDMI_GENERIC0_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL1,
+				HDMI_GENERIC0_LINE, line);
+		break;
+	case 1:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC1_CONT, cont,
+				HDMI_GENERIC1_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL1,
+				HDMI_GENERIC1_LINE, line);
+		break;
+	case 2:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC2_CONT, cont,
+				HDMI_GENERIC2_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL2,
+				HDMI_GENERIC2_LINE, line);
+		break;
+	case 3:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC3_CONT, cont,
+				HDMI_GENERIC3_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL2,
+				HDMI_GENERIC3_LINE, line);
+		break;
+	case 4:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC4_CONT, cont,
+				HDMI_GENERIC4_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL3,
+				HDMI_GENERIC4_LINE, line);
+		break;
+	case 5:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC5_CONT, cont,
+				HDMI_GENERIC5_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL3,
+				HDMI_GENERIC5_LINE, line);
+		break;
+	case 6:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC6_CONT, cont,
+				HDMI_GENERIC6_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL4,
+				HDMI_GENERIC6_LINE, line);
+		break;
+	case 7:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC7_CONT, cont,
+				HDMI_GENERIC7_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL4,
+				HDMI_GENERIC7_LINE, line);
+		break;
+	default:
+		/* invalid HW packet index */
+		DC_LOG_WARNING(
+			"Invalid HW packet index: %s()\n",
+			__func__);
+		return;
+	}
+}
+
+static void enc2_stream_encoder_update_hdmi_info_packets(
+	struct stream_encoder *enc,
+	const struct encoder_info_frame *info_frame)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	/* for bring up, disable dp double  TODO */
+	REG_UPDATE(HDMI_DB_CONTROL, HDMI_DB_DISABLE, 1);
+
+	/*Always add mandatory packets first followed by optional ones*/
+	enc2_update_hdmi_info_packet(enc1, 0, &info_frame->avi);
+	enc2_update_hdmi_info_packet(enc1, 5, &info_frame->hfvsif);
+	enc2_update_hdmi_info_packet(enc1, 2, &info_frame->gamut);
+	enc2_update_hdmi_info_packet(enc1, 1, &info_frame->vendor);
+	enc2_update_hdmi_info_packet(enc1, 3, &info_frame->spd);
+	enc2_update_hdmi_info_packet(enc1, 4, &info_frame->hdrsmd);
+}
+
+static void enc2_stream_encoder_stop_hdmi_info_packets(
+	struct stream_encoder *enc)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	/* stop generic packets 0,1 on HDMI */
+	REG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,
+		HDMI_GENERIC0_CONT, 0,
+		HDMI_GENERIC0_SEND, 0,
+		HDMI_GENERIC1_CONT, 0,
+		HDMI_GENERIC1_SEND, 0);
+	REG_SET_2(HDMI_GENERIC_PACKET_CONTROL1, 0,
+		HDMI_GENERIC0_LINE, 0,
+		HDMI_GENERIC1_LINE, 0);
+
+	/* stop generic packets 2,3 on HDMI */
+	REG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,
+		HDMI_GENERIC2_CONT, 0,
+		HDMI_GENERIC2_SEND, 0,
+		HDMI_GENERIC3_CONT, 0,
+		HDMI_GENERIC3_SEND, 0);
+	REG_SET_2(HDMI_GENERIC_PACKET_CONTROL2, 0,
+		HDMI_GENERIC2_LINE, 0,
+		HDMI_GENERIC3_LINE, 0);
+
+	/* stop generic packets 4,5 on HDMI */
+	REG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,
+		HDMI_GENERIC4_CONT, 0,
+		HDMI_GENERIC4_SEND, 0,
+		HDMI_GENERIC5_CONT, 0,
+		HDMI_GENERIC5_SEND, 0);
+	REG_SET_2(HDMI_GENERIC_PACKET_CONTROL3, 0,
+		HDMI_GENERIC4_LINE, 0,
+		HDMI_GENERIC5_LINE, 0);
+
+	/* stop generic packets 6,7 on HDMI */
+	REG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,
+		HDMI_GENERIC6_CONT, 0,
+		HDMI_GENERIC6_SEND, 0,
+		HDMI_GENERIC7_CONT, 0,
+		HDMI_GENERIC7_SEND, 0);
+	REG_SET_2(HDMI_GENERIC_PACKET_CONTROL4, 0,
+		HDMI_GENERIC6_LINE, 0,
+		HDMI_GENERIC7_LINE, 0);
+}
+
+
+
+/* Set Dynamic Metadata-configuration.
+ *   enable_dme:         TRUE: enables Dynamic Metadata Enfine, FALSE: disables DME
+ *   hubp_requestor_id:  HUBP physical instance that is the source of dynamic metadata
+ *                       only needs to be set when enable_dme is TRUE
+ *   dmdata_mode:        dynamic metadata packet type: DP, HDMI, or Dolby Vision
+ *
+ *   Ensure the OTG master update lock is set when changing DME configuration.
+ */
+static void enc2_set_dynamic_metadata(struct stream_encoder *enc,
+		bool enable_dme,
+		uint32_t hubp_requestor_id,
+		enum dynamic_metadata_mode dmdata_mode)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	if (enable_dme) {
+		REG_UPDATE_2(DME_CONTROL,
+				METADATA_HUBP_REQUESTOR_ID, hubp_requestor_id,
+				METADATA_STREAM_TYPE, (dmdata_mode == dmdata_dolby_vision) ? 1 : 0);
+
+		/* Use default line reference DP_SOF for bringup.
+		 * Should use OTG_SOF for DRR cases
+		 */
+		if (dmdata_mode == dmdata_dp)
+			REG_UPDATE_3(DP_SEC_METADATA_TRANSMISSION,
+					DP_SEC_METADATA_PACKET_ENABLE, 1,
+					DP_SEC_METADATA_PACKET_LINE_REFERENCE, 0,
+					DP_SEC_METADATA_PACKET_LINE, 20);
+		else {
+			REG_UPDATE_3(HDMI_METADATA_PACKET_CONTROL,
+					HDMI_METADATA_PACKET_ENABLE, 1,
+					HDMI_METADATA_PACKET_LINE_REFERENCE, 0,
+					HDMI_METADATA_PACKET_LINE, 2);
+
+			if (dmdata_mode == dmdata_dolby_vision)
+				REG_UPDATE(DIG_FE_CNTL,
+						DOLBY_VISION_EN, 1);
+		}
+
+		REG_UPDATE(DME_CONTROL,
+				METADATA_ENGINE_EN, 1);
+	} else {
+		REG_UPDATE(DME_CONTROL,
+				METADATA_ENGINE_EN, 0);
+
+		if (dmdata_mode == dmdata_dp)
+			REG_UPDATE(DP_SEC_METADATA_TRANSMISSION,
+					DP_SEC_METADATA_PACKET_ENABLE, 0);
+		else {
+			REG_UPDATE(HDMI_METADATA_PACKET_CONTROL,
+					HDMI_METADATA_PACKET_ENABLE, 0);
+			REG_UPDATE(DIG_FE_CNTL,
+					DOLBY_VISION_EN, 0);
+		}
+	}
+}
+
+static void enc2_stream_encoder_update_dp_info_packets(
+	struct stream_encoder *enc,
+	const struct encoder_info_frame *info_frame)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+	uint32_t dmdata_packet_enabled = 0;
+
+	enc1_stream_encoder_update_dp_info_packets(enc, info_frame);
+
+	/* check if dynamic metadata packet transmission is enabled */
+	REG_GET(DP_SEC_METADATA_TRANSMISSION,
+			DP_SEC_METADATA_PACKET_ENABLE, &dmdata_packet_enabled);
+
+	if (dmdata_packet_enabled)
+		REG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);
+}
+
+static bool is_two_pixels_per_containter(const struct dc_crtc_timing *timing)
+{
+	bool two_pix = timing->pixel_encoding == PIXEL_ENCODING_YCBCR420;
+
+	return two_pix;
+}
+
+static void enc2_stream_encoder_dp_unblank(
+		struct stream_encoder *enc,
+		const struct encoder_unblank_param *param)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	if (param->link_settings.link_rate != LINK_RATE_UNKNOWN) {
+		uint32_t n_vid = 0x8000;
+		uint32_t m_vid;
+		uint32_t n_multiply = 0;
+		uint64_t m_vid_l = n_vid;
+
+		/* YCbCr 4:2:0 : Computed VID_M will be 2X the input rate */
+		if (is_two_pixels_per_containter(&param->timing) || param->odm) {
+			/*this logic should be the same in get_pixel_clock_parameters() */
+			n_multiply = 1;
+		}
+		/* M / N = Fstream / Flink
+		 * m_vid / n_vid = pixel rate / link rate
+		 */
+
+		m_vid_l *= param->timing.pix_clk_100hz / 10;
+		m_vid_l = div_u64(m_vid_l,
+			param->link_settings.link_rate
+				* LINK_RATE_REF_FREQ_IN_KHZ);
+
+		m_vid = (uint32_t) m_vid_l;
+
+		/* enable auto measurement */
+
+		REG_UPDATE(DP_VID_TIMING, DP_VID_M_N_GEN_EN, 0);
+
+		/* auto measurement need 1 full 0x8000 symbol cycle to kick in,
+		 * therefore program initial value for Mvid and Nvid
+		 */
+
+		REG_UPDATE(DP_VID_N, DP_VID_N, n_vid);
+
+		REG_UPDATE(DP_VID_M, DP_VID_M, m_vid);
+
+		REG_UPDATE_2(DP_VID_TIMING,
+				DP_VID_M_N_GEN_EN, 1,
+				DP_VID_N_MUL, n_multiply);
+	}
+
+	/* set DIG_START to 0x1 to reset FIFO */
+
+	REG_UPDATE(DIG_FE_CNTL, DIG_START, 1);
+
+	/* write 0 to take the FIFO out of reset */
+
+	REG_UPDATE(DIG_FE_CNTL, DIG_START, 0);
+
+	/* switch DP encoder to CRTC data */
+
+	REG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 0);
+
+	/* wait 100us for DIG/DP logic to prime
+	 * (i.e. a few video lines)
+	 */
+	udelay(100);
+
+	/* the hardware would start sending video at the start of the next DP
+	 * frame (i.e. rising edge of the vblank).
+	 * NOTE: We used to program DP_VID_STREAM_DIS_DEFER = 2 here, but this
+	 * register has no effect on enable transition! HW always guarantees
+	 * VID_STREAM enable at start of next frame, and this is not
+	 * programmable
+	 */
+
+	REG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, true);
+}
+
+static void enc2_dp_set_odm_combine(
+	struct stream_encoder *enc,
+	bool odm_combine)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	REG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_COMBINE, odm_combine);
+}
+
+static void enc2_stream_encoder_dp_set_stream_attribute(
+	struct stream_encoder *enc,
+	struct dc_crtc_timing *crtc_timing,
+	enum dc_color_space output_color_space,
+	uint32_t enable_sdp_splitting)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	enc1_stream_encoder_dp_set_stream_attribute(enc, crtc_timing, output_color_space, enable_sdp_splitting);
+
+	REG_UPDATE(DP_SEC_FRAMING4,
+		DP_SST_SDP_SPLITTING, enable_sdp_splitting);
+}
+
+static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
+	.dp_set_odm_combine =
+		enc2_dp_set_odm_combine,
+	.dp_set_stream_attribute =
+		enc2_stream_encoder_dp_set_stream_attribute,
+	.hdmi_set_stream_attribute =
+		enc1_stream_encoder_hdmi_set_stream_attribute,
+	.dvi_set_stream_attribute =
+		enc1_stream_encoder_dvi_set_stream_attribute,
+	.set_mst_bandwidth =
+		enc1_stream_encoder_set_mst_bandwidth,
+	.update_hdmi_info_packets =
+		enc2_stream_encoder_update_hdmi_info_packets,
+	.stop_hdmi_info_packets =
+		enc2_stream_encoder_stop_hdmi_info_packets,
+	.update_dp_info_packets =
+		enc2_stream_encoder_update_dp_info_packets,
+	.stop_dp_info_packets =
+		enc1_stream_encoder_stop_dp_info_packets,
+	.dp_blank =
+		enc1_stream_encoder_dp_blank,
+	.dp_unblank =
+		enc2_stream_encoder_dp_unblank,
+	.audio_mute_control = enc1_se_audio_mute_control,
+
+	.dp_audio_setup = enc1_se_dp_audio_setup,
+	.dp_audio_enable = enc1_se_dp_audio_enable,
+	.dp_audio_disable = enc1_se_dp_audio_disable,
+
+	.hdmi_audio_setup = enc1_se_hdmi_audio_setup,
+	.hdmi_audio_disable = enc1_se_hdmi_audio_disable,
+	.setup_stereo_sync  = enc1_setup_stereo_sync,
+	.set_avmute = enc1_stream_encoder_set_avmute,
+	.dig_connect_to_otg  = enc1_dig_connect_to_otg,
+
+	.set_dynamic_metadata = enc2_set_dynamic_metadata,
+};
+
+void dcn20_stream_encoder_construct(
+	struct dcn10_stream_encoder *enc1,
+	struct dc_context *ctx,
+	struct dc_bios *bp,
+	enum engine_id eng_id,
+	const struct dcn10_stream_enc_registers *regs,
+	const struct dcn10_stream_encoder_shift *se_shift,
+	const struct dcn10_stream_encoder_mask *se_mask)
+{
+	enc1->base.funcs = &dcn20_str_enc_funcs;
+	enc1->base.ctx = ctx;
+	enc1->base.id = eng_id;
+	enc1->base.bp = bp;
+	enc1->regs = regs;
+	enc1->se_shift = se_shift;
+	enc1->se_mask = se_mask;
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.h b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.h
new file mode 100644
index 000000000000..60f4183d57ed
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *  and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_STREAM_ENCODER_DCN20_H__
+#define __DC_STREAM_ENCODER_DCN20_H__
+
+#include "stream_encoder.h"
+#include "dcn10/dcn10_stream_encoder.h"
+
+
+#define SE_DCN2_REG_LIST(id)\
+	SE_COMMON_DCN_REG_LIST(id),\
+	SRI(HDMI_GENERIC_PACKET_CONTROL4, DIG, id), \
+	SRI(HDMI_GENERIC_PACKET_CONTROL5, DIG, id), \
+	SRI(DP_DSC_CNTL, DP, id), \
+	SRI(DP_DSC_BYTES_PER_PIXEL, DP, id), \
+	SRI(DME_CONTROL, DIG, id),\
+	SRI(DP_SEC_METADATA_TRANSMISSION, DP, id), \
+	SRI(HDMI_METADATA_PACKET_CONTROL, DIG, id), \
+	SRI(DP_SEC_FRAMING4, DP, id)
+
+#define SE_COMMON_MASK_SH_LIST_DCN20(mask_sh)\
+	SE_COMMON_MASK_SH_LIST_SOC(mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC0_CONT, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC0_SEND, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC1_CONT, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC1_SEND, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC2_CONT, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC2_SEND, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC3_CONT, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC3_SEND, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC4_CONT, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC4_SEND, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC5_CONT, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC5_SEND, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC6_CONT, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC6_SEND, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC7_CONT, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL0, HDMI_GENERIC7_SEND, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL1, HDMI_GENERIC0_LINE, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL1, HDMI_GENERIC1_LINE, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL2, HDMI_GENERIC2_LINE, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL2, HDMI_GENERIC3_LINE, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL3, HDMI_GENERIC4_LINE, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL3, HDMI_GENERIC5_LINE, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL4, HDMI_GENERIC6_LINE, mask_sh),\
+	SE_SF(DIG0_HDMI_GENERIC_PACKET_CONTROL4, HDMI_GENERIC7_LINE, mask_sh),\
+	SE_SF(DP0_DP_DSC_CNTL, DP_DSC_MODE, mask_sh),\
+	SE_SF(DP0_DP_DSC_CNTL, DP_DSC_SLICE_WIDTH, mask_sh),\
+	SE_SF(DP0_DP_DSC_BYTES_PER_PIXEL, DP_DSC_BYTES_PER_PIXEL, mask_sh),\
+	SE_SF(DP0_DP_MSA_VBID_MISC, DP_VBID6_LINE_REFERENCE, mask_sh),\
+	SE_SF(DP0_DP_MSA_VBID_MISC, DP_VBID6_LINE_NUM, mask_sh),\
+	SE_SF(DIG0_DME_CONTROL, METADATA_ENGINE_EN, mask_sh),\
+	SE_SF(DIG0_DME_CONTROL, METADATA_HUBP_REQUESTOR_ID, mask_sh),\
+	SE_SF(DIG0_DME_CONTROL, METADATA_STREAM_TYPE, mask_sh),\
+	SE_SF(DP0_DP_SEC_METADATA_TRANSMISSION, DP_SEC_METADATA_PACKET_ENABLE, mask_sh),\
+	SE_SF(DP0_DP_SEC_METADATA_TRANSMISSION, DP_SEC_METADATA_PACKET_LINE_REFERENCE, mask_sh),\
+	SE_SF(DP0_DP_SEC_METADATA_TRANSMISSION, DP_SEC_METADATA_PACKET_LINE, mask_sh),\
+	SE_SF(DIG0_HDMI_METADATA_PACKET_CONTROL, HDMI_METADATA_PACKET_ENABLE, mask_sh),\
+	SE_SF(DIG0_HDMI_METADATA_PACKET_CONTROL, HDMI_METADATA_PACKET_LINE_REFERENCE, mask_sh),\
+	SE_SF(DIG0_HDMI_METADATA_PACKET_CONTROL, HDMI_METADATA_PACKET_LINE, mask_sh),\
+	SE_SF(DIG0_DIG_FE_CNTL, DOLBY_VISION_EN, mask_sh),\
+	SE_SF(DP0_DP_PIXEL_FORMAT, DP_PIXEL_COMBINE, mask_sh),\
+	SE_SF(DP0_DP_SEC_FRAMING4, DP_SST_SDP_SPLITTING, mask_sh)
+
+void dcn20_stream_encoder_construct(
+	struct dcn10_stream_encoder *enc1,
+	struct dc_context *ctx,
+	struct dc_bios *bp,
+	enum engine_id eng_id,
+	const struct dcn10_stream_enc_registers *regs,
+	const struct dcn10_stream_encoder_shift *se_shift,
+	const struct dcn10_stream_encoder_mask *se_mask);
+
+#endif /* __DC_STREAM_ENCODER_DCN20_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h b/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
index ca162079a41b..46de4a00f61b 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
@@ -113,8 +113,12 @@ struct link_encoder {
 	struct encoder_feature_support features;
 	enum transmitter transmitter;
 	enum hpd_source_id hpd_source;
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+	bool usbc_combo_phy;
+#endif
 };
 
+
 struct link_encoder_funcs {
 	bool (*validate_output_with_stream)(
 		struct link_encoder *enc, const struct dc_stream_state *stream);
@@ -156,6 +160,16 @@ struct link_encoder_funcs {
 	bool (*is_dig_enabled)(struct link_encoder *enc);
 	unsigned int (*get_dig_frontend)(struct link_encoder *enc);
 	void (*destroy)(struct link_encoder **enc);
+
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	void (*fec_set_enable)(struct link_encoder *enc,
+		bool enable);
+
+	void (*fec_set_ready)(struct link_encoder *enc,
+		bool ready);
+
+	bool (*fec_is_active)(struct link_encoder *enc);
+#endif
 };
 
 #endif /* LINK_ENCODER_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/stream_encoder.h b/drivers/gpu/drm/amd/display/dc/inc/hw/stream_encoder.h
index 74db1d82fa35..f84ce4de53ca 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/stream_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/stream_encoder.h
@@ -65,11 +65,20 @@ struct audio_clock_info {
 	uint32_t cts_48khz;
 };
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+enum dynamic_metadata_mode {
+	dmdata_dp,
+	dmdata_hdmi,
+	dmdata_dolby_vision
+};
+#endif
+
 struct encoder_info_frame {
 	/* auxiliary video information */
 	struct dc_info_packet avi;
 	struct dc_info_packet gamut;
 	struct dc_info_packet vendor;
+	struct dc_info_packet hfvsif;
 	/* source product description */
 	struct dc_info_packet spd;
 	/* video stream configuration */
@@ -81,6 +90,9 @@ struct encoder_info_frame {
 struct encoder_unblank_param {
 	struct dc_link_settings link_settings;
 	struct dc_crtc_timing timing;
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+	bool odm;
+#endif
 };
 
 struct encoder_set_dp_phy_pattern_param {
@@ -97,6 +109,7 @@ struct stream_encoder {
 	enum engine_id id;
 };
 
+
 struct stream_encoder_funcs {
 	void (*dp_set_stream_attribute)(
 		struct stream_encoder *enc,
@@ -184,6 +197,17 @@ struct stream_encoder_funcs {
 		struct stream_encoder *enc,
 		int tg_inst);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+
+	void (*set_dynamic_metadata)(struct stream_encoder *enc,
+			bool enable,
+			uint32_t hubp_requestor_id,
+			enum dynamic_metadata_mode dmdata_mode);
+
+	void (*dp_set_odm_combine)(
+		struct stream_encoder *enc,
+		bool odm_combine);
+#endif
 };
 
 #endif /* STREAM_ENCODER_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/virtual/virtual_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/virtual/virtual_stream_encoder.c
index fdcf9e66d852..16586e434b3d 100644
--- a/drivers/gpu/drm/amd/display/dc/virtual/virtual_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/virtual/virtual_stream_encoder.c
@@ -75,7 +75,12 @@ static void virtual_audio_mute_control(
 	struct stream_encoder *enc,
 	bool mute) {}
 
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+#endif
+
 static const struct stream_encoder_funcs virtual_str_enc_funcs = {
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+#endif
 	.dp_set_stream_attribute =
 		virtual_stream_encoder_dp_set_stream_attribute,
 	.hdmi_set_stream_attribute =
-- 
2.17.1

