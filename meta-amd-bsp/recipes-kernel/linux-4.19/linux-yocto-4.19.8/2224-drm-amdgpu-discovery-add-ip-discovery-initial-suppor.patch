From e802443a5a1a872fa5aca25c1d106b9def8c8121 Mon Sep 17 00:00:00 2001
From: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date: Thu, 20 Jun 2019 10:18:50 -0500
Subject: [PATCH 2224/2940] drm/amdgpu/discovery: add ip discovery initial
 support

v2: prefix struct and function names with 'amdgpu'
v3: read table binary from vram using mmMM_INDEX and mmMM_DATA
    update TABLE_BINARY_MAX_SIZE to 64kb (1 TMR)
    add 'instance_number' field per ip info
    consider endianness and replace uint8/16/32_t with u8/16/32
    initialize register base addresses
    initialize adev->gfx.config and adev->gfx.cu_info to replace gpu info fw
    get major and minor version using a single api
    don't expose internal data structures in amdgpu_discovery.h
v4: RCC_CONFIG_MEMSIZE is in MB units
    hold mmio_idx_lock while reading ip discovery binary
v5: pick out discovery.h as a cross-OS header
    do structure pointer cast directly
    consider endianness while using the member of structure
    convert base addresses to dword

at boot up, PSP BL copies ip discovery binary from VBIOS(SPIROM) image to the
top of the frame buffer (just below the reserved regions for PSP & SMU).

ip discovery data table includes the collection of each ip's identification
number, base addresses, version number, and harvest setting placeholder.

gc data table includes gfx info structure.

Change-Id: Idcc39e9020ea447b1ef777263e7e1d63ed3a4d79
Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/Makefile           |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu.h           |   4 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c | 401 ++++++++++++++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.h |  34 ++
 drivers/gpu/drm/amd/include/discovery.h       | 145 +++++++
 5 files changed, 585 insertions(+), 1 deletion(-)
 create mode 100644 drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
 create mode 100644 drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.h
 create mode 100644 drivers/gpu/drm/amd/include/discovery.h

diff --git a/drivers/gpu/drm/amd/amdgpu/Makefile b/drivers/gpu/drm/amd/amdgpu/Makefile
index d22067d2f038..14a82aa3de8d 100644
--- a/drivers/gpu/drm/amd/amdgpu/Makefile
+++ b/drivers/gpu/drm/amd/amdgpu/Makefile
@@ -53,7 +53,7 @@ amdgpu-y += amdgpu_device.o amdgpu_kms.o \
 	amdgpu_gtt_mgr.o amdgpu_vram_mgr.o amdgpu_virt.o amdgpu_atomfirmware.o \
 	amdgpu_vf_error.o amdgpu_sched.o amdgpu_debugfs.o amdgpu_ids.o \
 	amdgpu_sem.o amdgpu_gmc.o amdgpu_xgmi.o amdgpu_csa.o amdgpu_ras.o \
-	amdgpu_vm_cpu.o amdgpu_vm_sdma.o
+	amdgpu_vm_cpu.o amdgpu_vm_sdma.o amdgpu_discovery.o
 
 # add asic specific block
 amdgpu-$(CONFIG_DRM_AMDGPU_CIK)+= cik.o cik_ih.o kv_smc.o kv_dpm.o \
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 1d562cbb21c0..e6597318cc30 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -84,6 +84,7 @@
 #include "amdgpu_gem.h"
 #include "amdgpu_doorbell.h"
 #include "amdgpu_smu.h"
+#include "amdgpu_discovery.h"
 
 #define MAX_GPU_INSTANCE		16
 
@@ -948,6 +949,9 @@ struct amdgpu_device {
 	/* display related functionality */
 	struct amdgpu_display_manager dm;
 
+	/* discovery */
+	uint8_t				*discovery;
+
 	struct amdgpu_ip_block          ip_blocks[AMDGPU_MAX_IP_NUM];
 	int				num_ip_blocks;
 	struct mutex	mn_lock;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
new file mode 100644
index 000000000000..7b58273e2ed5
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -0,0 +1,401 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "amdgpu.h"
+#include "amdgpu_discovery.h"
+#include "soc15_common.h"
+#include "soc15_hw_ip.h"
+#include "nbio/nbio_2_3_offset.h"
+#include "discovery.h"
+
+#define mmMM_INDEX	0x0
+#define mmMM_INDEX_HI	0x6
+#define mmMM_DATA	0x1
+#define HW_ID_MAX	300
+
+const char *hw_id_names[HW_ID_MAX] = {
+	[MP1_HWID]		= "MP1",
+	[MP2_HWID]		= "MP2",
+	[THM_HWID]		= "THM",
+	[SMUIO_HWID]		= "SMUIO",
+	[FUSE_HWID]		= "FUSE",
+	[CLKA_HWID]		= "CLKA",
+	[PWR_HWID]		= "PWR",
+	[GC_HWID]		= "GC",
+	[UVD_HWID]		= "UVD",
+	[AUDIO_AZ_HWID]		= "AUDIO_AZ",
+	[ACP_HWID]		= "ACP",
+	[DCI_HWID]		= "DCI",
+	[DMU_HWID]		= "DMU",
+	[DCO_HWID]		= "DCO",
+	[DIO_HWID]		= "DIO",
+	[XDMA_HWID]		= "XDMA",
+	[DCEAZ_HWID]		= "DCEAZ",
+	[DAZ_HWID]		= "DAZ",
+	[SDPMUX_HWID]		= "SDPMUX",
+	[NTB_HWID]		= "NTB",
+	[IOHC_HWID]		= "IOHC",
+	[L2IMU_HWID]		= "L2IMU",
+	[VCE_HWID]		= "VCE",
+	[MMHUB_HWID]		= "MMHUB",
+	[ATHUB_HWID]		= "ATHUB",
+	[DBGU_NBIO_HWID]	= "DBGU_NBIO",
+	[DFX_HWID]		= "DFX",
+	[DBGU0_HWID]		= "DBGU0",
+	[DBGU1_HWID]		= "DBGU1",
+	[OSSSYS_HWID]		= "OSSSYS",
+	[HDP_HWID]		= "HDP",
+	[SDMA0_HWID]		= "SDMA0",
+	[SDMA1_HWID]		= "SDMA1",
+	[ISP_HWID]		= "ISP",
+	[DBGU_IO_HWID]		= "DBGU_IO",
+	[DF_HWID]		= "DF",
+	[CLKB_HWID]		= "CLKB",
+	[FCH_HWID]		= "FCH",
+	[DFX_DAP_HWID]		= "DFX_DAP",
+	[L1IMU_PCIE_HWID]	= "L1IMU_PCIE",
+	[L1IMU_NBIF_HWID]	= "L1IMU_NBIF",
+	[L1IMU_IOAGR_HWID]	= "L1IMU_IOAGR",
+	[L1IMU3_HWID]		= "L1IMU3",
+	[L1IMU4_HWID]		= "L1IMU4",
+	[L1IMU5_HWID]		= "L1IMU5",
+	[L1IMU6_HWID]		= "L1IMU6",
+	[L1IMU7_HWID]		= "L1IMU7",
+	[L1IMU8_HWID]		= "L1IMU8",
+	[L1IMU9_HWID]		= "L1IMU9",
+	[L1IMU10_HWID]		= "L1IMU10",
+	[L1IMU11_HWID]		= "L1IMU11",
+	[L1IMU12_HWID]		= "L1IMU12",
+	[L1IMU13_HWID]		= "L1IMU13",
+	[L1IMU14_HWID]		= "L1IMU14",
+	[L1IMU15_HWID]		= "L1IMU15",
+	[WAFLC_HWID]		= "WAFLC",
+	[FCH_USB_PD_HWID]	= "FCH_USB_PD",
+	[PCIE_HWID]		= "PCIE",
+	[PCS_HWID]		= "PCS",
+	[DDCL_HWID]		= "DDCL",
+	[SST_HWID]		= "SST",
+	[IOAGR_HWID]		= "IOAGR",
+	[NBIF_HWID]		= "NBIF",
+	[IOAPIC_HWID]		= "IOAPIC",
+	[SYSTEMHUB_HWID]	= "SYSTEMHUB",
+	[NTBCCP_HWID]		= "NTBCCP",
+	[UMC_HWID]		= "UMC",
+	[SATA_HWID]		= "SATA",
+	[USB_HWID]		= "USB",
+	[CCXSEC_HWID]		= "CCXSEC",
+	[XGMI_HWID]		= "XGMI",
+	[XGBE_HWID]		= "XGBE",
+	[MP0_HWID]		= "MP0",
+};
+
+static int hw_id_map[MAX_HWIP] = {
+	[GC_HWIP]	= GC_HWID,
+	[HDP_HWIP]	= HDP_HWID,
+	[SDMA0_HWIP]	= SDMA0_HWID,
+	[SDMA1_HWIP]	= SDMA1_HWID,
+	[MMHUB_HWIP]	= MMHUB_HWID,
+	[ATHUB_HWIP]	= ATHUB_HWID,
+	[NBIO_HWIP]	= DBGU_NBIO_HWID,
+	[MP0_HWIP]	= MP0_HWID,
+	[MP1_HWIP]	= MP1_HWID,
+	[UVD_HWIP]	= UVD_HWID,
+	[VCE_HWIP]	= VCE_HWID,
+	[DF_HWIP]	= DF_HWID,
+	[DCE_HWIP]	= DCEAZ_HWID,
+	[OSSSYS_HWIP]	= OSSSYS_HWID,
+	[SMUIO_HWIP]	= SMUIO_HWID,
+	[PWR_HWIP]	= PWR_HWID,
+	[NBIF_HWIP]	= NBIF_HWID,
+	[THM_HWIP]	= THM_HWID,
+	[CLK_HWIP]	= CLKA_HWID,
+};
+
+static int amdgpu_discovery_read_binary(struct amdgpu_device *adev, uint8_t *binary)
+{
+	uint32_t *p = (uint32_t *)binary;
+	uint64_t vram_size = RREG32_SOC15(NBIO, 0,
+			mmRCC_DEV0_EPF0_RCC_CONFIG_MEMSIZE) * 1024 * 1024;
+	uint64_t pos = vram_size - BINARY_MAX_SIZE;
+	unsigned long flags;
+
+	while (pos < vram_size) {
+		spin_lock_irqsave(&adev->mmio_idx_lock, flags);
+		WREG32_NO_KIQ(mmMM_INDEX, ((uint32_t)pos) | 0x80000000);
+		WREG32_NO_KIQ(mmMM_INDEX_HI, pos >> 31);
+		*p++ = RREG32_NO_KIQ(mmMM_DATA);
+		spin_unlock_irqrestore(&adev->mmio_idx_lock, flags);
+		pos += 4;
+	}
+
+	return 0;
+}
+
+static uint16_t amdgpu_discovery_calculate_checksum(uint8_t *data, uint32_t size)
+{
+	uint16_t checksum = 0;
+	int i;
+
+	for (i = 0; i < size; i++)
+		checksum += data[i];
+
+	return checksum;
+}
+
+static inline bool amdgpu_discovery_verify_checksum(uint8_t *data, uint32_t size,
+						    uint16_t expected)
+{
+	return !!(amdgpu_discovery_calculate_checksum(data, size) == expected);
+}
+
+int amdgpu_discovery_init(struct amdgpu_device *adev)
+{
+	struct table_info *info;
+	struct binary_header *bhdr;
+	struct ip_discovery_header *ihdr;
+	struct gpu_info_header *ghdr;
+	uint16_t offset;
+	uint16_t size;
+	uint16_t checksum;
+	int r;
+
+	adev->discovery = kzalloc(BINARY_MAX_SIZE, GFP_KERNEL);
+	if (!adev->discovery)
+		return -ENOMEM;
+
+	r = amdgpu_discovery_read_binary(adev, adev->discovery);
+	if (r) {
+		DRM_ERROR("failed to read ip discovery binary\n");
+		goto out;
+	}
+
+	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+
+	if (le32_to_cpu(bhdr->binary_signature) != BINARY_SIGNATURE) {
+		DRM_ERROR("invalid ip discovery binary signature\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	offset = PSP_HEADER_SIZE +
+		offsetof(struct binary_header, binary_checksum) +
+		sizeof(bhdr->binary_checksum);
+	size = bhdr->binary_size - offset;
+	checksum = bhdr->binary_checksum;
+
+	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+					      size, checksum)) {
+		DRM_ERROR("invalid ip discovery binary checksum\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	info = &bhdr->table_list[IP_DISCOVERY];
+	offset = le16_to_cpu(info->offset);
+	checksum = le16_to_cpu(info->checksum);
+	ihdr = (struct ip_discovery_header *)(adev->discovery + offset);
+
+	if (le32_to_cpu(ihdr->signature) != DISCOVERY_TABLE_SIGNATURE) {
+		DRM_ERROR("invalid ip discovery data table signature\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+					      ihdr->size, checksum)) {
+		DRM_ERROR("invalid ip discovery data table checksum\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	info = &bhdr->table_list[GC];
+	offset = le16_to_cpu(info->offset);
+	checksum = le16_to_cpu(info->checksum);
+	ghdr = (struct gpu_info_header *)(adev->discovery + offset);
+
+	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+				              ghdr->size, checksum)) {
+		DRM_ERROR("invalid gc data table checksum\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	return 0;
+
+out:
+	kfree(adev->discovery);
+	adev->discovery = NULL;
+
+	return r;
+}
+
+void amdgpu_discovery_fini(struct amdgpu_device *adev)
+{
+	kfree(adev->discovery);
+	adev->discovery = NULL;
+}
+
+int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
+{
+	struct binary_header *bhdr;
+	struct ip_discovery_header *ihdr;
+	struct die_header *dhdr;
+	struct ip *ip;
+	uint16_t die_offset;
+	uint16_t ip_offset;
+	uint16_t num_dies;
+	uint16_t num_ips;
+	uint8_t num_base_address;
+	int hw_ip;
+	int hw_id;
+	int i, j, k;
+
+	if (!adev->discovery) {
+		DRM_ERROR("ip discovery uninitialized\n");
+		return -EINVAL;
+	}
+
+	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	ihdr = (struct ip_discovery_header *)(adev->discovery +
+			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
+	num_dies = le16_to_cpu(ihdr->num_dies);
+
+	for (hw_ip = 0; hw_ip < MAX_HWIP; hw_ip++) {
+		hw_id = hw_id_map[hw_ip];
+
+		for (i = 0; i < num_dies; i++) {
+			die_offset = le16_to_cpu(ihdr->die_info[i].die_offset);
+			dhdr = (struct die_header *)(adev->discovery + die_offset);
+			num_ips = le16_to_cpu(dhdr->num_ips);
+			ip_offset = die_offset + sizeof(*dhdr);
+
+			for (j = 0; j < num_ips; j++) {
+				ip = (struct ip *)(adev->discovery + ip_offset);
+				num_base_address = ip->num_base_address;
+
+				if (le16_to_cpu(ip->hw_id) == hw_id) {
+					DRM_DEBUG("%s(%d) v%d.%d.%d:\n",
+						  hw_id_names[hw_id], hw_id,
+						  ip->major, ip->minor,
+						  ip->revision);
+
+					for (k = 0; k < num_base_address; k++) {
+						/*
+						 * convert the endianness and unit (in dword) of base addresses in place,
+						 * so that we don't need to convert them when accessing adev->reg_offset.
+						 */
+						ip->base_address[k] = le32_to_cpu(ip->base_address[k]) >> 2;
+						DRM_DEBUG("\t0x%08x\n", ip->base_address[k] << 2);
+					}
+
+					adev->reg_offset[hw_ip][ip->number_instance] =
+						ip->base_address;
+				}
+
+				ip_offset += sizeof(*ip) + 4 * (ip->num_base_address - 1);
+			}
+		}
+	}
+
+	return 0;
+}
+
+int amdgpu_discovery_get_ip_version(struct amdgpu_device *adev, int hw_id,
+				    int *major, int *minor)
+{
+	struct binary_header *bhdr;
+	struct ip_discovery_header *ihdr;
+	struct die_header *dhdr;
+	struct ip *ip;
+	uint16_t die_offset;
+	uint16_t ip_offset;
+	uint16_t num_dies;
+	uint16_t num_ips;
+	int i, j;
+
+	if (!adev->discovery) {
+		DRM_ERROR("ip discovery uninitialized\n");
+		return -EINVAL;
+	}
+
+	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	ihdr = (struct ip_discovery_header *)(adev->discovery +
+			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
+	num_dies = le16_to_cpu(ihdr->num_dies);
+
+	for (i = 0; i < num_dies; i++) {
+		die_offset = le16_to_cpu(ihdr->die_info[i].die_offset);
+		dhdr = (struct die_header *)(adev->discovery + die_offset);
+		num_ips = le16_to_cpu(dhdr->num_ips);
+		ip_offset = die_offset + sizeof(*dhdr);
+
+		for (j = 0; j < num_ips; j++) {
+			ip = (struct ip *)(adev->discovery + ip_offset);
+
+			if (le16_to_cpu(ip->hw_id) == hw_id) {
+				if (major)
+					*major = ip->major;
+				if (minor)
+					*minor = ip->minor;
+				return 0;
+			}
+			ip_offset += sizeof(*ip) + 4 * (ip->num_base_address - 1);
+		}
+	}
+
+	return -EINVAL;
+}
+
+int amdgpu_discovery_get_gfx_info(struct amdgpu_device *adev)
+{
+	struct binary_header *bhdr;
+	struct gc_info_v1_0 *gc_info;
+
+	if (!adev->discovery) {
+		DRM_ERROR("ip discovery uninitialized\n");
+		return -EINVAL;
+	}
+
+	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	gc_info = (struct gc_info_v1_0 *)(adev->discovery +
+			le16_to_cpu(bhdr->table_list[GC].offset));
+
+	adev->gfx.config.max_shader_engines = le32_to_cpu(gc_info->gc_num_se);
+	adev->gfx.config.max_cu_per_sh = le32_to_cpu(gc_info->gc_num_wgp0_per_sa);
+	adev->gfx.config.max_sh_per_se = le32_to_cpu(gc_info->gc_num_wgp1_per_sa);
+	adev->gfx.config.max_backends_per_se = le32_to_cpu(gc_info->gc_num_rb_per_se);
+	adev->gfx.config.max_texture_channel_caches = le32_to_cpu(gc_info->gc_num_gl2c);
+	adev->gfx.config.max_gprs = le32_to_cpu(gc_info->gc_num_gprs);
+	adev->gfx.config.max_gs_threads = le32_to_cpu(gc_info->gc_num_max_gs_thds);
+	adev->gfx.config.gs_vgt_table_depth = le32_to_cpu(gc_info->gc_gs_table_depth);
+	adev->gfx.config.gs_prim_buffer_depth = le32_to_cpu(gc_info->gc_gsprim_buff_depth);
+	adev->gfx.config.double_offchip_lds_buf = le32_to_cpu(gc_info->gc_double_offchip_lds_buffer);
+	adev->gfx.cu_info.wave_front_size = le32_to_cpu(gc_info->gc_wave_size);
+	adev->gfx.cu_info.max_waves_per_simd = le32_to_cpu(gc_info->gc_max_waves_per_simd);
+	adev->gfx.cu_info.max_scratch_slots_per_cu = le32_to_cpu(gc_info->gc_max_scratch_slots_per_cu);
+	adev->gfx.cu_info.lds_size = le32_to_cpu(gc_info->gc_lds_size);
+	adev->gfx.config.num_sc_per_sh = le32_to_cpu(gc_info->gc_num_sc_per_se);
+	adev->gfx.config.num_packer_per_sc = le32_to_cpu(gc_info->gc_num_sa_per_se);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.h
new file mode 100644
index 000000000000..85b8c4d4d576
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __AMDGPU_DISCOVERY__
+#define __AMDGPU_DISCOVERY__
+
+int amdgpu_discovery_init(struct amdgpu_device *adev);
+void amdgpu_discovery_fini(struct amdgpu_device *adev);
+int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev);
+int amdgpu_discovery_get_ip_version(struct amdgpu_device *adev, int hw_id,
+                                    int *major, int *minor);
+int amdgpu_discovery_get_gfx_info(struct amdgpu_device *adev);
+
+#endif /* __AMDGPU_DISCOVERY__ */
diff --git a/drivers/gpu/drm/amd/include/discovery.h b/drivers/gpu/drm/amd/include/discovery.h
new file mode 100644
index 000000000000..7cc921a28f51
--- /dev/null
+++ b/drivers/gpu/drm/amd/include/discovery.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _DISCOVERY_H_
+#define _DISCOVERY_H_
+
+#define PSP_HEADER_SIZE                 256
+#define BINARY_MAX_SIZE                 (64 << 10)
+#define BINARY_SIGNATURE                0x28211407
+#define DISCOVERY_TABLE_SIGNATURE       0x53445049
+
+typedef enum
+{
+	IP_DISCOVERY = 0,
+	GC,
+	TABLE_3,
+	TABLE_4,
+	RESERVED_1,
+	RESERVED_2,
+	TOTAL_TABLES = 6
+} table;
+
+#pragma pack(1)
+
+typedef struct table_info
+{
+	uint16_t offset;   /* Byte offset */
+	uint16_t checksum; /* Byte sum of the table */
+} table_info;
+
+typedef struct binary_header
+{
+	/* psp structure should go at the top of this structure */
+	uint32_t binary_signature; /* 0x7, 0x14, 0x21, 0x28 */
+	uint16_t binary_checksum;  /* Byte sum of the binary after this field */
+	uint16_t binary_size;      /* Binary Size*/
+	table_info table_list[TOTAL_TABLES];
+} binary_header;
+
+typedef struct die_info
+{
+	uint16_t die_id;
+	uint16_t die_offset; /* Points to the corresponding die_header structure */
+} die_info;
+
+
+typedef struct ip_discovery_header
+{
+	uint32_t signature;    /* Table Signature */
+	uint16_t version;      /* Table Version */
+	uint16_t size;         /* Table Size */
+	uint32_t id;           /* Table ID */
+	uint16_t num_dies;     /* Number of Dies */
+	die_info die_info[16]; /* list die information for up to 16 dies */
+	uint16_t padding[1];   /* padding */
+} ip_discovery_header;
+
+typedef struct ip
+{
+	uint16_t hw_id;           /* Hardware ID */
+	uint8_t number_instance;  /* instance of the IP */
+	uint8_t num_base_address; /* Number of Base Addresses */
+	uint8_t major;            /* HCID Major */
+	uint8_t minor;            /* HCID Minor */
+	uint8_t revision;         /* HCID Revision */
+#if defined(__BIG_ENDIAN)
+	uint8_t reserved : 4;     /* Placeholder field */
+	uint8_t harvest : 4;      /* Harvest */
+#else
+	uint8_t harvest : 4;      /* Harvest */
+	uint8_t reserved : 4;     /* Placeholder field */
+#endif
+	uint32_t base_address[1]; /* variable number of Addresses */
+} ip;
+
+typedef struct die_header
+{
+	uint32_t die_id;
+	uint32_t num_ips;
+} die_header;
+
+typedef struct ip_structure
+{
+	ip_discovery_header* header;
+	struct die
+	{
+		die_header *die_header;
+		ip *ip_list;
+	} die;
+} ip_structure;
+
+struct gpu_info_header {
+	uint32_t table_id;      /* table ID */
+	uint16_t version_major; /* table version */
+	uint16_t version_minor; /* table version */
+	uint32_t size;          /* size of the entire header+data in bytes */
+};
+
+struct gc_info_v1_0 {
+	struct gpu_info_header header;
+
+	uint32_t gc_num_se;
+	uint32_t gc_num_wgp0_per_sa;
+	uint32_t gc_num_wgp1_per_sa;
+	uint32_t gc_num_rb_per_se;
+	uint32_t gc_num_gl2c;
+	uint32_t gc_num_gprs;
+	uint32_t gc_num_max_gs_thds;
+	uint32_t gc_gs_table_depth;
+	uint32_t gc_gsprim_buff_depth;
+	uint32_t gc_parameter_cache_depth;
+	uint32_t gc_double_offchip_lds_buffer;
+	uint32_t gc_wave_size;
+	uint32_t gc_max_waves_per_simd;
+	uint32_t gc_max_scratch_slots_per_cu;
+	uint32_t gc_lds_size;
+	uint32_t gc_num_sc_per_se;
+	uint32_t gc_num_sa_per_se;
+	uint32_t gc_num_packer_per_sc;
+	uint32_t gc_num_gl2a;
+};
+
+#pragma pack()
+
+#endif
-- 
2.17.1

