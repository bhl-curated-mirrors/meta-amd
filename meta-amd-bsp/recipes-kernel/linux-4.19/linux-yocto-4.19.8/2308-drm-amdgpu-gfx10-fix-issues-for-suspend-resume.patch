From e390ced66dfaf46b1b23047de4fc7cb080a0521a Mon Sep 17 00:00:00 2001
From: Jack Xiao <Jack.Xiao@amd.com>
Date: Tue, 16 Apr 2019 17:27:41 +0800
Subject: [PATCH 2308/2940] drm/amdgpu/gfx10: fix issues for suspend/resume

1). use PREEMPT_QUEUE instead of RESET_QUEUE for gfx ring disablement.
2). Need wait for unmapping queue done before continue execution.

Signed-off-by: Jack Xiao <Jack.Xiao@amd.com>
Reviewed-by: Tianci Yin <tianci.yin@amd.com>
Reviewed-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c | 35 ++++++++++++++++++++++----
 1 file changed, 30 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c
index 9d162d269aca..fae07603e121 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c
@@ -3567,8 +3567,9 @@ static int gfx_v10_0_hw_init(void *handle)
 static int gfx10_0_disable_kgq(struct amdgpu_device *adev)
 {
 	struct amdgpu_kiq *kiq = &adev->gfx.kiq;
-	struct amdgpu_ring *kiq_ring = &kiq->ring;
-	int i;
+	struct amdgpu_ring *ring, *kiq_ring = &kiq->ring;
+	struct v10_gfx_mqd *mqd;
+	int r, i, j;
 
 	if (!kiq->pmf || !kiq->pmf->kiq_unmap_queues)
 		return -EINVAL;
@@ -3577,9 +3578,33 @@ static int gfx10_0_disable_kgq(struct amdgpu_device *adev)
 					adev->gfx.num_gfx_rings))
 		return -ENOMEM;
 
-	for (i = 0; i < adev->gfx.num_gfx_rings; i++)
-		kiq->pmf->kiq_unmap_queues(kiq_ring, &adev->gfx.gfx_ring[i],
-					   RESET_QUEUES, 0, 0);
+	for (i = 0; i < adev->gfx.num_gfx_rings; i++) {
+		ring = &adev->gfx.gfx_ring[i];
+
+		r = amdgpu_bo_reserve(ring->mqd_obj, false);
+		if (unlikely(r != 0))
+			return r;
+
+		r = amdgpu_bo_kmap(ring->mqd_obj, (void **)&ring->mqd_ptr);
+		if (!r) {
+			kiq->pmf->kiq_unmap_queues(kiq_ring, ring,
+						   PREEMPT_QUEUES, 0, 0);
+			mqd = ring->mqd_ptr;
+
+			for (j = 0; j < adev->usec_timeout; j++) {
+				if (!mqd->cp_gfx_hqd_active)
+					break;
+				udelay(1);
+			}
+
+			if (j == adev->usec_timeout)
+				DRM_ERROR("failed to wait for gfx inactive\n");
+
+			amdgpu_bo_kunmap(ring->mqd_obj);
+			ring->mqd_ptr = NULL;
+		}
+		amdgpu_bo_unreserve(ring->mqd_obj);
+	}
 
 	return amdgpu_ring_test_ring(kiq_ring);
 }
-- 
2.17.1

