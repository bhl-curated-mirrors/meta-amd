From 84db4314e3aba86765ed76dabb86df9bcf399573 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Fri, 22 Feb 2019 15:45:23 -0500
Subject: [PATCH 2438/2940] drm/amd/display: Add DCN2 OPP

Add support to program the DCN2 OPP (Output Plane Processing)

HW Blocks:

    +-------+
    |  OPP  |
    +-------+
        |
        v
    +--------+
    |  OPTC  |
    +--------+
        |
        v
    +--------+       +--------+
    |  DIO   |       |  DCCG  |
    +--------+       +--------+

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../gpu/drm/amd/display/dc/dcn10/dcn10_opp.c  |   8 +
 .../gpu/drm/amd/display/dc/dcn20/dcn20_opp.c  | 355 ++++++++++++++++++
 .../gpu/drm/amd/display/dc/dcn20/dcn20_opp.h  | 158 ++++++++
 drivers/gpu/drm/amd/display/dc/inc/hw/opp.h   |  29 ++
 4 files changed, 550 insertions(+)
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_opp.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn20/dcn20_opp.h

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index ab958cff3b76..1168342c7190 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -365,6 +365,11 @@ void opp1_program_oppbuf(
 	 */
 	REG_UPDATE(OPPBUF_CONTROL, OPPBUF_PIXEL_REPETITION, oppbuf->pixel_repetition);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	/* Controls the number of padded pixels at the end of a segment */
+	if (REG(OPPBUF_CONTROL1))
+		REG_UPDATE(OPPBUF_CONTROL1, OPPBUF_NUM_SEGMENT_PADDED_PIXELS, oppbuf->num_segment_padded_pixels);
+#endif
 }
 
 void opp1_pipe_clock_control(struct output_pixel_processor *opp, bool enable)
@@ -391,6 +396,9 @@ static const struct opp_funcs dcn10_opp_funcs = {
 		.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,
 		.opp_program_stereo = opp1_program_stereo,
 		.opp_pipe_clock_control = opp1_pipe_clock_control,
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+		.opp_set_disp_pattern_generator = NULL,
+#endif
 		.opp_destroy = opp1_destroy
 };
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_opp.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_opp.c
new file mode 100644
index 000000000000..d9e7c711a71c
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_opp.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dcn20_opp.h"
+#include "reg_helper.h"
+
+#define REG(reg) \
+	(oppn20->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	oppn20->opp_shift->field_name, oppn20->opp_mask->field_name
+
+#define CTX \
+	oppn20->base.ctx
+
+
+void opp2_set_disp_pattern_generator(
+		struct output_pixel_processor *opp,
+		enum controller_dp_test_pattern test_pattern,
+		enum dc_color_depth color_depth,
+		const struct tg_color *solid_color,
+		int width,
+		int height)
+{
+	struct dcn20_opp *oppn20 = TO_DCN20_OPP(opp);
+	enum test_pattern_color_format bit_depth;
+	enum test_pattern_dyn_range dyn_range;
+	enum test_pattern_mode mode;
+
+	/* color ramp generator mixes 16-bits color */
+	uint32_t src_bpc = 16;
+	/* requested bpc */
+	uint32_t dst_bpc;
+	uint32_t index;
+	/* RGB values of the color bars.
+	 * Produce two RGB colors: RGB0 - white (all Fs)
+	 * and RGB1 - black (all 0s)
+	 * (three RGB components for two colors)
+	 */
+	uint16_t src_color[6] = {0xFFFF, 0xFFFF, 0xFFFF, 0x0000,
+						0x0000, 0x0000};
+	/* dest color (converted to the specified color format) */
+	uint16_t dst_color[6];
+	uint32_t inc_base;
+
+	/* translate to bit depth */
+	switch (color_depth) {
+	case COLOR_DEPTH_666:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_6;
+	break;
+	case COLOR_DEPTH_888:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;
+	break;
+	case COLOR_DEPTH_101010:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_10;
+	break;
+	case COLOR_DEPTH_121212:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_12;
+	break;
+	default:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;
+	break;
+	}
+
+	/* set DPG dimentions */
+	REG_SET_2(DPG_DIMENSIONS, 0,
+		DPG_ACTIVE_WIDTH, width,
+		DPG_ACTIVE_HEIGHT, height);
+
+	switch (test_pattern) {
+	case CONTROLLER_DP_TEST_PATTERN_COLORSQUARES:
+	case CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA:
+	{
+		dyn_range = (test_pattern ==
+				CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA ?
+				TEST_PATTERN_DYN_RANGE_CEA :
+				TEST_PATTERN_DYN_RANGE_VESA);
+
+		REG_UPDATE_6(DPG_CONTROL,
+			DPG_EN, 1,
+			DPG_MODE, TEST_PATTERN_MODE_COLORSQUARES_RGB,
+			DPG_DYNAMIC_RANGE, dyn_range,
+			DPG_BIT_DEPTH, bit_depth,
+			DPG_VRES, 6,
+			DPG_HRES, 6);
+	}
+	break;
+
+	case CONTROLLER_DP_TEST_PATTERN_VERTICALBARS:
+	case CONTROLLER_DP_TEST_PATTERN_HORIZONTALBARS:
+	{
+		mode = (test_pattern ==
+			CONTROLLER_DP_TEST_PATTERN_VERTICALBARS ?
+			TEST_PATTERN_MODE_VERTICALBARS :
+			TEST_PATTERN_MODE_HORIZONTALBARS);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+			dst_bpc = 6;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+			dst_bpc = 8;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+			dst_bpc = 10;
+		break;
+		default:
+			dst_bpc = 8;
+		break;
+		}
+
+		/* adjust color to the required colorFormat */
+		for (index = 0; index < 6; index++) {
+			/* dst = 2^dstBpc * src / 2^srcBpc = src >>
+			 * (srcBpc - dstBpc);
+			 */
+			dst_color[index] =
+				src_color[index] >> (src_bpc - dst_bpc);
+		/* DPG_COLOUR registers are 16-bit MSB aligned value with bits 3:0 hardwired to ZERO.
+		 * XXXXXXXXXX000000 for 10 bit,
+		 * XXXXXXXX00000000 for 8 bit,
+		 * XXXXXX0000000000 for 6 bits
+		 */
+			dst_color[index] <<= (16 - dst_bpc);
+		}
+
+		REG_SET_2(DPG_COLOUR_R_CR, 0,
+				DPG_COLOUR1_R_CR, dst_color[0],
+				DPG_COLOUR0_R_CR, dst_color[3]);
+		REG_SET_2(DPG_COLOUR_G_Y, 0,
+				DPG_COLOUR1_G_Y, dst_color[1],
+				DPG_COLOUR0_G_Y, dst_color[4]);
+		REG_SET_2(DPG_COLOUR_B_CB, 0,
+				DPG_COLOUR1_B_CB, dst_color[2],
+				DPG_COLOUR0_B_CB, dst_color[5]);
+
+		/* enable test pattern */
+		REG_UPDATE_6(DPG_CONTROL,
+			DPG_EN, 1,
+			DPG_MODE, mode,
+			DPG_DYNAMIC_RANGE, 0,
+			DPG_BIT_DEPTH, bit_depth,
+			DPG_VRES, 0,
+			DPG_HRES, 0);
+	}
+	break;
+
+	case CONTROLLER_DP_TEST_PATTERN_COLORRAMP:
+	{
+		mode = (bit_depth ==
+			TEST_PATTERN_COLOR_FORMAT_BPC_10 ?
+			TEST_PATTERN_MODE_DUALRAMP_RGB :
+			TEST_PATTERN_MODE_SINGLERAMP_RGB);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+			dst_bpc = 6;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+			dst_bpc = 8;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+			dst_bpc = 10;
+		break;
+		default:
+			dst_bpc = 8;
+		break;
+		}
+
+		/* increment for the first ramp for one color gradation
+		 * 1 gradation for 6-bit color is 2^10
+		 * gradations in 16-bit color
+		 */
+		inc_base = (src_bpc - dst_bpc);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+		{
+			REG_SET_3(DPG_RAMP_CONTROL, 0,
+				DPG_RAMP0_OFFSET, 0,
+				DPG_INC0, inc_base,
+				DPG_INC1, 0);
+			REG_UPDATE_2(DPG_CONTROL,
+				DPG_VRES, 6,
+				DPG_HRES, 6);
+		}
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+		{
+			REG_SET_3(DPG_RAMP_CONTROL, 0,
+				DPG_RAMP0_OFFSET, 0,
+				DPG_INC0, inc_base,
+				DPG_INC1, 0);
+			REG_UPDATE_2(DPG_CONTROL,
+				DPG_VRES, 6,
+				DPG_HRES, 8);
+		}
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+		{
+			REG_SET_3(DPG_RAMP_CONTROL, 0,
+				DPG_RAMP0_OFFSET, 384 << 6,
+				DPG_INC0, inc_base,
+				DPG_INC1, inc_base + 2);
+			REG_UPDATE_2(DPG_CONTROL,
+				DPG_VRES, 5,
+				DPG_HRES, 8);
+		}
+		break;
+		default:
+		break;
+		}
+
+		/* enable test pattern */
+		REG_UPDATE_4(DPG_CONTROL,
+			DPG_EN, 1,
+			DPG_MODE, mode,
+			DPG_DYNAMIC_RANGE, 0,
+			DPG_BIT_DEPTH, bit_depth);
+	}
+	break;
+	case CONTROLLER_DP_TEST_PATTERN_VIDEOMODE:
+	{
+		REG_WRITE(DPG_CONTROL, 0);
+		REG_WRITE(DPG_COLOUR_R_CR, 0);
+		REG_WRITE(DPG_COLOUR_G_Y, 0);
+		REG_WRITE(DPG_COLOUR_B_CB, 0);
+		REG_WRITE(DPG_RAMP_CONTROL, 0);
+	}
+	break;
+	case CONTROLLER_DP_TEST_PATTERN_SOLID_COLOR:
+	{
+		opp2_dpg_set_blank_color(opp, solid_color);
+		REG_UPDATE_2(DPG_CONTROL,
+				DPG_EN, 1,
+				DPG_MODE, TEST_PATTERN_MODE_HORIZONTALBARS);
+
+		REG_SET_2(DPG_DIMENSIONS, 0,
+				DPG_ACTIVE_WIDTH, width,
+				DPG_ACTIVE_HEIGHT, height);
+	}
+	break;
+	default:
+		break;
+
+	}
+}
+
+void opp2_dpg_set_blank_color(
+		struct output_pixel_processor *opp,
+		const struct tg_color *color)
+{
+	struct dcn20_opp *oppn20 = TO_DCN20_OPP(opp);
+
+	/* 16-bit MSB aligned value. Bits 3:0 of this field are hardwired to ZERO */
+	ASSERT(color);
+	REG_SET_2(DPG_COLOUR_B_CB, 0,
+			DPG_COLOUR1_B_CB, color->color_b_cb << 6,
+			DPG_COLOUR0_B_CB, color->color_b_cb << 6);
+	REG_SET_2(DPG_COLOUR_G_Y, 0,
+			DPG_COLOUR1_G_Y, color->color_g_y << 6,
+			DPG_COLOUR0_G_Y, color->color_g_y << 6);
+	REG_SET_2(DPG_COLOUR_R_CR, 0,
+			DPG_COLOUR1_R_CR, color->color_r_cr << 6,
+			DPG_COLOUR0_R_CR, color->color_r_cr << 6);
+}
+
+bool opp2_dpg_is_blanked(struct output_pixel_processor *opp)
+{
+	struct dcn20_opp *oppn20 = TO_DCN20_OPP(opp);
+	uint32_t dpg_en, dpg_mode;
+	uint32_t double_buffer_pending;
+
+	REG_GET_2(DPG_CONTROL,
+			DPG_EN, &dpg_en,
+			DPG_MODE, &dpg_mode);
+
+	REG_GET(DPG_STATUS,
+			DPG_DOUBLE_BUFFER_PENDING, &double_buffer_pending);
+
+	return (dpg_en == 1) &&
+		(double_buffer_pending == 0);
+}
+
+void opp2_program_left_edge_extra_pixel (
+		struct output_pixel_processor *opp,
+		bool count)
+{
+	struct dcn20_opp *oppn20 = TO_DCN20_OPP(opp);
+
+	/* Specifies the number of extra left edge pixels that are supplied to
+	 * the 422 horizontal chroma sub-sample filter.
+	 * Note that when left edge pixel is not "0", fmt pixel encoding can be in either 420 or 422 mode
+	 * */
+	REG_UPDATE(FMT_422_CONTROL, FMT_LEFT_EDGE_EXTRA_PIXEL_COUNT, count);
+}
+
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+static struct opp_funcs dcn20_opp_funcs = {
+		.opp_set_dyn_expansion = opp1_set_dyn_expansion,
+		.opp_program_fmt = opp1_program_fmt,
+		.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,
+		.opp_program_stereo = opp1_program_stereo,
+		.opp_pipe_clock_control = opp1_pipe_clock_control,
+		.opp_set_disp_pattern_generator = opp2_set_disp_pattern_generator,
+		.dpg_is_blanked = opp2_dpg_is_blanked,
+		.opp_dpg_set_blank_color = opp2_dpg_set_blank_color,
+		.opp_convert_pti = NULL,
+		.opp_destroy = opp1_destroy,
+		.opp_program_left_edge_extra_pixel = opp2_program_left_edge_extra_pixel,
+};
+
+void dcn20_opp_construct(struct dcn20_opp *oppn20,
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dcn20_opp_registers *regs,
+	const struct dcn20_opp_shift *opp_shift,
+	const struct dcn20_opp_mask *opp_mask)
+{
+	oppn20->base.ctx = ctx;
+	oppn20->base.inst = inst;
+	oppn20->base.funcs = &dcn20_opp_funcs;
+
+	oppn20->regs = regs;
+	oppn20->opp_shift = opp_shift;
+	oppn20->opp_mask = opp_mask;
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_opp.h b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_opp.h
new file mode 100644
index 000000000000..abd8de9a78f8
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_opp.h
@@ -0,0 +1,158 @@
+/* Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_OPP_DCN20_H__
+#define __DC_OPP_DCN20_H__
+
+#include "dcn10/dcn10_opp.h"
+
+#define TO_DCN20_OPP(opp)\
+	container_of(opp, struct dcn20_opp, base)
+
+#define OPP_SF(reg_name, field_name, post_fix)\
+	.field_name = reg_name ## __ ## field_name ## post_fix
+
+#define OPP_DPG_REG_LIST(id) \
+	SRI(DPG_CONTROL, DPG, id), \
+	SRI(DPG_DIMENSIONS, DPG, id), \
+	SRI(DPG_COLOUR_B_CB, DPG, id), \
+	SRI(DPG_COLOUR_G_Y, DPG, id), \
+	SRI(DPG_COLOUR_R_CR, DPG, id), \
+	SRI(DPG_RAMP_CONTROL, DPG, id), \
+	SRI(DPG_STATUS, DPG, id)
+
+#define OPP_REG_LIST_DCN20(id) \
+	OPP_REG_LIST_DCN10(id), \
+	OPP_DPG_REG_LIST(id), \
+	SRI(FMT_422_CONTROL, FMT, id), \
+	SRI(OPPBUF_CONTROL1, OPPBUF, id)
+
+#define OPP_REG_VARIABLE_LIST_DCN2_0 \
+	OPP_COMMON_REG_VARIABLE_LIST; \
+	uint32_t FMT_422_CONTROL; \
+	uint32_t DPG_CONTROL; \
+	uint32_t DPG_DIMENSIONS; \
+	uint32_t DPG_COLOUR_B_CB; \
+	uint32_t DPG_COLOUR_G_Y; \
+	uint32_t DPG_COLOUR_R_CR; \
+	uint32_t DPG_RAMP_CONTROL; \
+	uint32_t DPG_STATUS
+
+#define OPP_DPG_MASK_SH_LIST(mask_sh) \
+	OPP_SF(DPG0_DPG_CONTROL, DPG_EN, mask_sh), \
+	OPP_SF(DPG0_DPG_CONTROL, DPG_MODE, mask_sh), \
+	OPP_SF(DPG0_DPG_CONTROL, DPG_DYNAMIC_RANGE, mask_sh), \
+	OPP_SF(DPG0_DPG_CONTROL, DPG_BIT_DEPTH, mask_sh), \
+	OPP_SF(DPG0_DPG_CONTROL, DPG_VRES, mask_sh), \
+	OPP_SF(DPG0_DPG_CONTROL, DPG_HRES, mask_sh), \
+	OPP_SF(DPG0_DPG_DIMENSIONS, DPG_ACTIVE_WIDTH, mask_sh), \
+	OPP_SF(DPG0_DPG_DIMENSIONS, DPG_ACTIVE_HEIGHT, mask_sh), \
+	OPP_SF(DPG0_DPG_COLOUR_R_CR, DPG_COLOUR0_R_CR, mask_sh), \
+	OPP_SF(DPG0_DPG_COLOUR_R_CR, DPG_COLOUR1_R_CR, mask_sh), \
+	OPP_SF(DPG0_DPG_COLOUR_B_CB, DPG_COLOUR0_B_CB, mask_sh), \
+	OPP_SF(DPG0_DPG_COLOUR_B_CB, DPG_COLOUR1_B_CB, mask_sh), \
+	OPP_SF(DPG0_DPG_COLOUR_G_Y, DPG_COLOUR0_G_Y, mask_sh), \
+	OPP_SF(DPG0_DPG_COLOUR_G_Y, DPG_COLOUR1_G_Y, mask_sh), \
+	OPP_SF(DPG0_DPG_RAMP_CONTROL, DPG_RAMP0_OFFSET, mask_sh), \
+	OPP_SF(DPG0_DPG_RAMP_CONTROL, DPG_INC0, mask_sh), \
+	OPP_SF(DPG0_DPG_RAMP_CONTROL, DPG_INC1, mask_sh), \
+	OPP_SF(DPG0_DPG_STATUS, DPG_DOUBLE_BUFFER_PENDING, mask_sh)
+
+#define OPP_MASK_SH_LIST_DCN20(mask_sh) \
+	OPP_MASK_SH_LIST_DCN(mask_sh), \
+	OPP_DPG_MASK_SH_LIST(mask_sh), \
+	OPP_SF(OPPBUF0_OPPBUF_CONTROL, OPPBUF_DISPLAY_SEGMENTATION, mask_sh),\
+	OPP_SF(OPPBUF0_OPPBUF_CONTROL, OPPBUF_OVERLAP_PIXEL_NUM, mask_sh), \
+	OPP_SF(FMT0_FMT_422_CONTROL, FMT_LEFT_EDGE_EXTRA_PIXEL_COUNT, mask_sh)
+
+#define OPP_DCN20_REG_FIELD_LIST(type) \
+	OPP_DCN10_REG_FIELD_LIST(type); \
+	type FMT_LEFT_EDGE_EXTRA_PIXEL_COUNT; \
+	type DPG_EN; \
+	type DPG_MODE; \
+	type DPG_DYNAMIC_RANGE; \
+	type DPG_BIT_DEPTH; \
+	type DPG_VRES; \
+	type DPG_HRES; \
+	type DPG_ACTIVE_WIDTH; \
+	type DPG_ACTIVE_HEIGHT; \
+	type DPG_COLOUR0_R_CR; \
+	type DPG_COLOUR1_R_CR; \
+	type DPG_COLOUR0_B_CB; \
+	type DPG_COLOUR1_B_CB; \
+	type DPG_COLOUR0_G_Y; \
+	type DPG_COLOUR1_G_Y; \
+	type DPG_RAMP0_OFFSET; \
+	type DPG_INC0; \
+	type DPG_INC1; \
+	type DPG_DOUBLE_BUFFER_PENDING
+
+struct dcn20_opp_registers {
+	OPP_REG_VARIABLE_LIST_DCN2_0;
+};
+
+struct dcn20_opp_shift {
+	OPP_DCN20_REG_FIELD_LIST(uint8_t);
+};
+
+struct dcn20_opp_mask {
+	OPP_DCN20_REG_FIELD_LIST(uint32_t);
+};
+
+struct dcn20_opp {
+	struct output_pixel_processor base;
+
+	const struct dcn20_opp_registers *regs;
+	const struct dcn20_opp_shift *opp_shift;
+	const struct dcn20_opp_mask *opp_mask;
+
+	bool is_write_to_ram_a_safe;
+};
+
+void dcn20_opp_construct(struct dcn20_opp *oppn20,
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dcn20_opp_registers *regs,
+	const struct dcn20_opp_shift *opp_shift,
+	const struct dcn20_opp_mask *opp_mask);
+
+void opp2_set_disp_pattern_generator(
+	struct output_pixel_processor *opp,
+	enum controller_dp_test_pattern test_pattern,
+	enum dc_color_depth color_depth,
+	const struct tg_color *solid_color,
+	int width,
+	int height);
+
+bool opp2_dpg_is_blanked(struct output_pixel_processor *opp);
+
+void opp2_dpg_set_blank_color(
+		struct output_pixel_processor *opp,
+		const struct tg_color *color);
+
+void opp2_program_left_edge_extra_pixel (
+		struct output_pixel_processor *opp,
+		bool count);
+
+#endif
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/opp.h b/drivers/gpu/drm/amd/display/dc/inc/hw/opp.h
index d974d9e18612..5d8a7bcccc6f 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/opp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/opp.h
@@ -262,6 +262,9 @@ struct oppbuf_params {
 	enum oppbuf_display_segmentation mso_segmentation;
 	uint32_t mso_overlap_pixel_num;
 	uint32_t pixel_repetition;
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	uint32_t num_segment_padded_pixels;
+#endif
 };
 
 struct opp_funcs {
@@ -301,6 +304,32 @@ struct opp_funcs {
 			struct output_pixel_processor *opp,
 			bool enable);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	void (*opp_set_disp_pattern_generator)(
+			struct output_pixel_processor *opp,
+			enum controller_dp_test_pattern test_pattern,
+			enum dc_color_depth color_depth,
+			const struct tg_color *solid_color,
+			int width,
+			int height);
+
+	bool (*dpg_is_blanked)(
+			struct output_pixel_processor *opp);
+
+	void (*opp_convert_pti)(
+		struct output_pixel_processor *opp,
+		bool enable,
+		bool polarity);
+
+	void (*opp_dpg_set_blank_color)(
+			struct output_pixel_processor *opp,
+			const struct tg_color *color);
+
+	void (*opp_program_left_edge_extra_pixel)(
+			struct output_pixel_processor *opp,
+			bool count);
+#endif
+
 };
 
 #endif
-- 
2.17.1

