From 87e43eda8a0e9ddb9909d80523ae201f8a359e6f Mon Sep 17 00:00:00 2001
From: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date: Tue, 9 Oct 2018 12:59:46 -0400
Subject: [PATCH 0721/2940] drm/amd/display: Clip all remaining regamma points
 after first clipped point

[Why]
All values computed in the gamma curve after the first upperbound
clipped point will need to be clipped anyways. We can avoid
unnecessary computations and potential fixed point
overflow by instead clipping these values to 1 automatically.

[How]
Track if upper-bound clipping has been done, and clip all values after
this threshold is reached without computing the output gamma
point.

Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Acked-by: Leo Li <sunpeng.li@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../amd/display/modules/color/color_gamma.c   | 44 +++++++++++--------
 1 file changed, 26 insertions(+), 18 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/modules/color/color_gamma.c b/drivers/gpu/drm/amd/display/modules/color/color_gamma.c
index 81b842270db9..7480f072c375 100644
--- a/drivers/gpu/drm/amd/display/modules/color/color_gamma.c
+++ b/drivers/gpu/drm/amd/display/modules/color/color_gamma.c
@@ -820,6 +820,7 @@ static bool build_freesync_hdr(struct pwl_float_data_ex *rgb_regamma,
 	struct fixed31_32 clip = dc_fixpt_one;
 	struct fixed31_32 output;
 	bool use_eetf = false;
+	bool is_clipped = false;
 	struct fixed31_32 sdr_white_level = dc_fixpt_from_int(fs_params->sdr_white_level);
 
 	if (fs_params == NULL || fs_params->max_content == 0 ||
@@ -844,25 +845,32 @@ static bool build_freesync_hdr(struct pwl_float_data_ex *rgb_regamma,
 	rgb += 32; // first 32 points have problems with fixed point, too small
 	coord_x += 32;
 	for (i = 32; i <= hw_points_num; i++) {
-		if (use_eetf) {
-			/*max content is equal 1 */
-			scaledX1 = dc_fixpt_div(coord_x->x,
-					dc_fixpt_div(max_content, sdr_white_level));
-			hermite_spline_eetf(scaledX1, max_display, min_display,
-					max_content, &scaledX);
-		} else
-			scaledX = dc_fixpt_div(coord_x->x,
-					dc_fixpt_div(max_display, sdr_white_level));
-
-		if (dc_fixpt_lt(scaledX, clip)) {
-			if (dc_fixpt_lt(scaledX, dc_fixpt_zero))
-				output = dc_fixpt_zero;
-			else
-				output = calculate_gamma22(scaledX);
+		if (!is_clipped) {
+			if (use_eetf) {
+				/*max content is equal 1 */
+				scaledX1 = dc_fixpt_div(coord_x->x,
+						dc_fixpt_div(max_content, sdr_white_level));
+				hermite_spline_eetf(scaledX1, max_display, min_display,
+						max_content, &scaledX);
+			} else
+				scaledX = dc_fixpt_div(coord_x->x,
+						dc_fixpt_div(max_display, sdr_white_level));
+
+			if (dc_fixpt_lt(scaledX, clip)) {
+				if (dc_fixpt_lt(scaledX, dc_fixpt_zero))
+					output = dc_fixpt_zero;
+				else
+					output = calculate_gamma22(scaledX);
 
-			rgb->r = output;
-			rgb->g = output;
-			rgb->b = output;
+				rgb->r = output;
+				rgb->g = output;
+				rgb->b = output;
+			} else {
+				is_clipped = true;
+				rgb->r = clip;
+				rgb->g = clip;
+				rgb->b = clip;
+			}
 		} else {
 			rgb->r = clip;
 			rgb->g = clip;
-- 
2.17.1

