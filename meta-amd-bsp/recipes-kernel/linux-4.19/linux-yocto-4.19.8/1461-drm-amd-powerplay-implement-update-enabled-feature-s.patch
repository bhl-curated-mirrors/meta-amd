From ff50e8f417d25cff2287c214d1c88760abd2c941 Mon Sep 17 00:00:00 2001
From: Kevin Wang <kevin1.wang@amd.com>
Date: Thu, 24 Jan 2019 15:27:02 +0800
Subject: [PATCH 1461/2940] drm/amd/powerplay: implement update enabled feature
 state to smc for smu11

change:
1.when enable smu feature, the feature id will store sw-bitmap and smu
controller.
2.add feature mutex lock to protect feature bitmap changed when update
feature enabled state.

Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
Reviewed-by: Huang Rui <ray.huang@amd.com>
Acked-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/powerplay/amdgpu_smu.c    | 45 ++++++++++++++++--
 .../gpu/drm/amd/powerplay/inc/amdgpu_smu.h    |  4 ++
 drivers/gpu/drm/amd/powerplay/smu_v11_0.c     | 47 +++++++++++++++++--
 3 files changed, 89 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 2917411a10eb..f4328cf78d22 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -170,16 +170,20 @@ int smu_feature_init_dpm(struct smu_context *smu)
 	int ret = 0;
 	uint32_t unallowed_feature_mask[SMU_FEATURE_MAX/32];
 
+	mutex_lock(&feature->mutex);
 	bitmap_fill(feature->allowed, SMU_FEATURE_MAX);
+	mutex_unlock(&feature->mutex);
 
 	ret = smu_get_unallowed_feature_mask(smu, unallowed_feature_mask,
 					     SMU_FEATURE_MAX/32);
 	if (ret)
 		return ret;
 
+	mutex_lock(&feature->mutex);
 	bitmap_andnot(feature->allowed, feature->allowed,
 		      (unsigned long *)unallowed_feature_mask,
 		      feature->feature_num);
+	mutex_unlock(&feature->mutex);
 
 	return ret;
 }
@@ -187,38 +191,70 @@ int smu_feature_init_dpm(struct smu_context *smu)
 int smu_feature_is_enabled(struct smu_context *smu, int feature_id)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+
 	WARN_ON(feature_id > feature->feature_num);
-	return test_bit(feature_id, feature->enabled);
+
+	mutex_lock(&feature->mutex);
+	ret = test_bit(feature_id, feature->enabled);
+	mutex_unlock(&feature->mutex);
+
+	return ret;
 }
 
 int smu_feature_set_enabled(struct smu_context *smu, int feature_id, bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+
 	WARN_ON(feature_id > feature->feature_num);
+
+	mutex_lock(&feature->mutex);
+	ret = smu_feature_update_enable_state(smu, feature_id, enable);
+	if (ret)
+		goto failed;
+
 	if (enable)
 		test_and_set_bit(feature_id, feature->enabled);
 	else
 		test_and_clear_bit(feature_id, feature->enabled);
-	return 0;
+
+failed:
+	mutex_unlock(&feature->mutex);
+
+	return ret;
 }
 
 int smu_feature_is_supported(struct smu_context *smu, int feature_id)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+
 	WARN_ON(feature_id > feature->feature_num);
-	return test_bit(feature_id, feature->supported);
+
+	mutex_lock(&feature->mutex);
+	ret = test_bit(feature_id, feature->supported);
+	mutex_unlock(&feature->mutex);
+
+	return ret;
 }
 
 int smu_feature_set_supported(struct smu_context *smu, int feature_id,
 			      bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+
 	WARN_ON(feature_id > feature->feature_num);
+
+	mutex_unlock(&feature->mutex);
 	if (enable)
 		test_and_set_bit(feature_id, feature->supported);
 	else
 		test_and_clear_bit(feature_id, feature->supported);
-	return 0;
+	mutex_unlock(&feature->mutex);
+
+	return ret;
 }
 
 static int smu_set_funcs(struct amdgpu_device *adev)
@@ -326,6 +362,7 @@ static int smu_sw_init(void *handle)
 
 	smu->pool_size = adev->pm.smu_prv_buffer_size;
 	smu->smu_feature.feature_num = SMU_FEATURE_MAX;
+	mutex_init(&smu->smu_feature.mutex);
 	bitmap_zero(smu->smu_feature.supported, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.enabled, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.allowed, SMU_FEATURE_MAX);
diff --git a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
index a0bfc378cdc0..101f04d0770e 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
@@ -340,6 +340,7 @@ struct smu_feature
 	DECLARE_BITMAP(supported, SMU_FEATURE_MAX);
 	DECLARE_BITMAP(allowed, SMU_FEATURE_MAX);
 	DECLARE_BITMAP(enabled, SMU_FEATURE_MAX);
+	struct mutex mutex;
 };
 
 struct smu_clocks {
@@ -469,6 +470,7 @@ struct smu_funcs
 	int (*get_enabled_mask)(struct smu_context *smu, uint32_t *feature_mask, uint32_t num);
 	int (*enable_all_mask)(struct smu_context *smu);
 	int (*disable_all_mask)(struct smu_context *smu);
+	int (*update_feature_enable_state)(struct smu_context *smu, uint32_t feature_id, bool enabled);
 	int (*notify_display_change)(struct smu_context *smu);
 	int (*get_power_limit)(struct smu_context *smu);
 	int (*get_current_clk_freq)(struct smu_context *smu, uint32_t clk_id, uint32_t *value);
@@ -580,6 +582,8 @@ struct smu_funcs
 	((smu)->funcs->enable_all_mask? (smu)->funcs->enable_all_mask((smu)) : 0)
 #define smu_feature_disable_all(smu) \
 	((smu)->funcs->disable_all_mask? (smu)->funcs->disable_all_mask((smu)) : 0)
+#define smu_feature_update_enable_state(smu, feature_id, enabled) \
+	((smu)->funcs->update_feature_enable_state? (smu)->funcs->update_feature_enable_state((smu), (feature_id), (enabled)) : 0)
 #define smu_notify_display_change(smu) \
 	((smu)->funcs->notify_display_change? (smu)->funcs->notify_display_change((smu)) : 0)
 #define smu_store_powerplay_table(smu) \
diff --git a/drivers/gpu/drm/amd/powerplay/smu_v11_0.c b/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
index 0e7f81a50dcf..400d981bda5a 100644
--- a/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
+++ b/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
@@ -615,27 +615,67 @@ static int smu_v11_0_init_display(struct smu_context *smu)
 	return ret;
 }
 
+static int smu_v11_0_update_feature_enable_state(struct smu_context *smu, uint32_t feature_id, bool enabled)
+{
+	uint32_t feature_low = 0, feature_high = 0;
+	int ret = 0;
+
+	if (feature_id >= 0 && feature_id < 31)
+		feature_low = (1 << feature_id);
+	else if (feature_id > 31 && feature_id < 63)
+		feature_high = (1 << feature_id);
+	else
+		return -EINVAL;
+
+	if (enabled) {
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesLow,
+						  feature_low);
+		if (ret)
+			return ret;
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesHigh,
+						  feature_high);
+		if (ret)
+			return ret;
+
+	} else {
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesLow,
+						  feature_low);
+		if (ret)
+			return ret;
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesHigh,
+						  feature_high);
+		if (ret)
+			return ret;
+
+	}
+
+	return ret;
+}
+
 static int smu_v11_0_set_allowed_mask(struct smu_context *smu)
 {
 	struct smu_feature *feature = &smu->smu_feature;
 	int ret = 0;
 	uint32_t feature_mask[2];
 
+	mutex_lock(&feature->mutex);
 	if (bitmap_empty(feature->allowed, SMU_FEATURE_MAX) || feature->feature_num < 64)
-		return -EINVAL;
+		goto failed;
 
 	bitmap_copy((unsigned long *)feature_mask, feature->allowed, 64);
 
 	ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetAllowedFeaturesMaskHigh,
 					  feature_mask[1]);
 	if (ret)
-		return ret;
+		goto failed;
 
 	ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetAllowedFeaturesMaskLow,
 					  feature_mask[0]);
 	if (ret)
-		return ret;
+		goto failed;
 
+failed:
+	mutex_unlock(&feature->mutex);
 	return ret;
 }
 
@@ -1578,6 +1618,7 @@ static const struct smu_funcs smu_v11_0_funcs = {
 	.get_enabled_mask = smu_v11_0_get_enabled_mask,
 	.enable_all_mask = smu_v11_0_enable_all_mask,
 	.disable_all_mask = smu_v11_0_disable_all_mask,
+	.update_feature_enable_state = smu_v11_0_update_feature_enable_state,
 	.notify_display_change = smu_v11_0_notify_display_change,
 	.get_power_limit = smu_v11_0_get_power_limit,
 	.get_current_clk_freq = smu_v11_0_get_current_clk_freq,
-- 
2.17.1

