From 54f2489368a66d7c90de71e4656964bee1275aee Mon Sep 17 00:00:00 2001
From: Jonathan Kim <jonathan.kim@amd.com>
Date: Thu, 28 Nov 2019 01:21:43 -0500
Subject: [PATCH 1154/1453] drm/amdkfd: allow debugger to attach to another
 process

This patch resolves SWDEV-207191 and is targeted for amd-staging-dkms-5.4.
It allows debugger to attach to another process before the target process
has opened the kfd device.

Change-Id: I153d9df1a0cf7be24933476ba192d1d984f2ec4e
Signed-off-by: Jonathan Kim <Jonathan.Kim@amd.com>
Reviewed-by: Felix.Kuehling <Felix.Kuehling@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/amdkfd/kfd_chardev.c |  23 ++++-
 drivers/gpu/drm/amd/amdkfd/kfd_priv.h    |   8 +-
 drivers/gpu/drm/amd/amdkfd/kfd_process.c | 120 ++++++++++++-----------
 include/uapi/linux/kfd_ioctl.h           |  11 ++-
 4 files changed, 103 insertions(+), 59 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
index 9a3bfa3c7caf..ea9497e51ae9 100755
--- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
@@ -140,10 +140,15 @@ static int kfd_open(struct inode *inode, struct file *filep)
 		return -EPERM;
 	}
 
-	process = kfd_create_process(filep);
+	process = kfd_create_process(current);
 	if (IS_ERR(process))
 		return PTR_ERR(process);
 
+	if (kfd_process_init_cwsr_apu(process, filep)) {
+		kfd_unref_process(process);
+		return -EFAULT;
+	}
+
 	if (kfd_is_locked()) {
 		kfd_unref_process(process);
 		return -EAGAIN;
@@ -2610,6 +2615,7 @@ static int kfd_ioctl_dbg_set_debug_trap(struct file *filep,
 {
 	struct kfd_ioctl_dbg_trap_args *args = data;
 	struct kfd_process_device *pdd = NULL;
+	struct task_struct *thread = NULL;
 	int r = 0;
 	struct kfd_dev *dev = NULL;
 	struct kfd_process *target = NULL;
@@ -2622,6 +2628,7 @@ static int kfd_ioctl_dbg_set_debug_trap(struct file *filep,
 	uint32_t data3;
 	bool need_device;
 	bool need_qid_array;
+	bool need_proc_create = false;
 
 	debug_trap_action = args->op;
 	gpu_id = args->gpu_id;
@@ -2653,7 +2660,17 @@ static int kfd_ioctl_dbg_set_debug_trap(struct file *filep,
 		goto out;
 	}
 
-	target = kfd_lookup_process_by_pid(pid);
+	thread = get_pid_task(pid, PIDTYPE_PID);
+
+	rcu_read_lock();
+	need_proc_create =
+		debug_trap_action == KFD_IOC_DBG_TRAP_ENABLE &&
+		data1 == 1 && thread && thread != current &&
+		ptrace_parent(thread) == current;
+	rcu_read_unlock();
+
+	target = need_proc_create ?
+		kfd_create_process(thread) : kfd_lookup_process_by_pid(pid);
 	if (!target) {
 		pr_err("Cannot find process info info for %i\n",
 				args->pid);
@@ -2858,6 +2875,8 @@ static int kfd_ioctl_dbg_set_debug_trap(struct file *filep,
 	mutex_unlock(&target->mutex);
 
 out:
+	if (thread)
+		put_task_struct(thread);
 	if (pid)
 		put_pid(pid);
 	if (target)
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_priv.h b/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
index a92be933bc53..a101c212bb40 100755
--- a/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
@@ -858,6 +858,9 @@ struct kfd_process {
 	/* Kobj for our procfs */
 	struct kobject *kobj;
 	struct attribute attr_pasid;
+
+	/* Keep track cwsr init */
+	bool has_cwsr;
 };
 
 #define KFD_PROCESS_TABLE_SIZE 5 /* bits: 32 entries */
@@ -885,7 +888,7 @@ bool kfd_dev_is_large_bar(struct kfd_dev *dev);
 
 int kfd_process_create_wq(void);
 void kfd_process_destroy_wq(void);
-struct kfd_process *kfd_create_process(struct file *filep);
+struct kfd_process *kfd_create_process(struct task_struct *thread);
 struct kfd_process *kfd_get_process(const struct task_struct *);
 struct kfd_process *kfd_lookup_process_by_pasid(unsigned int pasid);
 struct kfd_process *kfd_lookup_process_by_mm(const struct mm_struct *mm);
@@ -1002,6 +1005,9 @@ bool interrupt_is_wanted(struct kfd_dev *dev,
 /* amdkfd Apertures */
 int kfd_init_apertures(struct kfd_process *process);
 
+/* CWSR initialization */
+int kfd_process_init_cwsr_apu(struct kfd_process *process, struct file *filep);
+
 /* Queue Context Management */
 int init_queue(struct queue **q, const struct queue_properties *properties);
 void uninit_queue(struct queue *q);
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_process.c b/drivers/gpu/drm/amd/amdkfd/kfd_process.c
index 08c354752485..f3513c326281 100755
--- a/drivers/gpu/drm/amd/amdkfd/kfd_process.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_process.c
@@ -50,7 +50,20 @@ struct mm_struct;
 DEFINE_HASHTABLE(kfd_processes_table, KFD_PROCESS_TABLE_SIZE);
 static DEFINE_MUTEX(kfd_processes_mutex);
 
+#ifndef DEFINE_SRCU
+struct srcu_struct kfd_processes_srcu;
+void kfd_init_processes_srcu(void)
+{
+	init_srcu_struct(&kfd_processes_srcu);
+}
+
+void kfd_cleanup_processes_srcu(void)
+{
+	cleanup_srcu_struct(&kfd_processes_srcu);
+}
+#else
 DEFINE_SRCU(kfd_processes_srcu);
+#endif
 
 /* For process termination handling */
 static struct workqueue_struct *kfd_process_wq;
@@ -66,8 +79,7 @@ static struct workqueue_struct *kfd_restore_wq;
 static struct kfd_process *find_process(const struct task_struct *thread,
 		bool ref);
 static void kfd_process_ref_release(struct kref *ref);
-static struct kfd_process *create_process(const struct task_struct *thread,
-					struct file *filep);
+static struct kfd_process *create_process(const struct task_struct *thread);
 
 static void evict_process_worker(struct work_struct *work);
 static void restore_process_worker(struct work_struct *work);
@@ -138,9 +150,14 @@ void kfd_procfs_shutdown(void)
 int kfd_process_create_wq(void)
 {
 	if (!kfd_process_wq)
-		kfd_process_wq = alloc_workqueue("kfd_process_wq", 0, 0);
+		kfd_process_wq = create_workqueue("kfd_process_wq");
+
 	if (!kfd_restore_wq)
+#ifdef HAVE_ALLOC_ORDERED_WORKQUEUE
 		kfd_restore_wq = alloc_ordered_workqueue("kfd_restore_wq", 0);
+#else
+		kfd_restore_wq = alloc_workqueue("kfd_restore_wq", WQ_UNBOUND, 1);
+#endif
 
 	if (!kfd_process_wq || !kfd_restore_wq) {
 		kfd_process_destroy_wq();
@@ -277,18 +294,19 @@ static int kfd_process_device_reserve_ib_mem(struct kfd_process_device *pdd)
 	return 0;
 }
 
-struct kfd_process *kfd_create_process(struct file *filep)
+struct kfd_process *kfd_create_process(struct task_struct *thread)
 {
 	struct kfd_process *process;
-	struct task_struct *thread = current;
 	int ret;
 
-	if (!thread->mm)
+	if (!(thread->mm && mmget_not_zero(thread->mm)))
 		return ERR_PTR(-EINVAL);
 
 	/* Only the pthreads threading model is supported. */
-	if (thread->group_leader->mm != thread->mm)
+	if (thread->group_leader->mm != thread->mm) {
+		mmput(thread->mm);
 		return ERR_PTR(-EINVAL);
+	}
 
 	/*
 	 * take kfd processes mutex before starting of process creation
@@ -302,7 +320,9 @@ struct kfd_process *kfd_create_process(struct file *filep)
 	if (process) {
 		pr_debug("Process already found\n");
 	} else {
-		process = create_process(thread, filep);
+		process = create_process(thread);
+		if (IS_ERR(process))
+			goto out;
 
 		if (!procfs.kobj)
 			goto out;
@@ -332,6 +352,7 @@ struct kfd_process *kfd_create_process(struct file *filep)
 	if (!IS_ERR(process))
 		kref_get(&process->ref);
 	mutex_unlock(&kfd_processes_mutex);
+	mmput(thread->mm);
 
 	return process;
 }
@@ -607,10 +628,13 @@ static const struct mmu_notifier_ops kfd_process_mmu_notifier_ops = {
 	.release = kfd_process_notifier_release,
 };
 
-static int kfd_process_init_cwsr_apu(struct kfd_process *p, struct file *filep)
+int kfd_process_init_cwsr_apu(struct kfd_process *p, struct file *filep)
 {
 	unsigned long  offset;
 	struct kfd_process_device *pdd;
+	
+	if (p->has_cwsr)
+		return 0;
 
 	list_for_each_entry(pdd, &p->per_device_data, per_device_list) {
 		struct kfd_dev *dev = pdd->dev;
@@ -640,6 +664,8 @@ static int kfd_process_init_cwsr_apu(struct kfd_process *p, struct file *filep)
 			qpd->tba_addr, qpd->tma_addr, qpd->cwsr_kaddr);
 	}
 
+	p->has_cwsr = true;
+
 	return 0;
 }
 
@@ -673,18 +699,29 @@ static int kfd_process_device_init_cwsr_dgpu(struct kfd_process_device *pdd)
 	return 0;
 }
 
-static struct kfd_process *create_process(const struct task_struct *thread,
-					struct file *filep)
+/*
+ * On return the kfd_process is fully operational and will be freed when the
+ * mm is released
+ */
+static struct kfd_process *create_process(const struct task_struct *thread)
 {
 	struct kfd_process *process;
 	int err = -ENOMEM;
 
 	process = kzalloc(sizeof(*process), GFP_KERNEL);
-
 	if (!process)
 		goto err_alloc_process;
 
-	process->bo_interval_tree = RB_ROOT_CACHED;
+	kref_init(&process->ref);
+	mutex_init(&process->mutex);
+	process->mm = thread->mm;
+	process->lead_thread = thread->group_leader;
+	INIT_LIST_HEAD(&process->per_device_data);
+	INIT_DELAYED_WORK(&process->eviction_work, evict_process_worker);
+	INIT_DELAYED_WORK(&process->restore_work, restore_process_worker);
+	process->last_restore_timestamp = get_jiffies_64();
+	kfd_event_init_process(process);
+	process->is_32bit_user_mode = in_compat_syscall();
 
 	process->pasid = kfd_pasid_alloc();
 	if (process->pasid == 0)
@@ -693,45 +730,24 @@ static struct kfd_process *create_process(const struct task_struct *thread,
 	if (kfd_alloc_process_doorbells(process) < 0)
 		goto err_alloc_doorbells;
 
-	kref_init(&process->ref);
-
-	mutex_init(&process->mutex);
-
-	process->mm = thread->mm;
-
-	/* register notifier */
-	process->mmu_notifier.ops = &kfd_process_mmu_notifier_ops;
-	err = mmu_notifier_register(&process->mmu_notifier, process->mm);
-	if (err)
-		goto err_mmu_notifier;
-
-	hash_add_rcu(kfd_processes_table, &process->kfd_processes,
-			(uintptr_t)process->mm);
-
-	process->lead_thread = thread->group_leader;
-	get_task_struct(process->lead_thread);
-
-	INIT_LIST_HEAD(&process->per_device_data);
-
-	kfd_event_init_process(process);
-
 	err = pqm_init(&process->pqm, process);
 	if (err != 0)
 		goto err_process_pqm_init;
 
 	/* init process apertures*/
-	process->is_32bit_user_mode = in_compat_syscall();
 	err = kfd_init_apertures(process);
 	if (err != 0)
 		goto err_init_apertures;
 
-	INIT_DELAYED_WORK(&process->eviction_work, evict_process_worker);
-	INIT_DELAYED_WORK(&process->restore_work, restore_process_worker);
-	process->last_restore_timestamp = get_jiffies_64();
-
-	err = kfd_process_init_cwsr_apu(process, filep);
+	/* Must be last, have to use release destruction after this */
+	process->mmu_notifier.ops = &kfd_process_mmu_notifier_ops;
+	err = mmu_notifier_register(&process->mmu_notifier, process->mm);
 	if (err)
-		goto err_init_cwsr;
+		goto err_register_notifier;
+
+	get_task_struct(process->lead_thread);
+	hash_add_rcu(kfd_processes_table, &process->kfd_processes,
+			(uintptr_t)process->mm);
 
 	/* If PeerDirect interface was not detected try to detect it again
 	 * in case if network driver was loaded later.
@@ -740,21 +756,17 @@ static struct kfd_process *create_process(const struct task_struct *thread,
 
 	return process;
 
-err_init_cwsr:
+err_register_notifier:
 	kfd_process_free_outstanding_kfd_bos(process);
 	kfd_process_destroy_pdds(process);
 err_init_apertures:
 	pqm_uninit(&process->pqm);
 err_process_pqm_init:
-	hash_del_rcu(&process->kfd_processes);
-	synchronize_rcu();
-	mmu_notifier_unregister_no_release(&process->mmu_notifier, process->mm);
-err_mmu_notifier:
-	mutex_destroy(&process->mutex);
 	kfd_free_process_doorbells(process);
 err_alloc_doorbells:
 	kfd_pasid_free(process->pasid);
 err_alloc_pasid:
+	mutex_destroy(&process->mutex);
 	kfree(process);
 err_alloc_process:
 	return ERR_PTR(err);
@@ -1281,7 +1293,7 @@ static void evict_process_worker(struct work_struct *work)
 
 	p->last_evict_timestamp = get_jiffies_64();
 
-	pr_debug("Started evicting pasid 0x%x\n", p->pasid);
+	pr_info("Started evicting pasid 0x%x\n", p->pasid);
 	ret = kfd_process_evict_queues(p);
 	if (!ret) {
 		dma_fence_signal(p->ef);
@@ -1294,7 +1306,7 @@ static void evict_process_worker(struct work_struct *work)
 			pr_debug("Process %d queues idle, doorbell unmapped\n",
 				p->pasid);
 
-		pr_debug("Finished evicting pasid 0x%x\n", p->pasid);
+		pr_info("Finished evicting pasid 0x%x\n", p->pasid);
 	} else
 		pr_err("Failed to evict queues of pasid 0x%x\n", p->pasid);
 	trace_kfd_evict_process_worker_end(p, ret ? "Failed" : "Success");
@@ -1312,10 +1324,8 @@ static void restore_process_worker(struct work_struct *work)
 	 * lifetime of this thread, kfd_process p will be valid
 	 */
 	p = container_of(dwork, struct kfd_process, restore_work);
-
 	trace_kfd_restore_process_worker_start(p);
-
-	pr_debug("Started restoring pasid 0x%x\n", p->pasid);
+	pr_info("Started restoring pasid 0x%x\n", p->pasid);
 
 	/* Setting last_restore_timestamp before successful restoration.
 	 * Otherwise this would have to be set by KGD (restore_process_bos)
@@ -1331,7 +1341,7 @@ static void restore_process_worker(struct work_struct *work)
 	ret = amdgpu_amdkfd_gpuvm_restore_process_bos(p->kgd_process_info,
 						     &p->ef);
 	if (ret) {
-		pr_debug("Failed to restore BOs of pasid 0x%x, retry after %d ms\n",
+		pr_info("Failed to restore BOs of pasid 0x%x, retry after %d ms\n",
 			 p->pasid, PROCESS_BACK_OFF_TIME_MS);
 
 		ret = queue_delayed_work(kfd_restore_wq, &p->restore_work,
@@ -1346,7 +1356,7 @@ static void restore_process_worker(struct work_struct *work)
 	ret = kfd_process_restore_queues(p);
 	trace_kfd_restore_process_worker_end(p,	ret ? "Failed" : "Success");
 	if (!ret)
-		pr_debug("Finished restoring pasid 0x%x\n", p->pasid);
+		pr_info("Finished restoring pasid 0x%x\n", p->pasid);
 	else
 		pr_err("Failed to restore queues of pasid 0x%x\n", p->pasid);
 }
diff --git a/include/uapi/linux/kfd_ioctl.h b/include/uapi/linux/kfd_ioctl.h
index e58a6637d61a..8f55918bfc37 100755
--- a/include/uapi/linux/kfd_ioctl.h
+++ b/include/uapi/linux/kfd_ioctl.h
@@ -28,8 +28,17 @@
 
 #define KFD_IOCTL_MAJOR_VERSION 1
 #define KFD_IOCTL_MINOR_VERSION 2
+
+/*
+ * Debug revision change log
+ *
+ * 0.1 - Initial revision
+ * 0.2 - Fix to include querying pending event that is both trap and vmfault
+ * 1.0 - Removed function to set debug data (renumbering functions broke ABI)
+ * 1.1 - Allow attaching to processes that have not opened /dev/kfd yet
+ */
 #define KFD_IOCTL_DBG_MAJOR_VERSION	1
-#define KFD_IOCTL_DBG_MINOR_VERSION	0
+#define KFD_IOCTL_DBG_MINOR_VERSION	1
 
 struct kfd_ioctl_get_version_args {
 	__u32 major_version;	/* from KFD */
-- 
2.17.1

