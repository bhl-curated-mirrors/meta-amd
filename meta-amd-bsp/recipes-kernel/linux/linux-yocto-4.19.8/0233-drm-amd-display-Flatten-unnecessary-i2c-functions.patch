From 97b13ca97b2b9face4e8c203e46846dd4ecbfe69 Mon Sep 17 00:00:00 2001
From: David Francis <David.Francis@amd.com>
Date: Fri, 3 Aug 2018 13:24:28 -0400
Subject: [PATCH 0233/2940] drm/amd/display: Flatten unnecessary i2c functions

[Why]
The dce_i2c_hw code contained four funtcions that were only
called in one place and did not have a clearly delineated
purpose.

[How]
Inline these functions, keeping the same functionality.

This is not a functional change.

The functions disable_i2c_hw_engine and release_engine_dce_hw were
pulled into their respective callers.

The most interesting part of this change is the acquire functions.
dce_i2c_hw_engine_acquire_engine was pulled into
dce_i2c_engine_acquire_hw, and dce_i2c_engine_acquire_hw was pulled
into acquire_i2c_hw_engine.

Some notes to show that this change is not functional:
-Failure conditions in any function resulted in a cascade of calls that
ended in a 'return NULL'.
Those are replaced with a direct 'return NULL'.

-The variable result is the one from dce_i2c_hw_engine_acquire_engine.
The boolean result used as part of return logic was removed.

-As the second half of dce_i2c_hw_engine_acquire_engine is only executed
if that function is returning true and therefore exiting the do-while
loop in dce_i2c_engine_acquire_hw, those lines were moved outside
of the loop.

Signed-off-by: David Francis <David.Francis@amd.com>
Acked-by: Leo Li <sunpeng.li@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../gpu/drm/amd/display/dc/dce/dce_i2c_hw.c   | 111 ++++++------------
 1 file changed, 34 insertions(+), 77 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 2800d3fa49da..40f2d6e0b122 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -36,12 +36,6 @@
 #define FN(reg_name, field_name) \
 	dce_i2c_hw->shifts->field_name, dce_i2c_hw->masks->field_name
 
-static void disable_i2c_hw_engine(
-	struct dce_i2c_hw *dce_i2c_hw)
-{
-	REG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);
-}
-
 static void execute_transaction(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
@@ -348,60 +342,40 @@ static void release_engine(
 		REG_UPDATE(DC_I2C_CONTROL, DC_I2C_SW_STATUS_RESET, 1);
 	/* HW I2c engine - clock gating feature */
 	if (!dce_i2c_hw->engine_keep_power_up_count)
-		disable_i2c_hw_engine(dce_i2c_hw);
+		REG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);
 
 }
 
-static void release_engine_dce_hw(
+struct dce_i2c_hw *acquire_i2c_hw_engine(
 	struct resource_pool *pool,
-	struct dce_i2c_hw *dce_i2c_hw)
-{
-	pool->i2c_hw_buffer_in_use = false;
-
-	release_engine(dce_i2c_hw);
-	dal_ddc_close(dce_i2c_hw->ddc);
-
-	dce_i2c_hw->ddc = NULL;
-}
-
-bool dce_i2c_hw_engine_acquire_engine(
-	struct dce_i2c_hw *dce_i2c_hw,
 	struct ddc *ddc)
 {
-
+	uint32_t counter = 0;
 	enum gpio_result result;
 	uint32_t current_speed;
+	struct dce_i2c_hw *dce_i2c_hw = NULL;
 
-	result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
-		GPIO_DDC_CONFIG_TYPE_MODE_I2C);
-
-	if (result != GPIO_RESULT_OK)
-		return false;
-
-	dce_i2c_hw->ddc = ddc;
-
-
-	current_speed = get_speed(dce_i2c_hw);
+	if (!ddc)
+		return NULL;
 
-	if (current_speed)
-		dce_i2c_hw->original_speed = current_speed;
+	if (ddc->hw_info.hw_supported) {
+		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
 
-	return true;
-}
+		if (line < pool->pipe_count)
+			dce_i2c_hw = pool->hw_i2cs[line];
+	}
 
-bool dce_i2c_engine_acquire_hw(
-	struct dce_i2c_hw *dce_i2c_hw,
-	struct ddc *ddc_handle)
-{
+	if (!dce_i2c_hw)
+		return NULL;
 
-	uint32_t counter = 0;
-	bool result;
+	if (pool->i2c_hw_buffer_in_use)
+		return NULL;
 
 	do {
-		result = dce_i2c_hw_engine_acquire_engine(
-				dce_i2c_hw, ddc_handle);
+		result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
+			GPIO_DDC_CONFIG_TYPE_MODE_I2C);
 
-		if (result)
+		if (result == GPIO_RESULT_OK)
 			break;
 
 		/* i2c_engine is busy by VBios, lets wait and retry */
@@ -411,45 +385,23 @@ bool dce_i2c_engine_acquire_hw(
 		++counter;
 	} while (counter < 2);
 
-	if (result) {
-		if (!setup_engine(dce_i2c_hw)) {
-			release_engine(dce_i2c_hw);
-			result = false;
-		}
-	}
-
-	return result;
-}
-
-struct dce_i2c_hw *acquire_i2c_hw_engine(
-	struct resource_pool *pool,
-	struct ddc *ddc)
-{
-
-	struct dce_i2c_hw *engine = NULL;
-
-	if (!ddc)
+	if (result != GPIO_RESULT_OK)
 		return NULL;
 
-	if (ddc->hw_info.hw_supported) {
-		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
-
-		if (line < pool->pipe_count)
-			engine = pool->hw_i2cs[line];
-	}
+	dce_i2c_hw->ddc = ddc;
 
-	if (!engine)
-		return NULL;
+	current_speed = get_speed(dce_i2c_hw);
 
+	if (current_speed)
+		dce_i2c_hw->original_speed = current_speed;
 
-	if (!pool->i2c_hw_buffer_in_use &&
-			dce_i2c_engine_acquire_hw(engine, ddc)) {
-		pool->i2c_hw_buffer_in_use = true;
-		return engine;
+	if (!setup_engine(dce_i2c_hw)) {
+		release_engine(dce_i2c_hw);
+		return NULL;
 	}
 
-
-	return NULL;
+	pool->i2c_hw_buffer_in_use = true;
+	return dce_i2c_hw;
 }
 
 enum i2c_channel_operation_result dce_i2c_hw_engine_wait_on_operation_result(
@@ -619,7 +571,12 @@ bool dce_i2c_submit_command_hw(
 		++index_of_payload;
 	}
 
-	release_engine_dce_hw(pool, dce_i2c_hw);
+	pool->i2c_hw_buffer_in_use = false;
+
+	release_engine(dce_i2c_hw);
+	dal_ddc_close(dce_i2c_hw->ddc);
+
+	dce_i2c_hw->ddc = NULL;
 
 	return result;
 }
-- 
2.17.1

