From 906fdbfcb98e4608675af33d93b32375a4c50bca Mon Sep 17 00:00:00 2001
From: Wenjing Liu <Wenjing.Liu@amd.com>
Date: Tue, 7 May 2019 15:00:43 -0500
Subject: [PATCH 2508/2940] drm/amd/display: Implement DSC MST fair share
 algorithm

[why]
The current policy will always enable DSC to 12 bpp
regardless of if the current bandwidth is enough for MST displays.
This logic is not optimal because user will get lower quality output
if DSC compression is enabled.
This change to is to implement a DSC MST bandwidth fair share
algorithm so we will dynamically decide if DSC is needed and what
quality (target bpp) is needed to fairly destribute the MST bandwidth
in one MST topology. This will allow user to see the most optimal
image quality with the given bandwidth.

[how]
We will start with lowest bandwidth possible and run a
Max-Min fairness algorithm to fairly distribute the available
bandwidth. If there is still remaining bandwidth, we will try to fit
the timing without DSC compression.

Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
Reviewed-by: Jun Lei <Jun.Lei@amd.com>
Acked-by: Leo Li <sunpeng.li@amd.com>
Acked-by: Hawking Zhang <Hawking.Zhang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/display/dc/core/dc_link.c |  2 +-
 drivers/gpu/drm/amd/display/dc/dc_dsc.h       |  2 ++
 drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c   | 26 +++++++++++++------
 3 files changed, 21 insertions(+), 9 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link.c b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
index 943792729e15..8c7c183d616d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -2817,7 +2817,7 @@ void core_link_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 
 	disable_link(pipe_ctx->stream->link, pipe_ctx->stream->signal);
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
-	if (pipe_ctx->stream->timing.flags.DSC &&
+	if (pipe_ctx->stream->is_dsc_enabled &&
 			dc_is_dp_signal(pipe_ctx->stream->signal)) {
 		dp_set_dsc_enable(pipe_ctx, false);
 	}
diff --git a/drivers/gpu/drm/amd/display/dc/dc_dsc.h b/drivers/gpu/drm/amd/display/dc/dc_dsc.h
index 2cba6bd7937a..ddaf7532bb59 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_dsc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_dsc.h
@@ -38,6 +38,8 @@ bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_data,
 
 bool dc_dsc_compute_bandwidth_range(
 		const struct dc *dc,
+		const uint32_t min_kbps,
+		const uint32_t max_kbps,
 		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
 		const struct dc_crtc_timing *timing,
 		struct dc_dsc_bw_range *range);
diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 6357325d3c90..d15da6f906e8 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -284,7 +284,8 @@ const struct dc_dsc_policy dsc_policy = {
 };
 
 static void get_dsc_bandwidth_range(
-		const struct dc_dsc_policy *policy,
+		const uint32_t min_bpp,
+		const uint32_t max_bpp,
 		const struct dsc_enc_caps *dsc_caps,
 		const struct dc_crtc_timing *timing,
 		struct dc_dsc_bw_range *range)
@@ -293,8 +294,8 @@ static void get_dsc_bandwidth_range(
 	range->stream_kbps = dc_bandwidth_in_kbps_from_timing(timing);
 
 	/* max dsc target bpp */
-	range->max_kbps = dsc_round_up(policy->max_target_bpp * timing->pix_clk_100hz);
-	range->max_target_bpp_x16 = policy->max_target_bpp * 16;
+	range->max_kbps = dsc_round_up(max_bpp * timing->pix_clk_100hz);
+	range->max_target_bpp_x16 = max_bpp * 16;
 	if (range->max_kbps > range->stream_kbps) {
 		/* max dsc target bpp is capped to native bandwidth */
 		range->max_kbps = range->stream_kbps;
@@ -302,8 +303,8 @@ static void get_dsc_bandwidth_range(
 	}
 
 	/* min dsc target bpp */
-	range->min_kbps = dsc_round_up(policy->min_target_bpp * timing->pix_clk_100hz);
-	range->min_target_bpp_x16 = policy->min_target_bpp * 16;
+	range->min_kbps = dsc_round_up(min_bpp * timing->pix_clk_100hz);
+	range->min_target_bpp_x16 = min_bpp * 16;
 	if (range->min_kbps > range->max_kbps) {
 		/* min dsc target bpp is capped to max dsc bandwidth*/
 		range->min_kbps = range->max_kbps;
@@ -330,7 +331,8 @@ static bool decide_dsc_target_bpp_x16(
 
 	memset(&range, 0, sizeof(range));
 
-	get_dsc_bandwidth_range(policy, dsc_common_caps, timing, &range);
+	get_dsc_bandwidth_range(policy->min_target_bpp, policy->max_target_bpp,
+			dsc_common_caps, timing, &range);
 	if (target_bandwidth_kbps >= range.stream_kbps) {
 		/* enough bandwidth without dsc */
 		*target_bpp_x16 = 0;
@@ -753,6 +755,8 @@ bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_data, struct dsc_dec_dpcd_cap
 
 bool dc_dsc_compute_bandwidth_range(
 		const struct dc *dc,
+		const uint32_t min_bpp,
+		const uint32_t max_bpp,
 		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
 		const struct dc_crtc_timing *timing,
 		struct dc_dsc_bw_range *range)
@@ -760,10 +764,16 @@ bool dc_dsc_compute_bandwidth_range(
 	bool is_dsc_possible = false;
 	struct dsc_enc_caps dsc_enc_caps;
 	struct dsc_enc_caps dsc_common_caps;
+	struct dc_dsc_config config;
+
 	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
-	is_dsc_possible = dc_intersect_dsc_caps(dsc_sink_caps, &dsc_enc_caps, timing->pixel_encoding, &dsc_common_caps);
+	is_dsc_possible = setup_dsc_config(dsc_sink_caps,
+			&dsc_enc_caps,
+			0,
+			timing, &config);
 	if (is_dsc_possible)
-		get_dsc_bandwidth_range(&dsc_policy, &dsc_common_caps, timing, range);
+		get_dsc_bandwidth_range(min_bpp, max_bpp, &dsc_common_caps, timing, range);
+
 	return is_dsc_possible;
 }
 
-- 
2.17.1

