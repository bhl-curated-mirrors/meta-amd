From 55727eb53d013e30178fe0d4ce286b881aa4f613 Mon Sep 17 00:00:00 2001
From: Hawking Zhang <Hawking.Zhang@amd.com>
Date: Fri, 12 Apr 2019 14:08:00 -0500
Subject: [PATCH 2140/2940] drm/amdgpu: atomfirmware.h updates for navi10

Updated tables for Navi10.

Signed-off-by: Hawking Zhang <Hawking.Zhang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/include/atomfirmware.h | 188 ++++++++++++++++++++-
 1 file changed, 180 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/amd/include/atomfirmware.h b/drivers/gpu/drm/amd/include/atomfirmware.h
index 97477d7f6c9f..3ec0aadee03f 100644
--- a/drivers/gpu/drm/amd/include/atomfirmware.h
+++ b/drivers/gpu/drm/amd/include/atomfirmware.h
@@ -177,9 +177,10 @@ enum atom_voltage_type
   VOLTAGE_TYPE_GENERIC_I2C_10 = 0x1A,
 };
 
-enum atom_dgpu_vram_type{
+enum atom_dgpu_vram_type {
   ATOM_DGPU_VRAM_TYPE_GDDR5 = 0x50,
   ATOM_DGPU_VRAM_TYPE_HBM2  = 0x60,
+  ATOM_DGPU_VRAM_TYPE_GDDR6 = 0x70,
 };
 
 enum atom_dp_vs_preemph_def{
@@ -1657,6 +1658,137 @@ struct atom_smc_dpm_info_v4_4
   uint32_t boardreserved[10];
 };
 
+enum smudpm_v4_5_i2ccontrollername_e{
+    SMC_V4_5_I2C_CONTROLLER_NAME_VR_GFX = 0,
+    SMC_V4_5_I2C_CONTROLLER_NAME_VR_SOC,
+    SMC_V4_5_I2C_CONTROLLER_NAME_VR_VDDCI,
+    SMC_V4_5_I2C_CONTROLLER_NAME_VR_MVDD,
+    SMC_V4_5_I2C_CONTROLLER_NAME_LIQUID0,
+    SMC_V4_5_I2C_CONTROLLER_NAME_LIQUID1,
+    SMC_V4_5_I2C_CONTROLLER_NAME_PLX,
+    SMC_V4_5_I2C_CONTROLLER_NAME_SPARE,
+    SMC_V4_5_I2C_CONTROLLER_NAME_COUNT,
+};
+
+enum smudpm_v4_5_i2ccontrollerthrottler_e{
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_TYPE_NONE = 0,
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_VR_GFX,
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_VR_SOC,
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_VR_VDDCI,
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_VR_MVDD,
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_LIQUID0,
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_LIQUID1,
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_PLX,
+    SMC_V4_5_I2C_CONTROLLER_THROTTLER_COUNT,
+};
+
+enum smudpm_v4_5_i2ccontrollerprotocol_e{
+    SMC_V4_5_I2C_CONTROLLER_PROTOCOL_VR_0,
+    SMC_V4_5_I2C_CONTROLLER_PROTOCOL_VR_1,
+    SMC_V4_5_I2C_CONTROLLER_PROTOCOL_TMP_0,
+    SMC_V4_5_I2C_CONTROLLER_PROTOCOL_TMP_1,
+    SMC_V4_5_I2C_CONTROLLER_PROTOCOL_SPARE_0,
+    SMC_V4_5_I2C_CONTROLLER_PROTOCOL_SPARE_1,
+    SMC_V4_5_I2C_CONTROLLER_PROTOCOL_COUNT,
+};
+
+struct smudpm_i2c_controller_config_v2
+{
+    uint8_t   Enabled;
+    uint8_t   Speed;
+    uint8_t   Padding[2];
+    uint32_t  SlaveAddress;
+    uint8_t   ControllerPort;
+    uint8_t   ControllerName;
+    uint8_t   ThermalThrotter;
+    uint8_t   I2cProtocol;
+};
+
+struct atom_smc_dpm_info_v4_5
+{
+  struct   atom_common_table_header  table_header;
+    // SECTION: BOARD PARAMETERS
+    // I2C Control
+  struct smudpm_i2c_controller_config_v2  I2cControllers[8];
+
+  // SVI2 Board Parameters
+  uint16_t     MaxVoltageStepGfx; // In mV(Q2) Max voltage step that SMU will request. Multiple steps are taken if voltage change exceeds this value.
+  uint16_t     MaxVoltageStepSoc; // In mV(Q2) Max voltage step that SMU will request. Multiple steps are taken if voltage change exceeds this value.
+
+  uint8_t      VddGfxVrMapping;   // Use VR_MAPPING* bitfields
+  uint8_t      VddSocVrMapping;   // Use VR_MAPPING* bitfields
+  uint8_t      VddMem0VrMapping;  // Use VR_MAPPING* bitfields
+  uint8_t      VddMem1VrMapping;  // Use VR_MAPPING* bitfields
+
+  uint8_t      GfxUlvPhaseSheddingMask; // set this to 1 to set PSI0/1 to 1 in ULV mode
+  uint8_t      SocUlvPhaseSheddingMask; // set this to 1 to set PSI0/1 to 1 in ULV mode
+  uint8_t      ExternalSensorPresent; // External RDI connected to TMON (aka TEMP IN)
+  uint8_t      Padding8_V;
+
+  // Telemetry Settings
+  uint16_t     GfxMaxCurrent;   // in Amps
+  uint8_t      GfxOffset;       // in Amps
+  uint8_t      Padding_TelemetryGfx;
+  uint16_t     SocMaxCurrent;   // in Amps
+  uint8_t      SocOffset;       // in Amps
+  uint8_t      Padding_TelemetrySoc;
+
+  uint16_t     Mem0MaxCurrent;   // in Amps
+  uint8_t      Mem0Offset;       // in Amps
+  uint8_t      Padding_TelemetryMem0;
+
+  uint16_t     Mem1MaxCurrent;   // in Amps
+  uint8_t      Mem1Offset;       // in Amps
+  uint8_t      Padding_TelemetryMem1;
+
+  // GPIO Settings
+  uint8_t      AcDcGpio;        // GPIO pin configured for AC/DC switching
+  uint8_t      AcDcPolarity;    // GPIO polarity for AC/DC switching
+  uint8_t      VR0HotGpio;      // GPIO pin configured for VR0 HOT event
+  uint8_t      VR0HotPolarity;  // GPIO polarity for VR0 HOT event
+
+  uint8_t      VR1HotGpio;      // GPIO pin configured for VR1 HOT event 
+  uint8_t      VR1HotPolarity;  // GPIO polarity for VR1 HOT event 
+  uint8_t      GthrGpio;        // GPIO pin configured for GTHR Event
+  uint8_t      GthrPolarity;    // replace GPIO polarity for GTHR
+
+  // LED Display Settings
+  uint8_t      LedPin0;         // GPIO number for LedPin[0]
+  uint8_t      LedPin1;         // GPIO number for LedPin[1]
+  uint8_t      LedPin2;         // GPIO number for LedPin[2]
+  uint8_t      padding8_4;
+
+  // GFXCLK PLL Spread Spectrum
+  uint8_t      PllGfxclkSpreadEnabled;   // on or off
+  uint8_t      PllGfxclkSpreadPercent;   // Q4.4
+  uint16_t     PllGfxclkSpreadFreq;      // kHz
+
+  // GFXCLK DFLL Spread Spectrum
+  uint8_t      DfllGfxclkSpreadEnabled;   // on or off
+  uint8_t      DfllGfxclkSpreadPercent;   // Q4.4
+  uint16_t     DfllGfxclkSpreadFreq;      // kHz
+
+  // UCLK Spread Spectrum
+  uint8_t      UclkSpreadEnabled;   // on or off
+  uint8_t      UclkSpreadPercent;   // Q4.4
+  uint16_t     UclkSpreadFreq;      // kHz
+
+  // SOCCLK Spread Spectrum
+  uint8_t      SoclkSpreadEnabled;   // on or off
+  uint8_t      SocclkSpreadPercent;   // Q4.4
+  uint16_t     SocclkSpreadFreq;      // kHz
+
+  // Total board power
+  uint16_t     TotalBoardPower;     //Only needed for TCP Estimated case, where TCP = TGP+Total Board Power
+  uint16_t     BoardPadding; 
+
+  // Mvdd Svi2 Div Ratio Setting
+  uint32_t MvddRatio; // This is used for MVDD Vid workaround. It has 16 fractional bits (Q16.16)
+  
+  uint32_t     BoardReserved[9];
+
+};
+
 /* 
   ***************************************************************************
     Data Table asic_profiling_info  structure
@@ -1870,8 +2002,7 @@ struct atom_umc_info_v3_3
     Data Table vram_info  structure
   ***************************************************************************
 */
-struct atom_vram_module_v9
-{
+struct atom_vram_module_v9 {
   // Design Specific Values
   uint32_t  memory_size;                   // Total memory size in unit of MB for CONFIG_MEMSIZE zeros
   uint32_t  channel_enable;                // bit vector, each bit indicate specific channel enable or not
@@ -1887,13 +2018,12 @@ struct atom_vram_module_v9
   uint8_t   tunningset_id;                 // MC phy registers set per. 
   uint8_t   vender_rev_id;                 // [7:4] Revision, [3:0] Vendor code
   uint8_t   refreshrate;                   // [1:0]=RefreshFactor (00=8ms, 01=16ms, 10=32ms,11=64ms)
-  uint8_t   hbm_ven_rev_id;				   // hbm_ven_rev_id
-  uint8_t   vram_rsd2;					   // reserved
+  uint8_t   hbm_ven_rev_id;		   // hbm_ven_rev_id
+  uint8_t   vram_rsd2;			   // reserved
   char    dram_pnstring[20];               // part number end with '0'. 
 };
 
-struct atom_vram_info_header_v2_3
-{
+struct atom_vram_info_header_v2_3 {
   struct   atom_common_table_header table_header;
   uint16_t mem_adjust_tbloffset;                         // offset of atom_umc_init_reg_block structure for memory vendor specific UMC adjust setting
   uint16_t mem_clk_patch_tbloffset;                      // offset of atom_umc_init_reg_block structure for memory clock specific UMC setting
@@ -1904,7 +2034,8 @@ struct atom_vram_info_header_v2_3
   uint16_t post_ucode_init_offset;                       // offset of atom_umc_init_reg_block structure for MC phy init after MC uCode complete umc init
   uint16_t vram_rsd2;
   uint8_t  vram_module_num;                              // indicate number of VRAM module
-  uint8_t  vram_rsd1[2];
+  uint8_t  umcip_min_ver;
+  uint8_t  umcip_max_ver;
   uint8_t  mc_phy_tile_num;                              // indicate the MCD tile number which use in DramDataRemapTbl and usMcAdjustPerTileTblOffset
   struct   atom_vram_module_v9  vram_module[16];         // just for allocation, real number of blocks is in ucNumOfVRAMModule;
 };
@@ -1949,6 +2080,47 @@ struct atom_umc_init_reg_block{
   struct atom_umc_reg_setting_data_block umc_reg_setting_list[1];
 };
 
+struct atom_vram_module_v10 {
+  // Design Specific Values
+  uint32_t  memory_size;                   // Total memory size in unit of MB for CONFIG_MEMSIZE zeros
+  uint32_t  channel_enable;                // bit vector, each bit indicate specific channel enable or not
+  uint32_t  max_mem_clk;                   // max memory clock of this memory in unit of 10kHz, =0 means it is not defined
+  uint16_t  reserved[3];
+  uint16_t  mem_voltage;                   // mem_voltage
+  uint16_t  vram_module_size;              // Size of atom_vram_module_v9
+  uint8_t   ext_memory_id;                 // Current memory module ID
+  uint8_t   memory_type;                   // enum of atom_dgpu_vram_type
+  uint8_t   channel_num;                   // Number of mem. channels supported in this module
+  uint8_t   channel_width;                 // CHANNEL_16BIT/CHANNEL_32BIT/CHANNEL_64BIT
+  uint8_t   density;                       // _8Mx32, _16Mx32, _16Mx16, _32Mx16
+  uint8_t   tunningset_id;                 // MC phy registers set per
+  uint8_t   vender_rev_id;                 // [7:4] Revision, [3:0] Vendor code
+  uint8_t   refreshrate;                   // [1:0]=RefreshFactor (00=8ms, 01=16ms, 10=32ms,11=64ms)
+  uint8_t   vram_flags;			   // bit0= bankgroup enable
+  uint8_t   vram_rsd2;			   // reserved
+  uint16_t  gddr6_mr10;                    // gddr6 mode register10 value
+  uint16_t  gddr6_mr1;                     // gddr6 mode register1 value
+  uint16_t  gddr6_mr2;                     // gddr6 mode register2 value
+  uint16_t  gddr6_mr7;                     // gddr6 mode register7 value
+  char    dram_pnstring[20];               // part number end with '0'
+};
+
+struct atom_vram_info_header_v2_4 {
+  struct   atom_common_table_header table_header;
+  uint16_t mem_adjust_tbloffset;                         // offset of atom_umc_init_reg_block structure for memory vendor specific UMC adjust setting
+  uint16_t mem_clk_patch_tbloffset;                      // offset of atom_umc_init_reg_block structure for memory clock specific UMC setting
+  uint16_t mc_adjust_pertile_tbloffset;                  // offset of atom_umc_init_reg_block structure for Per Byte Offset Preset Settings
+  uint16_t mc_phyinit_tbloffset;                         // offset of atom_umc_init_reg_block structure for MC phy init set
+  uint16_t dram_data_remap_tbloffset;                    // reserved for now
+  uint16_t reserved;                                     // offset of reserved
+  uint16_t post_ucode_init_offset;                       // offset of atom_umc_init_reg_block structure for MC phy init after MC uCode complete umc init
+  uint16_t vram_rsd2;
+  uint8_t  vram_module_num;                              // indicate number of VRAM module
+  uint8_t  umcip_min_ver;
+  uint8_t  umcip_max_ver;
+  uint8_t  mc_phy_tile_num;                              // indicate the MCD tile number which use in DramDataRemapTbl and usMcAdjustPerTileTblOffset
+  struct   atom_vram_module_v10  vram_module[16];        // just for allocation, real number of blocks is in ucNumOfVRAMModule;
+};
 
 /* 
   ***************************************************************************
-- 
2.17.1

