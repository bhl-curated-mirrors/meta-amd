From 5a43334ca3f61f5e4652156a0410c467b6abe81a Mon Sep 17 00:00:00 2001
From: Leo Liu <leo.liu@amd.com>
Date: Fri, 24 May 2019 12:19:00 -0400
Subject: [PATCH 2402/2940] drm/amdgpu/VCN2.0: add direct SRAM read and write

This will be the basic and used for DPG mode

Signed-off-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Reviewed-by: James Zhu <James.Zhu@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.h | 48 +++++++++++++++++++++++++
 1 file changed, 48 insertions(+)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.h
index 7ae7280bac5f..5b38798f8bc3 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.h
@@ -45,6 +45,11 @@
 #define VCN_ENC_CMD_REG_WRITE		0x0000000b
 #define VCN_ENC_CMD_REG_WAIT		0x0000000c
 
+#define VCN_VID_SOC_ADDRESS_2_0 	0x1fa00
+#define VCN_AON_SOC_ADDRESS_2_0 	0x1f800
+#define VCN_VID_IP_ADDRESS_2_0		0x0
+#define VCN_AON_IP_ADDRESS_2_0		0x30000
+
 #define RREG32_SOC15_DPG_MODE(ip, inst, reg, mask, sram_sel) 				\
 	({	WREG32_SOC15(ip, inst, mmUVD_DPG_LMA_MASK, mask); 			\
 		WREG32_SOC15(ip, inst, mmUVD_DPG_LMA_CTL, 				\
@@ -66,6 +71,49 @@
 			(sram_sel << UVD_DPG_LMA_CTL__SRAM_SEL__SHIFT)); 		\
 	} while (0)
 
+#define SOC15_DPG_MODE_OFFSET_2_0(ip, inst, reg) 						\
+	({											\
+		uint32_t internal_reg_offset, addr;						\
+		bool video_range, aon_range;							\
+												\
+		addr = (adev->reg_offset[ip##_HWIP][inst][reg##_BASE_IDX] + reg);		\
+		addr <<= 2; 									\
+		video_range = ((((0xFFFFF & addr) >= (VCN_VID_SOC_ADDRESS_2_0)) && 		\
+				((0xFFFFF & addr) < ((VCN_VID_SOC_ADDRESS_2_0 + 0x2600)))));	\
+		aon_range   = ((((0xFFFFF & addr) >= (VCN_AON_SOC_ADDRESS_2_0)) && 		\
+				((0xFFFFF & addr) < ((VCN_AON_SOC_ADDRESS_2_0 + 0x600)))));	\
+		if (video_range) 								\
+			internal_reg_offset = ((0xFFFFF & addr) - (VCN_VID_SOC_ADDRESS_2_0) + 	\
+				(VCN_VID_IP_ADDRESS_2_0));					\
+		else if (aon_range)								\
+			internal_reg_offset = ((0xFFFFF & addr) - (VCN_AON_SOC_ADDRESS_2_0) + 	\
+				(VCN_AON_IP_ADDRESS_2_0));					\
+		else										\
+			internal_reg_offset = (0xFFFFF & addr);					\
+												\
+		internal_reg_offset >>= 2;							\
+	})
+
+#define RREG32_SOC15_DPG_MODE_2_0(offset, mask_en) 						\
+	({ 											\
+		WREG32_SOC15(VCN, 0, mmUVD_DPG_LMA_CTL, 					\
+			(0x0 << UVD_DPG_LMA_CTL__READ_WRITE__SHIFT | 				\
+			mask_en << UVD_DPG_LMA_CTL__MASK_EN__SHIFT | 				\
+			offset << UVD_DPG_LMA_CTL__READ_WRITE_ADDR__SHIFT)); 			\
+		RREG32_SOC15(VCN, 0, mmUVD_DPG_LMA_DATA); 					\
+	})
+
+#define WREG32_SOC15_DPG_MODE_2_0(offset, value, mask_en, indirect)				\
+	do { 											\
+		if (!indirect) { 								\
+			WREG32_SOC15(VCN, 0, mmUVD_DPG_LMA_DATA, value); 			\
+			WREG32_SOC15(VCN, 0, mmUVD_DPG_LMA_CTL, 				\
+				(0x1 << UVD_DPG_LMA_CTL__READ_WRITE__SHIFT | 			\
+				 mask_en << UVD_DPG_LMA_CTL__MASK_EN__SHIFT | 			\
+				 offset << UVD_DPG_LMA_CTL__READ_WRITE_ADDR__SHIFT)); 		\
+		} 										\
+	} while (0)
+
 enum engine_status_constants {
 	UVD_PGFSM_STATUS__UVDM_UVDU_PWR_ON = 0x2AAAA0,
 	UVD_PGFSM_STATUS__UVDM_UVDU_PWR_ON_2_0 = 0xAAAA0,
-- 
2.17.1

