From 2d58eecf8ce15aaeb210dc2d4e42e136c4fa5330 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christian=20K=C3=B6nig?= <christian.koenig@amd.com>
Date: Tue, 30 Jul 2019 14:01:11 +0200
Subject: [PATCH 3158/4256] Revert accidential push
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit 51b7e1515aa2d9ea34cd8f629667cc99b3114e99.
This reverts commit 77012ddc093927f3cd0a0826b4b6eb13df3489dd.
This reverts commit b71ea8f524f88de51be73fd74a111e2f3aa4d119.

Accidentially pushed.

Signed-off-by: Christian KÃ¶nig <christian.koenig@amd.com>
---
 drivers/dma-buf/dma-fence-chain.c | 144 +++++++-----------------------
 include/linux/dma-fence-chain.h   |  35 --------
 2 files changed, 34 insertions(+), 145 deletions(-)

diff --git a/drivers/dma-buf/dma-fence-chain.c b/drivers/dma-buf/dma-fence-chain.c
index 58fc68ed5df9..c729f98a7bd3 100644
--- a/drivers/dma-buf/dma-fence-chain.c
+++ b/drivers/dma-buf/dma-fence-chain.c
@@ -20,67 +20,22 @@
 static bool dma_fence_chain_enable_signaling(struct dma_fence *fence);
 
 /**
- * dma_fence_chain_get - use RCU to get a reference to a fence
- * @pfence: rcu protected fence pointer
+ * dma_fence_chain_get_prev - use RCU to get a reference to the previous fence
+ * @chain: chain node to get the previous node from
  *
- * Use dma_fence_get_rcu_safe to get a reference to a fence in a chain.
+ * Use dma_fence_get_rcu_safe to get a reference to the previous fence of the
+ * chain node.
  */
-static struct dma_fence *dma_fence_chain_get(struct dma_fence __rcu **pfence)
+static struct dma_fence *dma_fence_chain_get_prev(struct dma_fence_chain *chain)
 {
 	struct dma_fence *prev;
 
 	rcu_read_lock();
-	prev = dma_fence_get_rcu_safe(pfence);
+	prev = dma_fence_get_rcu_safe(&chain->prev);
 	rcu_read_unlock();
 	return prev;
 }
 
-/**
- * dma_fence_chain_is_dead - check if dma_fence_chain should be unlinked
- * @fence: fence to check
- *
- * If @fence is a dma_fence_chain node we check if the contained fence is
- * signaled, otherwise we check if just this fence is signaled.
- */
-static bool dma_fence_chain_is_dead(struct dma_fence *fence)
-{
-	struct dma_fence_chain *chain = to_dma_fence_chain(fence);
-
-	if (chain)
-		return dma_fence_is_signaled(chain->fence);
-
-	return dma_fence_is_signaled(fence);
-}
-
-/**
- * dma_fence_chain_unlink - make an RCU safe removal of a chain node
- * @pfence: the pointer to replace
- * @old: the current value of that pointer
- *
- * Tries to replace the RCU protected value of pointer @pfence with the previous
- * fence in the chain. The reference to the old fence is dropped no matter if
- * the exchange was succesfully or not.
- */
-static void dma_fence_chain_unlink(struct dma_fence __rcu **pfence,
-				   struct dma_fence *old)
-{
-	struct dma_fence *replacement, *tmp;
-	struct dma_fence_chain *chain;
-
-	chain = to_dma_fence_chain(old);
-	if (chain)
-		replacement = dma_fence_chain_get(&chain->prev);
-	else
-		replacement = NULL;
-
-	tmp = cmpxchg((void **)pfence, (void *)current, (void *)replacement);
-	if (tmp == old)
-		dma_fence_put(tmp);
-	else
-		dma_fence_put(replacement);
-	dma_fence_put(old);
-}
-
 /**
  * dma_fence_chain_walk - chain walking function
  * @fence: current chain node
@@ -91,8 +46,8 @@ static void dma_fence_chain_unlink(struct dma_fence __rcu **pfence,
  */
 struct dma_fence *dma_fence_chain_walk(struct dma_fence *fence)
 {
-	struct dma_fence_chain *chain;
-	struct dma_fence *prev;
+	struct dma_fence_chain *chain, *prev_chain;
+	struct dma_fence *prev, *replacement, *tmp;
 
 	chain = to_dma_fence_chain(fence);
 	if (!chain) {
@@ -100,12 +55,27 @@ struct dma_fence *dma_fence_chain_walk(struct dma_fence *fence)
 		return NULL;
 	}
 
-	while ((prev = dma_fence_chain_get(&chain->prev))) {
+	while ((prev = dma_fence_chain_get_prev(chain))) {
 
-		if (!dma_fence_chain_is_dead(prev))
-			break;
+		prev_chain = to_dma_fence_chain(prev);
+		if (prev_chain) {
+			if (!dma_fence_is_signaled(prev_chain->fence))
+				break;
+
+			replacement = dma_fence_chain_get_prev(prev_chain);
+		} else {
+			if (!dma_fence_is_signaled(prev))
+				break;
 
-		dma_fence_chain_unlink(&chain->prev, prev);
+			replacement = NULL;
+		}
+
+		tmp = cmpxchg((void **)&chain->prev, (void *)prev, (void *)replacement);
+		if (tmp == prev)
+			dma_fence_put(tmp);
+		else
+			dma_fence_put(replacement);
+		dma_fence_put(prev);
 	}
 
 	dma_fence_put(fence);
@@ -146,55 +116,6 @@ int dma_fence_chain_find_seqno(struct dma_fence **pfence, uint64_t seqno)
 }
 EXPORT_SYMBOL(dma_fence_chain_find_seqno);
 
-/**
- * dma_fence_chain_remove_fences - remove fences from a chain
- * @pfence: pointer to the chain node where to start
- * @cb: callback to decide if fence should be removed
- * @data: data for the callback
- *
- * Iterate over the chain nodes until we can be sure that there are no more
- * fences which should be removed.
- *
- * To remove a node we need to iterate at least twice to make sure we doesn't
- * collide with concurrent operations.
- */
-void dma_fence_chain_remove_fence(struct dma_fence __rcu **pfence,
-				  bool (*cb)(struct dma_fence *f, void *data),
-				  void *data)
-{
-	struct dma_fence_chain *chain = NULL;
-	struct dma_fence **prev, *fence;
-
-retry:
-	prev = pfence;
-	while ((fence = dma_fence_chain_get(prev))) {
-		dma_fence_put(&chain->base);
-		chain = to_dma_fence_chain(fence);
-
-		if (dma_fence_chain_is_dead(fence)) {
-			dma_fence_chain_unlink(prev, fence);
-			continue;
-		}
-
-		if (cb(chain ? chain->fence : fence, data)) {
-			dma_fence_chain_unlink(prev, fence);
-			/* Restart the search cause it can be that the previous
-			 * chain is unlinked just as we try to unlink this one.
-			 */
-			goto retry;
-		}
-
-		if (!chain) {
-			dma_fence_put(fence);
-			break;
-		}
-
-		prev = &chain->prev;
-	}
-	dma_fence_put(&chain->base);
-}
-EXPORT_SYMBOL(dma_fence_chain_remove_fence);
-
 static const char *dma_fence_chain_get_driver_name(struct dma_fence *fence)
 {
         return "dma_fence_chain";
@@ -230,10 +151,12 @@ static void dma_fence_chain_cb(struct dma_fence *f, struct dma_fence_cb *cb)
 static bool dma_fence_chain_enable_signaling(struct dma_fence *fence)
 {
 	struct dma_fence_chain *head = to_dma_fence_chain(fence);
-	struct dma_fence *f;
 
 	dma_fence_get(&head->base);
-	dma_fence_chain_for_each_unwrap(f, fence, &head->base) {
+	dma_fence_chain_for_each(fence, &head->base) {
+		struct dma_fence_chain *chain = to_dma_fence_chain(fence);
+		struct dma_fence *f = chain ? chain->fence : fence;
+
 		dma_fence_get(f);
 		if (!dma_fence_add_callback(f, &head->cb, dma_fence_chain_cb)) {
 			dma_fence_put(fence);
@@ -247,9 +170,10 @@ static bool dma_fence_chain_enable_signaling(struct dma_fence *fence)
 
 static bool dma_fence_chain_signaled(struct dma_fence *fence)
 {
-	struct dma_fence *f;
+	dma_fence_chain_for_each(fence, fence) {
+		struct dma_fence_chain *chain = to_dma_fence_chain(fence);
+		struct dma_fence *f = chain ? chain->fence : fence;
 
-	dma_fence_chain_for_each_unwrap(f, fence, fence) {
 		if (!dma_fence_is_signaled(f)) {
 			dma_fence_put(fence);
 			return false;
diff --git a/include/linux/dma-fence-chain.h b/include/linux/dma-fence-chain.h
index 694f35fb2b5e..934a442db8ac 100644
--- a/include/linux/dma-fence-chain.h
+++ b/include/linux/dma-fence-chain.h
@@ -59,24 +59,6 @@ to_dma_fence_chain(struct dma_fence *fence)
 	return container_of(fence, struct dma_fence_chain, base);
 }
 
-/**
- * dma_fence_chain_unwrap - unwrap chain node
- * @fence: fence which could be a chain node
- *
- * If the paramter is a chain node return the cotained fence, otherwise return
- * the parameter itself.
- */
-static inline struct dma_fence *
-dma_fence_chain_unwrap(struct dma_fence *fence)
-{
-	struct dma_fence_chain *chain = to_dma_fence_chain(fence);
-
-	if (!chain)
-		return fence;
-
-	return chain->fence;
-}
-
 /**
  * dma_fence_chain_for_each - iterate over all fences in chain
  * @iter: current fence
@@ -89,25 +71,8 @@ dma_fence_chain_unwrap(struct dma_fence *fence)
 	for (iter = dma_fence_get(head); iter; \
 	     iter = dma_fence_chain_walk(iter))
 
-/**
- * dma_fence_chain_for_each_unwrap - iterate over all unwrapped fences in chain
- * @fence: the unwrapped fence
- * @iter: current fence
- * @head: starting point
- *
- * Iterate over all fences in the chain with unwrapping. We keep a reference to
- * the current fence while inside the loop which must be dropped when breaking
- * out.
- */
-#define dma_fence_chain_for_each_unwrap(fence, iter, head)	\
-	for (iter = dma_fence_get(head),			\
-	     fence = dma_fence_chain_unwrap(iter);		\
-	     iter; iter = dma_fence_chain_walk(iter),		\
-	     fence = dma_fence_chain_unwrap(iter))
-
 struct dma_fence *dma_fence_chain_walk(struct dma_fence *fence);
 int dma_fence_chain_find_seqno(struct dma_fence **pfence, uint64_t seqno);
-void dma_fence_chain_purge_ctx(struct dma_fence **pfence, uint64_t ctx);
 void dma_fence_chain_init(struct dma_fence_chain *chain,
 			  struct dma_fence *prev,
 			  struct dma_fence *fence,
-- 
2.17.1

