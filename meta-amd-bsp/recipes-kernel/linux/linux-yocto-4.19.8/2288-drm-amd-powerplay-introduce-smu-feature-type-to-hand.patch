From 2905cb815602297503a5df19b0861aeda0e381d2 Mon Sep 17 00:00:00 2001
From: Huang Rui <ray.huang@amd.com>
Date: Wed, 29 May 2019 23:14:33 -0500
Subject: [PATCH 2288/2940] drm/amd/powerplay: introduce smu feature type to
 handle feature mask for each asic

This patch introduces new smu feature type, it's to handle the different feature
mask defines for each asic with the same smu ip.

Signed-off-by: Huang Rui <ray.huang@amd.com>
Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/powerplay/amdgpu_smu.c    |  22 +++-
 .../gpu/drm/amd/powerplay/inc/amdgpu_smu.h    |  72 ++++++++++-
 .../amd/powerplay/inc/smu_11_0_driver_if.h    |   4 +-
 drivers/gpu/drm/amd/powerplay/inc/smu_v11_0.h |   3 +
 drivers/gpu/drm/amd/powerplay/navi10_ppt.c    |  63 ++++++++-
 drivers/gpu/drm/amd/powerplay/smu_v11_0.c     |  26 ++--
 drivers/gpu/drm/amd/powerplay/vega20_ppt.c    | 122 ++++++++++++------
 7 files changed, 251 insertions(+), 61 deletions(-)

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 87822f434350..99e10313afa2 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -254,11 +254,14 @@ int smu_feature_init_dpm(struct smu_context *smu)
 	return ret;
 }
 
-int smu_feature_is_enabled(struct smu_context *smu, int feature_id)
+int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_id;
 	int ret = 0;
 
+	feature_id = smu_feature_get_index(smu, mask);
+
 	WARN_ON(feature_id > feature->feature_num);
 
 	mutex_lock(&feature->mutex);
@@ -268,11 +271,15 @@ int smu_feature_is_enabled(struct smu_context *smu, int feature_id)
 	return ret;
 }
 
-int smu_feature_set_enabled(struct smu_context *smu, int feature_id, bool enable)
+int smu_feature_set_enabled(struct smu_context *smu, enum smu_feature_mask mask,
+			    bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_id;
 	int ret = 0;
 
+	feature_id = smu_feature_get_index(smu, mask);
+
 	WARN_ON(feature_id > feature->feature_num);
 
 	mutex_lock(&feature->mutex);
@@ -291,11 +298,14 @@ int smu_feature_set_enabled(struct smu_context *smu, int feature_id, bool enable
 	return ret;
 }
 
-int smu_feature_is_supported(struct smu_context *smu, int feature_id)
+int smu_feature_is_supported(struct smu_context *smu, enum smu_feature_mask mask)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_id;
 	int ret = 0;
 
+	feature_id = smu_feature_get_index(smu, mask);
+
 	WARN_ON(feature_id > feature->feature_num);
 
 	mutex_lock(&feature->mutex);
@@ -305,12 +315,16 @@ int smu_feature_is_supported(struct smu_context *smu, int feature_id)
 	return ret;
 }
 
-int smu_feature_set_supported(struct smu_context *smu, int feature_id,
+int smu_feature_set_supported(struct smu_context *smu,
+			      enum smu_feature_mask mask,
 			      bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_id;
 	int ret = 0;
 
+	feature_id = smu_feature_get_index(smu, mask);
+
 	WARN_ON(feature_id > feature->feature_num);
 
 	mutex_lock(&feature->mutex);
diff --git a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
index 65990dd700f0..f0b313baf04d 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
@@ -243,6 +243,63 @@ enum smu_clk_type
 	SMU_CLK_COUNT,
 };
 
+enum smu_feature_mask
+{
+	SMU_FEATURE_DPM_PREFETCHER_BIT,
+	SMU_FEATURE_DPM_GFXCLK_BIT,
+	SMU_FEATURE_DPM_UCLK_BIT,
+	SMU_FEATURE_DPM_SOCCLK_BIT,
+	SMU_FEATURE_DPM_UVD_BIT,
+	SMU_FEATURE_DPM_VCE_BIT,
+	SMU_FEATURE_ULV_BIT,
+	SMU_FEATURE_DPM_MP0CLK_BIT,
+	SMU_FEATURE_DPM_LINK_BIT,
+	SMU_FEATURE_DPM_DCEFCLK_BIT,
+	SMU_FEATURE_DS_GFXCLK_BIT,
+	SMU_FEATURE_DS_SOCCLK_BIT,
+	SMU_FEATURE_DS_LCLK_BIT,
+	SMU_FEATURE_PPT_BIT,
+	SMU_FEATURE_TDC_BIT,
+	SMU_FEATURE_THERMAL_BIT,
+	SMU_FEATURE_GFX_PER_CU_CG_BIT,
+	SMU_FEATURE_RM_BIT,
+	SMU_FEATURE_DS_DCEFCLK_BIT,
+	SMU_FEATURE_ACDC_BIT,
+	SMU_FEATURE_VR0HOT_BIT,
+	SMU_FEATURE_VR1HOT_BIT,
+	SMU_FEATURE_FW_CTF_BIT,
+	SMU_FEATURE_LED_DISPLAY_BIT,
+	SMU_FEATURE_FAN_CONTROL_BIT,
+	SMU_FEATURE_GFX_EDC_BIT,
+	SMU_FEATURE_GFXOFF_BIT,
+	SMU_FEATURE_CG_BIT,
+	SMU_FEATURE_DPM_FCLK_BIT,
+	SMU_FEATURE_DS_FCLK_BIT,
+	SMU_FEATURE_DS_MP1CLK_BIT,
+	SMU_FEATURE_DS_MP0CLK_BIT,
+	SMU_FEATURE_XGMI_BIT,
+	SMU_FEATURE_DPM_GFX_PACE_BIT,
+	SMU_FEATURE_MEM_VDDCI_SCALING_BIT,
+	SMU_FEATURE_MEM_MVDD_SCALING_BIT,
+	SMU_FEATURE_DS_UCLK_BIT,
+	SMU_FEATURE_GFX_ULV_BIT,
+	SMU_FEATURE_FW_DSTATE_BIT,
+	SMU_FEATURE_BACO_BIT,
+	SMU_FEATURE_VCN_PG_BIT,
+	SMU_FEATURE_JPEG_PG_BIT,
+	SMU_FEATURE_USB_PG_BIT,
+	SMU_FEATURE_RSMU_SMN_CG_BIT,
+	SMU_FEATURE_APCC_PLUS_BIT,
+	SMU_FEATURE_GTHR_BIT,
+	SMU_FEATURE_GFX_DCS_BIT,
+	SMU_FEATURE_GFX_SS_BIT,
+	SMU_FEATURE_OUT_OF_BAND_MONITOR_BIT,
+	SMU_FEATURE_TEMP_DEPENDENT_VMIN_BIT,
+	SMU_FEATURE_MMHUB_PG_BIT,
+	SMU_FEATURE_ATHUB_PG_BIT,
+	SMU_FEATURE_COUNT,
+};
+
 enum smu_memory_pool_size
 {
     SMU_MEMORY_POOL_SIZE_ZERO   = 0,
@@ -437,6 +494,7 @@ struct pptable_funcs {
 	int (*append_powerplay_table)(struct smu_context *smu);
 	int (*get_smu_msg_index)(struct smu_context *smu, uint32_t index);
 	int (*get_smu_clk_index)(struct smu_context *smu, uint32_t index);
+	int (*get_smu_feature_index)(struct smu_context *smu, uint32_t index);
 	int (*run_afll_btc)(struct smu_context *smu);
 	int (*get_allowed_feature_mask)(struct smu_context *smu, uint32_t *feature_mask, uint32_t num);
 	enum amd_pm_state_type (*get_current_power_state)(struct smu_context *smu);
@@ -723,6 +781,8 @@ struct smu_funcs
 	((smu)->ppt_funcs? ((smu)->ppt_funcs->get_smu_msg_index? (smu)->ppt_funcs->get_smu_msg_index((smu), (msg)) : -EINVAL) : -EINVAL)
 #define smu_clk_get_index(smu, msg) \
 	((smu)->ppt_funcs? ((smu)->ppt_funcs->get_smu_clk_index? (smu)->ppt_funcs->get_smu_clk_index((smu), (msg)) : -EINVAL) : -EINVAL)
+#define smu_feature_get_index(smu, msg) \
+	((smu)->ppt_funcs? ((smu)->ppt_funcs->get_smu_feature_index? (smu)->ppt_funcs->get_smu_feature_index((smu), (msg)) : -EINVAL) : -EINVAL)
 #define smu_run_afll_btc(smu) \
 	((smu)->ppt_funcs? ((smu)->ppt_funcs->run_afll_btc? (smu)->ppt_funcs->run_afll_btc((smu)) : 0) : 0)
 #define smu_get_allowed_feature_mask(smu, feature_mask, num) \
@@ -779,10 +839,14 @@ extern const struct amd_ip_funcs smu_ip_funcs;
 extern const struct amdgpu_ip_block_version smu_v11_0_ip_block;
 extern int smu_feature_init_dpm(struct smu_context *smu);
 
-extern int smu_feature_is_enabled(struct smu_context *smu, int feature_id);
-extern int smu_feature_set_enabled(struct smu_context *smu, int feature_id, bool enable);
-extern int smu_feature_is_supported(struct smu_context *smu, int feature_id);
-extern int smu_feature_set_supported(struct smu_context *smu, int feature_id, bool enable);
+extern int smu_feature_is_enabled(struct smu_context *smu,
+				  enum smu_feature_mask mask);
+extern int smu_feature_set_enabled(struct smu_context *smu,
+				   enum smu_feature_mask mask, bool enable);
+extern int smu_feature_is_supported(struct smu_context *smu,
+				    enum smu_feature_mask mask);
+extern int smu_feature_set_supported(struct smu_context *smu,
+				     enum smu_feature_mask mask, bool enable);
 
 int smu_update_table_with_arg(struct smu_context *smu, uint16_t table_id, uint16_t exarg,
 		     void *table_data, bool drv2smu);
diff --git a/drivers/gpu/drm/amd/powerplay/inc/smu_11_0_driver_if.h b/drivers/gpu/drm/amd/powerplay/inc/smu_11_0_driver_if.h
index a53547fa8980..1ab6e4eca09f 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/smu_11_0_driver_if.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/smu_11_0_driver_if.h
@@ -90,8 +90,8 @@
 #define FEATURE_OUT_OF_BAND_MONITOR_BIT 38
 #define FEATURE_TEMP_DEPENDENT_VMIN_BIT 39
 
-#define FEATURE_MMHUB_PG                40 
-#define FEATURE_ATHUB_PG                41
+#define FEATURE_MMHUB_PG_BIT            40
+#define FEATURE_ATHUB_PG_BIT            41
 #define FEATURE_SPARE_42_BIT            42
 #define FEATURE_SPARE_43_BIT            43
 #define FEATURE_SPARE_44_BIT            44
diff --git a/drivers/gpu/drm/amd/powerplay/inc/smu_v11_0.h b/drivers/gpu/drm/amd/powerplay/inc/smu_v11_0.h
index cae6619d2df5..9284c1edfe42 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/smu_v11_0.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/smu_v11_0.h
@@ -43,6 +43,9 @@
 #define CLK_MAP(clk, index) \
 	[SMU_##clk] = index
 
+#define FEA_MAP(fea) \
+	[SMU_FEATURE_##fea##_BIT] = FEATURE_##fea##_BIT
+
 struct smu_11_0_max_sustainable_clocks {
 	uint32_t display_clock;
 	uint32_t phy_clock;
diff --git a/drivers/gpu/drm/amd/powerplay/navi10_ppt.c b/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
index f45df244013f..d1c2d4e67879 100644
--- a/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
@@ -111,6 +111,51 @@ static int navi10_clk_map[SMU_CLK_COUNT] = {
 	CLK_MAP(PHYCLK, PPCLK_PHYCLK),
 };
 
+static int navi10_feature_mask_map[SMU_FEATURE_COUNT] = {
+	FEA_MAP(DPM_PREFETCHER),
+	FEA_MAP(DPM_GFXCLK),
+	FEA_MAP(DPM_GFX_PACE),
+	FEA_MAP(DPM_UCLK),
+	FEA_MAP(DPM_SOCCLK),
+	FEA_MAP(DPM_MP0CLK),
+	FEA_MAP(DPM_LINK),
+	FEA_MAP(DPM_DCEFCLK),
+	FEA_MAP(MEM_VDDCI_SCALING),
+	FEA_MAP(MEM_MVDD_SCALING),
+	FEA_MAP(DS_GFXCLK),
+	FEA_MAP(DS_SOCCLK),
+	FEA_MAP(DS_LCLK),
+	FEA_MAP(DS_DCEFCLK),
+	FEA_MAP(DS_UCLK),
+	FEA_MAP(GFX_ULV),
+	FEA_MAP(FW_DSTATE),
+	FEA_MAP(GFXOFF),
+	FEA_MAP(BACO),
+	FEA_MAP(VCN_PG),
+	FEA_MAP(JPEG_PG),
+	FEA_MAP(USB_PG),
+	FEA_MAP(RSMU_SMN_CG),
+	FEA_MAP(PPT),
+	FEA_MAP(TDC),
+	FEA_MAP(GFX_EDC),
+	FEA_MAP(APCC_PLUS),
+	FEA_MAP(GTHR),
+	FEA_MAP(ACDC),
+	FEA_MAP(VR0HOT),
+	FEA_MAP(VR1HOT),
+	FEA_MAP(FW_CTF),
+	FEA_MAP(FAN_CONTROL),
+	FEA_MAP(THERMAL),
+	FEA_MAP(GFX_DCS),
+	FEA_MAP(RM),
+	FEA_MAP(LED_DISPLAY),
+	FEA_MAP(GFX_SS),
+	FEA_MAP(OUT_OF_BAND_MONITOR),
+	FEA_MAP(TEMP_DEPENDENT_VMIN),
+	FEA_MAP(MMHUB_PG),
+	FEA_MAP(ATHUB_PG),
+};
+
 static int navi10_get_smu_msg_index(struct smu_context *smc, uint32_t index)
 {
 	int val;
@@ -137,6 +182,19 @@ static int navi10_get_smu_clk_index(struct smu_context *smc, uint32_t index)
 	return val;
 }
 
+static int navi10_get_smu_feature_index(struct smu_context *smc, uint32_t index)
+{
+	int val;
+	if (index >= SMU_FEATURE_COUNT)
+		return -EINVAL;
+
+	val = navi10_feature_mask_map[index];
+	if (val > 64)
+		return -EINVAL;
+
+	return val;
+}
+
 #define FEATURE_MASK(feature) (1UL << feature)
 static int
 navi10_get_allowed_feature_mask(struct smu_context *smu,
@@ -163,8 +221,8 @@ navi10_get_allowed_feature_mask(struct smu_context *smu,
 				| FEATURE_MASK(FEATURE_FAN_CONTROL_BIT)
 				| FEATURE_MASK(FEATURE_THERMAL_BIT)
 				| FEATURE_MASK(FEATURE_LED_DISPLAY_BIT)
-				| FEATURE_MASK(FEATURE_MMHUB_PG)
-				| FEATURE_MASK(FEATURE_ATHUB_PG)
+				| FEATURE_MASK(FEATURE_MMHUB_PG_BIT)
+				| FEATURE_MASK(FEATURE_ATHUB_PG_BIT)
 				| FEATURE_MASK(FEATURE_DPM_DCEFCLK_BIT);
 
 	if (adev->pm.pp_feature & PP_GFXOFF_MASK)
@@ -353,6 +411,7 @@ static const struct pptable_funcs navi10_ppt_funcs = {
 	.append_powerplay_table = navi10_append_powerplay_table,
 	.get_smu_msg_index = navi10_get_smu_msg_index,
 	.get_smu_clk_index = navi10_get_smu_clk_index,
+	.get_smu_feature_index = navi10_get_smu_feature_index,
 	.get_allowed_feature_mask = navi10_get_allowed_feature_mask,
 	.set_default_dpm_table = navi10_set_default_dpm_table,
 };
diff --git a/drivers/gpu/drm/amd/powerplay/smu_v11_0.c b/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
index 367c9795985c..8c60cdcba4ef 100644
--- a/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
+++ b/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
@@ -912,7 +912,7 @@ static int smu_v11_0_notify_display_change(struct smu_context *smu)
 
 	if (!smu->pm_enabled)
 		return ret;
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT))
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT))
 	    ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetUclkFastSwitch, 1);
 
 	return ret;
@@ -969,7 +969,7 @@ static int smu_v11_0_init_max_sustainable_clocks(struct smu_context *smu)
 	max_sustainable_clocks->phy_clock = 0xFFFFFFFF;
 	max_sustainable_clocks->pixel_clock = 0xFFFFFFFF;
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
 		ret = smu_v11_0_get_max_sustainable_clock(smu,
 							  &(max_sustainable_clocks->uclock),
 							  SMU_UCLK);
@@ -980,7 +980,7 @@ static int smu_v11_0_init_max_sustainable_clocks(struct smu_context *smu)
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_SOCCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
 		ret = smu_v11_0_get_max_sustainable_clock(smu,
 							  &(max_sustainable_clocks->soc_clock),
 							  SMU_SOCCLK);
@@ -991,7 +991,7 @@ static int smu_v11_0_init_max_sustainable_clocks(struct smu_context *smu)
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_DCEFCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {
 		ret = smu_v11_0_get_max_sustainable_clock(smu,
 							  &(max_sustainable_clocks->dcef_clock),
 							  SMU_DCEFCLK);
@@ -1076,7 +1076,7 @@ static int smu_v11_0_set_power_limit(struct smu_context *smu, uint32_t n)
 		max_power_limit /= 100;
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_PPT_BIT))
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_PPT_BIT))
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetPptLimit, n);
 	if (ret) {
 		pr_err("[%s] Set power limit Failed!", __func__);
@@ -1439,7 +1439,7 @@ smu_v11_0_display_clock_voltage_request(struct smu_context *smu,
 
 	if (!smu->pm_enabled)
 		return -EINVAL;
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_DCEFCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {
 		switch (clk_type) {
 		case amd_pp_dcef_clock:
 			clk_select = SMU_DCEFCLK;
@@ -1539,8 +1539,8 @@ smu_v11_0_set_watermarks_for_clock_ranges(struct smu_context *smu, struct
 	Watermarks_t *table = watermarks->cpu_addr;
 
 	if (!smu->disable_watermark &&
-	    smu_feature_is_enabled(smu, FEATURE_DPM_DCEFCLK_BIT) &&
-	    smu_feature_is_enabled(smu, FEATURE_DPM_SOCCLK_BIT)) {
+	    smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) &&
+	    smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
 		smu_v11_0_set_watermarks_table(smu, table, clock_ranges);
 		smu->watermarks_bitmap |= WATERMARKS_EXIST;
 		smu->watermarks_bitmap &= ~WATERMARKS_LOADED;
@@ -1608,7 +1608,7 @@ static uint32_t smu_v11_0_dpm_get_sclk(struct smu_context *smu, bool low)
 	uint32_t gfx_clk;
 	int ret;
 
-	if (!smu_feature_is_enabled(smu, FEATURE_DPM_GFXCLK_BIT)) {
+	if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {
 		pr_err("[GetSclks]: gfxclk dpm not enabled!\n");
 		return -EPERM;
 	}
@@ -1635,7 +1635,7 @@ static uint32_t smu_v11_0_dpm_get_mclk(struct smu_context *smu, bool low)
 	uint32_t mem_clk;
 	int ret;
 
-	if (!smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT)) {
+	if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
 		pr_err("[GetMclks]: memclk dpm not enabled!\n");
 		return -EPERM;
 	}
@@ -1743,7 +1743,7 @@ static int smu_v11_0_get_current_rpm(struct smu_context *smu,
 static uint32_t
 smu_v11_0_get_fan_control_mode(struct smu_context *smu)
 {
-	if (!smu_feature_is_enabled(smu, FEATURE_FAN_CONTROL_BIT))
+	if (!smu_feature_is_enabled(smu, SMU_FEATURE_FAN_CONTROL_BIT))
 		return AMD_FAN_CTRL_MANUAL;
 	else
 		return AMD_FAN_CTRL_AUTO;
@@ -1770,10 +1770,10 @@ smu_v11_0_smc_fan_control(struct smu_context *smu, bool start)
 {
 	int ret = 0;
 
-	if (smu_feature_is_supported(smu, FEATURE_FAN_CONTROL_BIT))
+	if (smu_feature_is_supported(smu, SMU_FEATURE_FAN_CONTROL_BIT))
 		return 0;
 
-	ret = smu_feature_set_enabled(smu, FEATURE_FAN_CONTROL_BIT, start);
+	ret = smu_feature_set_enabled(smu, SMU_FEATURE_FAN_CONTROL_BIT, start);
 	if (ret)
 		pr_err("[%s]%s smc FAN CONTROL feature failed!",
 		       __func__, (start ? "Start" : "Stop"));
diff --git a/drivers/gpu/drm/amd/powerplay/vega20_ppt.c b/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
index b3fc9c034aa0..718fd4dec531 100644
--- a/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
@@ -153,6 +153,55 @@ static int vega20_clk_map[SMU_CLK_COUNT] = {
 	CLK_MAP(FCLK, PPCLK_FCLK),
 };
 
+static int vega20_feature_mask_map[SMU_FEATURE_COUNT] = {
+	FEA_MAP(DPM_PREFETCHER),
+	FEA_MAP(DPM_GFXCLK),
+	FEA_MAP(DPM_UCLK),
+	FEA_MAP(DPM_SOCCLK),
+	FEA_MAP(DPM_UVD),
+	FEA_MAP(DPM_VCE),
+	FEA_MAP(ULV),
+	FEA_MAP(DPM_MP0CLK),
+	FEA_MAP(DPM_LINK),
+	FEA_MAP(DPM_DCEFCLK),
+	FEA_MAP(DS_GFXCLK),
+	FEA_MAP(DS_SOCCLK),
+	FEA_MAP(DS_LCLK),
+	FEA_MAP(PPT),
+	FEA_MAP(TDC),
+	FEA_MAP(THERMAL),
+	FEA_MAP(GFX_PER_CU_CG),
+	FEA_MAP(RM),
+	FEA_MAP(DS_DCEFCLK),
+	FEA_MAP(ACDC),
+	FEA_MAP(VR0HOT),
+	FEA_MAP(VR1HOT),
+	FEA_MAP(FW_CTF),
+	FEA_MAP(LED_DISPLAY),
+	FEA_MAP(FAN_CONTROL),
+	FEA_MAP(GFX_EDC),
+	FEA_MAP(GFXOFF),
+	FEA_MAP(CG),
+	FEA_MAP(DPM_FCLK),
+	FEA_MAP(DS_FCLK),
+	FEA_MAP(DS_MP1CLK),
+	FEA_MAP(DS_MP0CLK),
+	FEA_MAP(XGMI),
+};
+
+static int vega20_get_smu_feature_index(struct smu_context *smc, uint32_t index)
+{
+	int val;
+	if (index >= SMU_FEATURE_COUNT)
+		return -EINVAL;
+
+	val = vega20_feature_mask_map[index];
+	if (val > 64)
+		return -EINVAL;
+
+	return val;
+}
+
 static int vega20_get_smu_clk_index(struct smu_context *smc, uint32_t index)
 {
 	int val;
@@ -565,7 +614,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* socclk */
 	single_dpm_table = &(dpm_table->soc_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_SOCCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table,
 						  PPCLK_SOCCLK);
 		if (ret) {
@@ -581,7 +630,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* gfxclk */
 	single_dpm_table = &(dpm_table->gfx_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_GFXCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table,
 						  PPCLK_GFXCLK);
 		if (ret) {
@@ -597,7 +646,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* memclk */
 	single_dpm_table = &(dpm_table->mem_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table,
 						  PPCLK_UCLK);
 		if (ret) {
@@ -613,7 +662,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* eclk */
 	single_dpm_table = &(dpm_table->eclk_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_VCE_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_VCE_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table, PPCLK_ECLK);
 		if (ret) {
 			pr_err("[SetupDefaultDpmTable] failed to get eclk dpm levels!");
@@ -628,7 +677,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* vclk */
 	single_dpm_table = &(dpm_table->vclk_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UVD_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UVD_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table, PPCLK_VCLK);
 		if (ret) {
 			pr_err("[SetupDefaultDpmTable] failed to get vclk dpm levels!");
@@ -643,7 +692,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* dclk */
 	single_dpm_table = &(dpm_table->dclk_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UVD_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UVD_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table, PPCLK_DCLK);
 		if (ret) {
 			pr_err("[SetupDefaultDpmTable] failed to get dclk dpm levels!");
@@ -658,7 +707,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* dcefclk */
 	single_dpm_table = &(dpm_table->dcef_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_DCEFCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table,
 						  PPCLK_DCEFCLK);
 		if (ret) {
@@ -674,7 +723,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* pixclk */
 	single_dpm_table = &(dpm_table->pixel_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_DCEFCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table,
 						  PPCLK_PIXCLK);
 		if (ret) {
@@ -689,7 +738,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* dispclk */
 	single_dpm_table = &(dpm_table->display_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_DCEFCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table,
 						  PPCLK_DISPCLK);
 		if (ret) {
@@ -704,7 +753,7 @@ static int vega20_set_default_dpm_table(struct smu_context *smu)
 	/* phyclk */
 	single_dpm_table = &(dpm_table->phy_table);
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_DCEFCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {
 		ret = vega20_set_single_dpm_table(smu, single_dpm_table,
 						  PPCLK_PHYCLK);
 		if (ret) {
@@ -1034,7 +1083,7 @@ static int vega20_upload_dpm_level(struct smu_context *smu, bool max,
 
 	dpm_table = smu->smu_dpm.dpm_context;
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_GFXCLK_BIT) &&
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT) &&
 	    (feature_mask & FEATURE_DPM_GFXCLK_MASK)) {
 		single_dpm_table = &(dpm_table->gfx_table);
 		freq = max ? single_dpm_table->dpm_state.soft_max_level :
@@ -1049,7 +1098,7 @@ static int vega20_upload_dpm_level(struct smu_context *smu, bool max,
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT) &&
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT) &&
 	    (feature_mask & FEATURE_DPM_UCLK_MASK)) {
 		single_dpm_table = &(dpm_table->mem_table);
 		freq = max ? single_dpm_table->dpm_state.soft_max_level :
@@ -1064,7 +1113,7 @@ static int vega20_upload_dpm_level(struct smu_context *smu, bool max,
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_SOCCLK_BIT) &&
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT) &&
 	    (feature_mask & FEATURE_DPM_SOCCLK_MASK)) {
 		single_dpm_table = &(dpm_table->soc_table);
 		freq = max ? single_dpm_table->dpm_state.soft_max_level :
@@ -1079,7 +1128,7 @@ static int vega20_upload_dpm_level(struct smu_context *smu, bool max,
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_FCLK_BIT) &&
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_FCLK_BIT) &&
 	    (feature_mask & FEATURE_DPM_FCLK_MASK)) {
 		single_dpm_table = &(dpm_table->fclk_table);
 		freq = max ? single_dpm_table->dpm_state.soft_max_level :
@@ -1094,7 +1143,7 @@ static int vega20_upload_dpm_level(struct smu_context *smu, bool max,
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_DCEFCLK_BIT) &&
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) &&
 	    (feature_mask & FEATURE_DPM_DCEFCLK_MASK)) {
 		single_dpm_table = &(dpm_table->dcef_table);
 		freq = single_dpm_table->dpm_state.hard_min_level;
@@ -1360,7 +1409,7 @@ static int vega20_set_default_od8_setttings(struct smu_context *smu)
 
 	od8_settings = (struct vega20_od8_settings *)table_context->od8_settings;
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_SOCCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
 		if (table_context->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_GFXCLK_LIMITS] &&
 		    table_context->od_settings_max[OD8_SETTING_GFXCLK_FMAX] > 0 &&
 		    table_context->od_settings_min[OD8_SETTING_GFXCLK_FMIN] > 0 &&
@@ -1433,7 +1482,7 @@ static int vega20_set_default_od8_setttings(struct smu_context *smu)
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
 		if (table_context->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_UCLK_MAX] &&
 		    table_context->od_settings_min[OD8_SETTING_UCLK_FMAX] > 0 &&
 		    table_context->od_settings_max[OD8_SETTING_UCLK_FMAX] > 0 &&
@@ -1457,7 +1506,7 @@ static int vega20_set_default_od8_setttings(struct smu_context *smu)
 			od_table->OverDrivePct;
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_FAN_CONTROL_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_FAN_CONTROL_BIT)) {
 		if (table_context->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_FAN_ACOUSTIC_LIMIT] &&
 		    table_context->od_settings_min[OD8_SETTING_FAN_ACOUSTIC_LIMIT] > 0 &&
 		    table_context->od_settings_max[OD8_SETTING_FAN_ACOUSTIC_LIMIT] > 0 &&
@@ -1481,7 +1530,7 @@ static int vega20_set_default_od8_setttings(struct smu_context *smu)
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_THERMAL_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_THERMAL_BIT)) {
 		if (table_context->od_feature_capabilities[ATOM_VEGA20_ODFEATURE_TEMPERATURE_FAN] &&
 		    table_context->od_settings_min[OD8_SETTING_FAN_TARGET_TEMP] > 0 &&
 		    table_context->od_settings_max[OD8_SETTING_FAN_TARGET_TEMP] > 0 &&
@@ -1838,7 +1887,7 @@ vega20_set_uclk_to_highest_dpm_level(struct smu_context *smu,
 	if (!smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
 		if (dpm_table->count <= 0) {
 			pr_err("[%s] Dpm table has no entry!", __func__);
 				return -EINVAL;
@@ -1901,8 +1950,8 @@ static int vega20_display_config_changed(struct smu_context *smu)
 	}
 
 	if ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&
-	    smu_feature_is_supported(smu, FEATURE_DPM_DCEFCLK_BIT) &&
-	    smu_feature_is_supported(smu, FEATURE_DPM_SOCCLK_BIT)) {
+	    smu_feature_is_supported(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) &&
+	    smu_feature_is_supported(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
 		smu_send_smc_msg_with_param(smu,
 					    SMU_MSG_NumOfDisplays,
 					    smu->display_config->num_display);
@@ -2071,11 +2120,11 @@ vega20_notify_smc_dispaly_config(struct smu_context *smu)
 	min_clocks.dcef_clock_in_sr = smu->display_config->min_dcef_deep_sleep_set_clk;
 	min_clocks.memory_clock = smu->display_config->min_mem_set_clock;
 
-	if (smu_feature_is_supported(smu, FEATURE_DPM_DCEFCLK_BIT)) {
+	if (smu_feature_is_supported(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {
 		clock_req.clock_type = amd_pp_dcef_clock;
 		clock_req.clock_freq_in_khz = min_clocks.dcef_clock * 10;
 		if (!smu->funcs->display_clock_voltage_request(smu, &clock_req)) {
-			if (smu_feature_is_supported(smu, FEATURE_DS_DCEFCLK_BIT)) {
+			if (smu_feature_is_supported(smu, SMU_FEATURE_DS_DCEFCLK_BIT)) {
 				ret = smu_send_smc_msg_with_param(smu,
 								  SMU_MSG_SetMinDeepSleepDcefclk,
 								  min_clocks.dcef_clock_in_sr/100);
@@ -2089,7 +2138,7 @@ vega20_notify_smc_dispaly_config(struct smu_context *smu)
 		}
 	}
 
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT)) {
+	if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
 		memtable->dpm_state.hard_min_level = min_clocks.memory_clock/100;
 		ret = smu_send_smc_msg_with_param(smu,
 						  SMU_MSG_SetHardMinByFreq,
@@ -2382,14 +2431,14 @@ static int vega20_set_od_percentage(struct smu_context *smu,
 	case OD_SCLK:
 		single_dpm_table = &(dpm_table->gfx_table);
 		golden_dpm_table = &(golden_table->gfx_table);
-		feature_enabled = smu_feature_is_enabled(smu, FEATURE_DPM_GFXCLK_BIT);
+		feature_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT);
 		clk_id = PPCLK_GFXCLK;
 		index = OD8_SETTING_GFXCLK_FMAX;
 		break;
 	case OD_MCLK:
 		single_dpm_table = &(dpm_table->mem_table);
 		golden_dpm_table = &(golden_table->mem_table);
-		feature_enabled = smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT);
+		feature_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT);
 		clk_id = PPCLK_UCLK;
 		index = OD8_SETTING_UCLK_FMAX;
 		break;
@@ -2633,7 +2682,7 @@ static int vega20_odn_edit_dpm_table(struct smu_context *smu,
 			table_context->od_gfxclk_update = false;
 			single_dpm_table = &(dpm_table->gfx_table);
 
-			if (smu_feature_is_enabled(smu, FEATURE_DPM_GFXCLK_BIT)) {
+			if (smu_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {
 				ret = vega20_set_single_dpm_table(smu, single_dpm_table,
 								  PPCLK_GFXCLK);
 				if (ret) {
@@ -2664,24 +2713,24 @@ static int vega20_odn_edit_dpm_table(struct smu_context *smu,
 
 static int vega20_dpm_set_uvd_enable(struct smu_context *smu, bool enable)
 {
-	if (!smu_feature_is_supported(smu, FEATURE_DPM_UVD_BIT))
+	if (!smu_feature_is_supported(smu, SMU_FEATURE_DPM_UVD_BIT))
 		return 0;
 
-	if (enable == smu_feature_is_enabled(smu, FEATURE_DPM_UVD_BIT))
+	if (enable == smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UVD_BIT))
 		return 0;
 
-	return smu_feature_set_enabled(smu, FEATURE_DPM_UVD_BIT, enable);
+	return smu_feature_set_enabled(smu, SMU_FEATURE_DPM_UVD_BIT, enable);
 }
 
 static int vega20_dpm_set_vce_enable(struct smu_context *smu, bool enable)
 {
-	if (!smu_feature_is_supported(smu, FEATURE_DPM_VCE_BIT))
+	if (!smu_feature_is_supported(smu, SMU_FEATURE_DPM_VCE_BIT))
 		return 0;
 
-	if (enable == smu_feature_is_enabled(smu, FEATURE_DPM_VCE_BIT))
+	if (enable == smu_feature_is_enabled(smu, SMU_FEATURE_DPM_VCE_BIT))
 		return 0;
 
-	return smu_feature_set_enabled(smu, FEATURE_DPM_VCE_BIT, enable);
+	return smu_feature_set_enabled(smu, SMU_FEATURE_DPM_VCE_BIT, enable);
 }
 
 static int vega20_get_enabled_smc_features(struct smu_context *smu,
@@ -2843,11 +2892,11 @@ static int vega20_read_sensor(struct smu_context *smu,
 
 	switch (sensor) {
 	case AMDGPU_PP_SENSOR_UVD_POWER:
-		*(uint32_t *)data = smu_feature_is_enabled(smu, FEATURE_DPM_UVD_BIT) ? 1 : 0;
+		*(uint32_t *)data = smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UVD_BIT) ? 1 : 0;
 		*size = 4;
 		break;
 	case AMDGPU_PP_SENSOR_VCE_POWER:
-		*(uint32_t *)data = smu_feature_is_enabled(smu, FEATURE_DPM_VCE_BIT) ? 1 : 0;
+		*(uint32_t *)data = smu_feature_is_enabled(smu, SMU_FEATURE_DPM_VCE_BIT) ? 1 : 0;
 		*size = 4;
 		break;
 	default:
@@ -2875,6 +2924,7 @@ static const struct pptable_funcs vega20_ppt_funcs = {
 	.append_powerplay_table = vega20_append_powerplay_table,
 	.get_smu_msg_index = vega20_get_smu_msg_index,
 	.get_smu_clk_index = vega20_get_smu_clk_index,
+	.get_smu_feature_index = vega20_get_smu_feature_index,
 	.run_afll_btc = vega20_run_btc_afll,
 	.get_allowed_feature_mask = vega20_get_allowed_feature_mask,
 	.get_current_power_state = vega20_get_current_power_state,
-- 
2.17.1

