From 427a2867957665d24bd4216e35366c74cc057c82 Mon Sep 17 00:00:00 2001
From: Chaudhary Amit Kumar <chaudharyamit.kumar@amd.com>
Date: Thu, 10 Jan 2019 14:57:12 +0530
Subject: [PATCH 4687/5725] x86/MCE/AMD: mce code changes to fix the crash 
 which is

occuring when doing suspend resume on Dibbler V1000.

Up stream Patches commits from where the code is taken
11cf887728a3d1de77cc12ce247b64ef32608891:  x86/MCE/AMD: Read MCx_MISC block addresses on any CPU
8a331f4a0863bea758561c921b94b4d28f7c4029 : x86/mce/AMD: Carve out SMCA get_block_address() code
fbf96cf904dc154a28338fe68f72902e9af57afc : x86/MCE/AMD: Define a function to get SMCA bank type

This patch fixes the below crash seen when user gives the command
"systemctl suspend" for S3.

 CPU: 0 PID: 1830 Comm: systemd-sleep Not tainted 4.14.14-1-amd-oct3-allpatches+ #3
 Hardware name: AMD Dibbler/Dibbler, BIOS RDB1107CB 09/13/2018
 task: ffff96d541174500 task.stack: ffffb8bd41df0000
 RIP: 0010:smp_call_function_single+0xe2/0xf0
 RSP: 0018:ffffb8bd41df3c40 EFLAGS: 00010046
 RAX: 0000000000000000 RBX: ffffb8bd41df3cd4 RCX: 0000000000000001
 RDX: ffffb8bd41df3c90 RSI: ffffffff98c3c2a0 RDI: 0000000000000000
 RBP: ffffb8bd41df3c70 R08: 0000000000000001 R09: 0000000000010000
 R10: ffffb8bd41df3c90 R11: ffffffff99c6ad20 R12: 0000000000000001
 R13: 0000000000000000 R14: 0000000000000000 R15: ffffb8bd41df3d14
 FS:  00007fc832f29940(0000) GS:ffff96d54a200000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 00005633e8039eb8 CR3: 00000001409ba000 CR4: 00000000003406f0
 Call Trace:
  ? rdmsr_safe_on_cpu+0x4b/0x70
  rdmsr_safe_on_cpu+0x4b/0x70
  get_block_address.isra.2+0x75/0xf0
  mce_amd_feature_init+0x69/0x2b0
  mce_syscore_resume+0x1e/0x30
  syscore_resume+0x47/0x170
  suspend_devices_and_enter+0x6fd/0x760
  pm_suspend+0x30c/0x380
  state_store+0x71/0xd0
  kernfs_fop_write+0x10f/0x190
  __vfs_write+0x26/0x150
  ? common_file_perm+0x44/0x140
  ? security_file_permission+0x3c/0xb0
  vfs_write+0xb3/0x1a0
  SyS_write+0x42/0x90
  do_syscall_64+0x6e/0x120
  entry_SYSCALL_64_after_hwframe+0x3d/0xa2
  RIP: 0033:0x7fc832a4a154
  RSP: 002b:00007ffe0a53c7e8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
  RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007fc832a4a154
  RDX: 0000000000000004 RSI: 00005633e8038eb0 RDI: 0000000000000004
  RBP: 00005633e8038eb0 R08: 00005633e8037370 R09: 00007fc832f29940
  R10: 000000000000000a R11: 0000000000000246 R12: 00005633e8037290
  R13: 0000000000000004 R14: 00007fc832d222a0 R15: 00007fc832d21760
  Code: fe ff ff 8b 55 e8 83 e2 01 74 0a f3 90 8b 55 e8 83 e2 01 75 f6 48 83 c4 28 41 5a 5d 49 8d 62 f8 c3 8b 05 f2 76 9e 01 85 c0 75 85 <0f> 0b eb 81 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 f6 46
							 ---[ end trace 21ebe5b8c411c5d7 ]---

Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
Signed-off-by: Chaudhary Amit Kumar <chaudharyamit.kumar@amd.com>
---
 arch/x86/kernel/cpu/mcheck/mce_amd.c | 17 ++++++++---------
 1 file changed, 8 insertions(+), 9 deletions(-)
 mode change 100644 => 100755 arch/x86/kernel/cpu/mcheck/mce_amd.c

diff --git a/arch/x86/kernel/cpu/mcheck/mce_amd.c b/arch/x86/kernel/cpu/mcheck/mce_amd.c
old mode 100644
new mode 100755
index dbcb010..63250b3
--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c
@@ -434,8 +434,7 @@ static void deferred_error_interrupt_enable(struct cpuinfo_x86 *c)
 	wrmsr(MSR_CU_DEF_ERR, low, high);
 }
 
-static u32 smca_get_block_address(unsigned int cpu, unsigned int bank,
-				  unsigned int block)
+static u32 smca_get_block_address(unsigned int bank, unsigned int block)
 {
 	u32 low, high;
 	u32 addr = 0;
@@ -454,13 +453,13 @@ static u32 smca_get_block_address(unsigned int cpu, unsigned int bank,
 	 * For SMCA enabled processors, BLKPTR field of the first MISC register
 	 * (MCx_MISC0) indicates presence of additional MISC regs set (MISC1-4).
 	 */
-	if (rdmsr_safe_on_cpu(cpu, MSR_AMD64_SMCA_MCx_CONFIG(bank), &low, &high))
+	if (rdmsr_safe(MSR_AMD64_SMCA_MCx_CONFIG(bank), &low, &high))
 		goto out;
 
 	if (!(low & MCI_CONFIG_MCAX))
 		goto out;
 
-	if (!rdmsr_safe_on_cpu(cpu, MSR_AMD64_SMCA_MCx_MISC(bank), &low, &high) &&
+	if (!rdmsr_safe(MSR_AMD64_SMCA_MCx_MISC(bank), &low, &high) &&
 	    (low & MASK_BLKPTR_LO))
 		addr = MSR_AMD64_SMCA_MCx_MISCy(bank, block - 1);
 
@@ -469,8 +468,8 @@ static u32 smca_get_block_address(unsigned int cpu, unsigned int bank,
 	return addr;
 }
 
-static u32 get_block_address(unsigned int cpu, u32 current_addr, u32 low, u32 high,
-			     unsigned int bank, unsigned int block)
+static u32 get_block_address(u32 current_addr, u32 low, u32 high,
+                            unsigned int bank, unsigned int block)
 {
 	u32 addr = 0, offset = 0;
 
@@ -478,7 +477,7 @@ static u32 get_block_address(unsigned int cpu, u32 current_addr, u32 low, u32 hi
 		return addr;
 
 	if (mce_flags.smca)
-		return smca_get_block_address(cpu, bank, block);
+		return smca_get_block_address(bank, block);
 
 	/* Fall back to method we used for older processors: */
 	switch (block) {
@@ -556,7 +555,7 @@ void mce_amd_feature_init(struct cpuinfo_x86 *c)
 			smca_configure(bank, cpu);
 
 		for (block = 0; block < NR_BLOCKS; ++block) {
-			address = get_block_address(cpu, address, low, high, bank, block);
+			address = get_block_address(address, low, high, bank, block);
 			if (!address)
 				break;
 
@@ -1173,7 +1172,7 @@ static int allocate_threshold_blocks(unsigned int cpu, unsigned int bank,
 	if (err)
 		goto out_free;
 recurse:
-	address = get_block_address(cpu, address, low, high, bank, ++block);
+	address = get_block_address(address, low, high, bank, ++block);
 	if (!address)
 		return 0;
 
-- 
2.7.4

