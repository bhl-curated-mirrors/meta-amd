From bcc6a8a8dbad9b1741106266dfbc3e058df4d5af Mon Sep 17 00:00:00 2001
From: Kalyan Alle <kalyan.alle@amd.com>
Date: Mon, 23 Apr 2018 12:45:11 +0530
Subject: [PATCH 1975/4131] fixing the compilation issues v2

This Patch fixes the compilation issues while porting
Till commit :4b6e17791af0d6f531d5e5409ee007d78d9457d4
repo:brahma/ec/linux , branch : amd-18.10

Signed-off-by: kalyan alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c       |   2 +-
 drivers/gpu/drm/amd/powerplay/amd_powerplay.c |  20 +++--
 drivers/gpu/drm/drm_syncobj.c                 | 123 +++++++++++++++++++-------
 include/drm/drm_syncobj.h                     |   6 +-
 include/uapi/drm/amdgpu_drm.h                 |  26 +++++-
 5 files changed, 135 insertions(+), 42 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
index 23101b0..9391db0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
@@ -142,7 +142,7 @@ void amdgpu_gfx_compute_queue_acquire(struct amdgpu_device *adev)
 		if (mec >= adev->gfx.mec.num_mec)
 			break;
 		
-		if (multiple_policy) {
+		if (multipipe_policy) {
 			/* policy: amdgpu owns the first two queues of the first MEC */
 			if (mec == 0 && queue < 2)
 				set_bit(i, adev->gfx.mec.queue_bitmap);
diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 1910524..2010bbd 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1163,7 +1163,9 @@ static int pp_dpm_switch_power_profile(void *handle,
 	return 0;
 }
 
-static int amd_powerplay_display_configuration_change(void *handle,
+/* export this function to DAL */
+
+static int pp_display_configuration_change(void *handle,
 	const struct amd_pp_display_configuration *display_config)
 {
 	struct pp_hwmgr  *hwmgr;
@@ -1182,7 +1184,7 @@ static int amd_powerplay_display_configuration_change(void *handle,
 	return 0;
 }
 
-static int amd_powerplay_get_display_power_level(void *handle,
+static int pp_get_display_power_level(void *handle,
 		struct amd_pp_simple_clock_info *output)
 {
 	struct pp_hwmgr  *hwmgr;
@@ -1205,7 +1207,7 @@ static int amd_powerplay_get_display_power_level(void *handle,
 	return ret;
 }
 
-static int amd_powerplay_get_current_clocks(void *handle,
+static int pp_get_current_clocks(void *handle,
 		struct amd_pp_clock_info *clocks)
 {
 	struct amd_pp_simple_clock_info simple_clocks;
@@ -1259,7 +1261,7 @@ static int amd_powerplay_get_current_clocks(void *handle,
 	return 0;
 }
 
-static int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)
+static int pp_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
@@ -1281,7 +1283,7 @@ static int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type
 	return ret;
 }
 
-static int amd_powerplay_get_clock_by_type_with_latency(void *handle,
+static int pp_get_clock_by_type_with_latency(void *handle,
 		enum amd_pp_clock_type type,
 		struct pp_clock_levels_with_latency *clocks)
 {
@@ -1303,7 +1305,7 @@ static int amd_powerplay_get_clock_by_type_with_latency(void *handle,
 	return ret;
 }
 
-static int amd_powerplay_get_clock_by_type_with_voltage(void *handle,
+static int pp_get_clock_by_type_with_voltage(void *handle,
 		enum amd_pp_clock_type type,
 		struct pp_clock_levels_with_voltage *clocks)
 {
@@ -1328,7 +1330,7 @@ static int amd_powerplay_get_clock_by_type_with_voltage(void *handle,
 	return ret;
 }
 
-static int amd_powerplay_set_watermarks_for_clocks_ranges(void *handle,
+static int pp_set_watermarks_for_clocks_ranges(void *handle,
 		struct pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)
 {
 	struct pp_hwmgr *hwmgr;
@@ -1352,7 +1354,7 @@ static int amd_powerplay_set_watermarks_for_clocks_ranges(void *handle,
 	return ret;
 }
 
-static int amd_powerplay_display_clock_voltage_request(void *handle,
+static int pp_display_clock_voltage_request(void *handle,
 		struct pp_display_clock_request *clock)
 {
 	struct pp_hwmgr *hwmgr;
@@ -1375,7 +1377,7 @@ static int amd_powerplay_display_clock_voltage_request(void *handle,
 	return ret;
 }
 
-static int amd_powerplay_get_display_mode_validation_clocks(void *handle,
+static int pp_get_display_mode_validation_clocks(void *handle,
 		struct amd_pp_simple_clock_info *clocks)
 {
 	struct pp_hwmgr  *hwmgr;
diff --git a/drivers/gpu/drm/drm_syncobj.c b/drivers/gpu/drm/drm_syncobj.c
index 7bcf570..5cd8269 100644
--- a/drivers/gpu/drm/drm_syncobj.c
+++ b/drivers/gpu/drm/drm_syncobj.c
@@ -262,42 +262,83 @@ void drm_syncobj_free(struct kref *kref)
 }
 EXPORT_SYMBOL(drm_syncobj_free);
 
-static int drm_syncobj_create(struct drm_file *file_private,
-			      u32 *handle, uint32_t flags)
+/**
+ * drm_syncobj_create - create a new syncobj
+ * @out_syncobj: returned syncobj
+ * @flags: DRM_SYNCOBJ_* flags
+ * @fence: if non-NULL, the syncobj will represent this fence
+ */
+int drm_syncobj_create(struct drm_syncobj **out_syncobj, uint32_t flags,
+                       struct dma_fence *fence)
 {
-	int ret;
-	struct drm_syncobj *syncobj;
+        int ret;
+        struct drm_syncobj *syncobj;
 
-	syncobj = kzalloc(sizeof(struct drm_syncobj), GFP_KERNEL);
-	if (!syncobj)
-		return -ENOMEM;
+        syncobj = kzalloc(sizeof(struct drm_syncobj), GFP_KERNEL);
+        if (!syncobj)
+                return -ENOMEM;
 
-	kref_init(&syncobj->refcount);
-	INIT_LIST_HEAD(&syncobj->cb_list);
-	spin_lock_init(&syncobj->lock);
+        kref_init(&syncobj->refcount);
+        INIT_LIST_HEAD(&syncobj->cb_list);
+        spin_lock_init(&syncobj->lock);
 
-	if (flags & DRM_SYNCOBJ_CREATE_SIGNALED) {
-		ret = drm_syncobj_assign_null_handle(syncobj);
-		if (ret < 0) {
-			drm_syncobj_put(syncobj);
-			return ret;
-		}
-	}
+        if (flags & DRM_SYNCOBJ_CREATE_SIGNALED) {
+                ret = drm_syncobj_assign_null_handle(syncobj);
+                if (ret < 0) {
+                        drm_syncobj_put(syncobj);
+                        return ret;
+                }
+        }
 
-	idr_preload(GFP_KERNEL);
-	spin_lock(&file_private->syncobj_table_lock);
-	ret = idr_alloc(&file_private->syncobj_idr, syncobj, 1, 0, GFP_NOWAIT);
-	spin_unlock(&file_private->syncobj_table_lock);
+        if (fence)
+                drm_syncobj_replace_fence(syncobj, fence);
 
-	idr_preload_end();
+        *out_syncobj = syncobj;
+        return 0;
+}
+EXPORT_SYMBOL(drm_syncobj_create);
 
-	if (ret < 0) {
-		drm_syncobj_put(syncobj);
-		return ret;
-	}
+/**
+ * drm_syncobj_get_handle - get a handle from a syncobj
+ */
+int drm_syncobj_get_handle(struct drm_file *file_private,
+                           struct drm_syncobj *syncobj, u32 *handle)
+{
+        int ret;
 
-	*handle = ret;
-	return 0;
+        /* take a reference to put in the idr */
+        drm_syncobj_get(syncobj);
+
+        idr_preload(GFP_KERNEL);
+        spin_lock(&file_private->syncobj_table_lock);
+        ret = idr_alloc(&file_private->syncobj_idr, syncobj, 1, 0, GFP_NOWAIT);
+        spin_unlock(&file_private->syncobj_table_lock);
+
+        idr_preload_end();
+
+        if (ret < 0) {
+                drm_syncobj_put(syncobj);
+                return ret;
+        }
+
+        *handle = ret;
+        return 0;
+}
+EXPORT_SYMBOL(drm_syncobj_get_handle);
+
+static int drm_syncobj_create_as_handle(struct drm_file *file_private,
+                                        u32 *handle, uint32_t flags)
+{
+        int ret;
+        struct drm_syncobj *syncobj;
+
+        ret = drm_syncobj_create(&syncobj, flags, NULL);
+        if (ret)
+                return ret;
+
+        ret = drm_syncobj_get_handle(file_private, syncobj, handle);
+        drm_syncobj_put(syncobj);
+        return ret;
 }
 
 static int drm_syncobj_destroy(struct drm_file *file_private,
@@ -328,6 +369,28 @@ static const struct file_operations drm_syncobj_file_fops = {
 	.release = drm_syncobj_file_release,
 };
 
+int drm_syncobj_get_fd(struct drm_syncobj *syncobj, int *p_fd)
+{
+        int ret;
+        int fd;
+
+        fd = get_unused_fd_flags(O_CLOEXEC);
+        if (fd < 0)
+                return fd;
+
+        if (!syncobj->file) {
+                ret = drm_syncobj_alloc_file(syncobj);
+                if (ret) {
+                        put_unused_fd(fd);
+                        return ret;
+                }
+        }
+        fd_install(fd, syncobj->file);
+        *p_fd = fd;
+        return 0;
+}
+EXPORT_SYMBOL(drm_syncobj_get_fd);
+
 static int drm_syncobj_handle_to_fd(struct drm_file *file_private,
 				    u32 handle, int *p_fd)
 {
@@ -501,8 +564,8 @@ drm_syncobj_create_ioctl(struct drm_device *dev, void *data,
 	if (args->flags & ~DRM_SYNCOBJ_CREATE_SIGNALED)
 		return -EINVAL;
 
-	return drm_syncobj_create(file_private,
-				  &args->handle, args->flags);
+	return drm_syncobj_create_as_handle(file_private,
+						&args->handle, args->flags);
 }
 
 int
diff --git a/include/drm/drm_syncobj.h b/include/drm/drm_syncobj.h
index 6d45aae..30c452f 100644
--- a/include/drm/drm_syncobj.h
+++ b/include/drm/drm_syncobj.h
@@ -131,5 +131,9 @@ int drm_syncobj_find_fence(struct drm_file *file_private,
 			   u32 handle,
 			   struct dma_fence **fence);
 void drm_syncobj_free(struct kref *kref);
-
+int drm_syncobj_create(struct drm_syncobj **out_syncobj, uint32_t flags,
+                       struct dma_fence *fence);
+int drm_syncobj_get_handle(struct drm_file *file_private,
+                           struct drm_syncobj *syncobj, u32 *handle);
+int drm_syncobj_get_fd(struct drm_syncobj *syncobj, int *p_fd);
 #endif
diff --git a/include/uapi/drm/amdgpu_drm.h b/include/uapi/drm/amdgpu_drm.h
index 69f72d1..a03a782 100644
--- a/include/uapi/drm/amdgpu_drm.h
+++ b/include/uapi/drm/amdgpu_drm.h
@@ -52,6 +52,7 @@ extern "C" {
 #define DRM_AMDGPU_GEM_USERPTR		0x11
 #define DRM_AMDGPU_WAIT_FENCES		0x12
 #define DRM_AMDGPU_VM			0x13
+#define DRM_AMDGPU_FENCE_TO_HANDLE      0x14
 
 /* hybrid specific ioctls */
 #define DRM_AMDGPU_FREESYNC             0x5d
@@ -73,6 +74,7 @@ extern "C" {
 #define DRM_IOCTL_AMDGPU_GEM_USERPTR	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_USERPTR, struct drm_amdgpu_gem_userptr)
 #define DRM_IOCTL_AMDGPU_WAIT_FENCES	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_WAIT_FENCES, union drm_amdgpu_wait_fences)
 #define DRM_IOCTL_AMDGPU_VM		DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_VM, union drm_amdgpu_vm)
+#define DRM_IOCTL_AMDGPU_FENCE_TO_HANDLE DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_FENCE_TO_HANDLE, union drm_amdgpu_fence_to_handle)
 
 /* hybrid specific ioctls */
 #define DRM_IOCTL_AMDGPU_FREESYNC       DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_FREESYNC, struct drm_amdgpu_freesync)
@@ -184,13 +186,21 @@ union drm_amdgpu_bo_list {
 /* unknown cause */
 #define AMDGPU_CTX_UNKNOWN_RESET	3
 
+/* Context priority level */
+#define AMDGPU_CTX_PRIORITY_LOW_HW      -1023
+#define AMDGPU_CTX_PRIORITY_LOW_SW      -512
+#define AMDGPU_CTX_PRIORITY_NORMAL      0
+/* Selecting a priority above NORMAL requires CAP_SYS_NICE or DRM_MASTER */
+#define AMDGPU_CTX_PRIORITY_HIGH_SW     512
+#define AMDGPU_CTX_PRIORITY_HIGH_HW     1023
+
 struct drm_amdgpu_ctx_in {
 	/** AMDGPU_CTX_OP_* */
 	__u32	op;
 	/** For future use, no flags defined so far */
 	__u32	flags;
 	__u32	ctx_id;
-	__u32	_pad;
+	__s32   priority;
 };
 
 union drm_amdgpu_ctx_out {
@@ -582,6 +592,20 @@ struct drm_amdgpu_cs_chunk_sem {
 	__u32 handle;
 };
 
+#define AMDGPU_FENCE_TO_HANDLE_GET_SYNCOBJ      0
+#define AMDGPU_FENCE_TO_HANDLE_GET_SYNCOBJ_FD   1
+#define AMDGPU_FENCE_TO_HANDLE_GET_SYNC_FILE_FD 2
+
+union drm_amdgpu_fence_to_handle {
+        struct {
+                struct drm_amdgpu_fence fence;
+                __u32 what;
+        } in;
+        struct {
+                __u32 handle;
+        } out;
+};
+
 struct drm_amdgpu_cs_chunk_data {
 	union {
 		struct drm_amdgpu_cs_chunk_ib		ib_data;
-- 
2.7.4

