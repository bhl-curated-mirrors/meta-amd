From 9cb48e7e6a6e0a07cacbedb52afb46e370da3948 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Thu, 27 Jul 2017 09:55:38 -0400
Subject: [PATCH 0711/4131] drm/amd/display: Rename more dc_surface stuff to
 plane_state

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c  | 288 +++++++++++----------
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h  |   2 +-
 drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c   |  20 +-
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c   |  52 ++--
 drivers/gpu/drm/amd/display/dc/core/dc.c           | 130 +++++-----
 drivers/gpu/drm/amd/display/dc/core/dc_debug.c     | 188 +++++++-------
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  | 190 +++++++-------
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    |   8 +-
 drivers/gpu/drm/amd/display/dc/core/dc_surface.c   |  74 +++---
 drivers/gpu/drm/amd/display/dc/dc.h                |  32 +--
 drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c     |   4 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h     |   2 +-
 .../drm/amd/display/dc/dce100/dce100_resource.c    |   8 +-
 .../amd/display/dc/dce110/dce110_hw_sequencer.c    | 125 +++++----
 .../drm/amd/display/dc/dce110/dce110_resource.c    |  20 +-
 .../drm/amd/display/dc/dce112/dce112_resource.c    |   8 +-
 .../drm/amd/display/dc/dce120/dce120_resource.c    |   2 +-
 .../gpu/drm/amd/display/dc/dce80/dce80_resource.c  |   8 +-
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  | 140 +++++-----
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.c  |   2 +-
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |   4 +-
 drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h  |   4 +-
 drivers/gpu/drm/amd/display/dc/inc/resource.h      |   2 +-
 .../gpu/drm/amd/display/include/logger_interface.h |   2 +-
 24 files changed, 658 insertions(+), 657 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 7f70fe9..0d42bd0 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -70,7 +70,7 @@
 #include "i2caux_interface.h"
 
 
-static enum drm_plane_type dm_surfaces_type_default[AMDGPU_MAX_PLANES] = {
+static enum drm_plane_type dm_plane_type_default[AMDGPU_MAX_PLANES] = {
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
@@ -79,14 +79,14 @@ static enum drm_plane_type dm_surfaces_type_default[AMDGPU_MAX_PLANES] = {
 	DRM_PLANE_TYPE_PRIMARY,
 };
 
-static enum drm_plane_type dm_surfaces_type_carizzo[AMDGPU_MAX_PLANES] = {
+static enum drm_plane_type dm_plane_type_carizzo[AMDGPU_MAX_PLANES] = {
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_OVERLAY,/* YUV Capable Underlay */
 };
 
-static enum drm_plane_type dm_surfaces_type_stoney[AMDGPU_MAX_PLANES] = {
+static enum drm_plane_type dm_plane_type_stoney[AMDGPU_MAX_PLANES] = {
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_OVERLAY, /* YUV Capable Underlay */
@@ -1285,11 +1285,11 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 		return -1;
 	}
 
-	for (i = 0; i < dm->dc->caps.max_surfaces; i++) {
+	for (i = 0; i < dm->dc->caps.max_planes; i++) {
 		mode_info->planes[i] = kzalloc(sizeof(struct amdgpu_plane),
 								 GFP_KERNEL);
 		if (!mode_info->planes[i]) {
-			DRM_ERROR("KMS: Failed to allocate surface\n");
+			DRM_ERROR("KMS: Failed to allocate plane\n");
 			goto fail_free_planes;
 		}
 		mode_info->planes[i]->base.type = mode_info->plane_type[i];
@@ -1389,7 +1389,7 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 fail_free_connector:
 	kfree(aconnector);
 fail_free_planes:
-	for (i = 0; i < dm->dc->caps.max_surfaces; i++)
+	for (i = 0; i < dm->dc->caps.max_planes; i++)
 		kfree(mode_info->planes[i]);
 	return -1;
 }
@@ -1523,52 +1523,52 @@ static int dm_early_init(void *handle)
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 	case CHIP_FIJI:
 	case CHIP_TONGA:
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 7;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 	case CHIP_CARRIZO:
 		adev->mode_info.num_crtc = 3;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 9;
-		adev->mode_info.plane_type = dm_surfaces_type_carizzo;
+		adev->mode_info.plane_type = dm_plane_type_carizzo;
 		break;
 	case CHIP_STONEY:
 		adev->mode_info.num_crtc = 2;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 9;
-		adev->mode_info.plane_type = dm_surfaces_type_stoney;
+		adev->mode_info.plane_type = dm_plane_type_stoney;
 		break;
 	case CHIP_POLARIS11:
 	case CHIP_POLARIS12:
 		adev->mode_info.num_crtc = 5;
 		adev->mode_info.num_hpd = 5;
 		adev->mode_info.num_dig = 5;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 	case CHIP_POLARIS10:
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 	case CHIP_VEGA10:
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case CHIP_RAVEN:
 		adev->mode_info.num_crtc = 4;
 		adev->mode_info.num_hpd = 4;
 		adev->mode_info.num_dig = 4;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 #endif
 	default:
@@ -1826,50 +1826,50 @@ static int dm_crtc_cursor_move(struct drm_crtc *crtc,
 
 static bool fill_rects_from_plane_state(
 	const struct drm_plane_state *state,
-	struct dc_plane_state *surface)
+	struct dc_plane_state *plane_state)
 {
-	surface->src_rect.x = state->src_x >> 16;
-	surface->src_rect.y = state->src_y >> 16;
+	plane_state->src_rect.x = state->src_x >> 16;
+	plane_state->src_rect.y = state->src_y >> 16;
 	/*we ignore for now mantissa and do not to deal with floating pixels :(*/
-	surface->src_rect.width = state->src_w >> 16;
+	plane_state->src_rect.width = state->src_w >> 16;
 
-	if (surface->src_rect.width == 0)
+	if (plane_state->src_rect.width == 0)
 		return false;
 
-	surface->src_rect.height = state->src_h >> 16;
-	if (surface->src_rect.height == 0)
+	plane_state->src_rect.height = state->src_h >> 16;
+	if (plane_state->src_rect.height == 0)
 		return false;
 
-	surface->dst_rect.x = state->crtc_x;
-	surface->dst_rect.y = state->crtc_y;
+	plane_state->dst_rect.x = state->crtc_x;
+	plane_state->dst_rect.y = state->crtc_y;
 
 	if (state->crtc_w == 0)
 		return false;
 
-	surface->dst_rect.width = state->crtc_w;
+	plane_state->dst_rect.width = state->crtc_w;
 
 	if (state->crtc_h == 0)
 		return false;
 
-	surface->dst_rect.height = state->crtc_h;
+	plane_state->dst_rect.height = state->crtc_h;
 
-	surface->clip_rect = surface->dst_rect;
+	plane_state->clip_rect = plane_state->dst_rect;
 
 	switch (state->rotation) {
 	case BIT(DRM_ROTATE_0):
-		surface->rotation = ROTATION_ANGLE_0;
+		plane_state->rotation = ROTATION_ANGLE_0;
 		break;
 	case BIT(DRM_ROTATE_90):
-		surface->rotation = ROTATION_ANGLE_90;
+		plane_state->rotation = ROTATION_ANGLE_90;
 		break;
 	case BIT(DRM_ROTATE_180):
-		surface->rotation = ROTATION_ANGLE_180;
+		plane_state->rotation = ROTATION_ANGLE_180;
 		break;
 	case BIT(DRM_ROTATE_270):
-		surface->rotation = ROTATION_ANGLE_270;
+		plane_state->rotation = ROTATION_ANGLE_270;
 		break;
 	default:
-		surface->rotation = ROTATION_ANGLE_0;
+		plane_state->rotation = ROTATION_ANGLE_0;
 		break;
 	}
 
@@ -1901,7 +1901,7 @@ static int get_fb_info(
 
 static int fill_plane_attributes_from_fb(
 	struct amdgpu_device *adev,
-	struct dc_plane_state *surface,
+	struct dc_plane_state *plane_state,
 	const struct amdgpu_framebuffer *amdgpu_fb, bool addReq)
 {
 	uint64_t tiling_flags;
@@ -1921,28 +1921,28 @@ static int fill_plane_attributes_from_fb(
 
 	switch (fb->format->format) {
 	case DRM_FORMAT_C8:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS;
 		break;
 	case DRM_FORMAT_RGB565:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_RGB565;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_RGB565;
 		break;
 	case DRM_FORMAT_XRGB8888:
 	case DRM_FORMAT_ARGB8888:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB8888;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB8888;
 		break;
 	case DRM_FORMAT_XRGB2101010:
 	case DRM_FORMAT_ARGB2101010:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010;
 		break;
 	case DRM_FORMAT_XBGR2101010:
 	case DRM_FORMAT_ABGR2101010:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010;
 		break;
 	case DRM_FORMAT_NV21:
-		surface->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr;
+		plane_state->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr;
 		break;
 	case DRM_FORMAT_NV12:
-		surface->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb;
+		plane_state->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb;
 		break;
 	default:
 		DRM_ERROR("Unsupported screen format %s\n",
@@ -1950,45 +1950,45 @@ static int fill_plane_attributes_from_fb(
 		return -EINVAL;
 	}
 
-	if (surface->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
-		surface->address.type = PLN_ADDR_TYPE_GRAPHICS;
-		surface->address.grph.addr.low_part = lower_32_bits(fb_location);
-		surface->address.grph.addr.high_part = upper_32_bits(fb_location);
-		surface->plane_size.grph.surface_size.x = 0;
-		surface->plane_size.grph.surface_size.y = 0;
-		surface->plane_size.grph.surface_size.width = fb->width;
-		surface->plane_size.grph.surface_size.height = fb->height;
-		surface->plane_size.grph.surface_pitch =
+	if (plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
+		plane_state->address.type = PLN_ADDR_TYPE_GRAPHICS;
+		plane_state->address.grph.addr.low_part = lower_32_bits(fb_location);
+		plane_state->address.grph.addr.high_part = upper_32_bits(fb_location);
+		plane_state->plane_size.grph.surface_size.x = 0;
+		plane_state->plane_size.grph.surface_size.y = 0;
+		plane_state->plane_size.grph.surface_size.width = fb->width;
+		plane_state->plane_size.grph.surface_size.height = fb->height;
+		plane_state->plane_size.grph.surface_pitch =
 				fb->pitches[0] / fb->format->cpp[0];
 		/* TODO: unhardcode */
-		surface->color_space = COLOR_SPACE_SRGB;
+		plane_state->color_space = COLOR_SPACE_SRGB;
 
 	} else {
 		awidth = ALIGN(fb->width, 64);
-		surface->address.type = PLN_ADDR_TYPE_VIDEO_PROGRESSIVE;
-		surface->address.video_progressive.luma_addr.low_part
+		plane_state->address.type = PLN_ADDR_TYPE_VIDEO_PROGRESSIVE;
+		plane_state->address.video_progressive.luma_addr.low_part
 						= lower_32_bits(fb_location);
-		surface->address.video_progressive.chroma_addr.low_part
+		plane_state->address.video_progressive.chroma_addr.low_part
 						= lower_32_bits(fb_location) +
 							(awidth * fb->height);
-		surface->plane_size.video.luma_size.x = 0;
-		surface->plane_size.video.luma_size.y = 0;
-		surface->plane_size.video.luma_size.width = awidth;
-		surface->plane_size.video.luma_size.height = fb->height;
+		plane_state->plane_size.video.luma_size.x = 0;
+		plane_state->plane_size.video.luma_size.y = 0;
+		plane_state->plane_size.video.luma_size.width = awidth;
+		plane_state->plane_size.video.luma_size.height = fb->height;
 		/* TODO: unhardcode */
-		surface->plane_size.video.luma_pitch = awidth;
+		plane_state->plane_size.video.luma_pitch = awidth;
 
-		surface->plane_size.video.chroma_size.x = 0;
-		surface->plane_size.video.chroma_size.y = 0;
-		surface->plane_size.video.chroma_size.width = awidth;
-		surface->plane_size.video.chroma_size.height = fb->height;
-		surface->plane_size.video.chroma_pitch = awidth / 2;
+		plane_state->plane_size.video.chroma_size.x = 0;
+		plane_state->plane_size.video.chroma_size.y = 0;
+		plane_state->plane_size.video.chroma_size.width = awidth;
+		plane_state->plane_size.video.chroma_size.height = fb->height;
+		plane_state->plane_size.video.chroma_pitch = awidth / 2;
 
 		/* TODO: unhardcode */
-		surface->color_space = COLOR_SPACE_YCBCR709;
+		plane_state->color_space = COLOR_SPACE_YCBCR709;
 	}
 
-	memset(&surface->tiling_info, 0, sizeof(surface->tiling_info));
+	memset(&plane_state->tiling_info, 0, sizeof(plane_state->tiling_info));
 
 	/* Fill GFX8 params */
 	if (AMDGPU_TILING_GET(tiling_flags, ARRAY_MODE) == DC_ARRAY_2D_TILED_THIN1) {
@@ -2001,51 +2001,51 @@ static int fill_plane_attributes_from_fb(
 		num_banks = AMDGPU_TILING_GET(tiling_flags, NUM_BANKS);
 
 		/* XXX fix me for VI */
-		surface->tiling_info.gfx8.num_banks = num_banks;
-		surface->tiling_info.gfx8.array_mode =
+		plane_state->tiling_info.gfx8.num_banks = num_banks;
+		plane_state->tiling_info.gfx8.array_mode =
 				DC_ARRAY_2D_TILED_THIN1;
-		surface->tiling_info.gfx8.tile_split = tile_split;
-		surface->tiling_info.gfx8.bank_width = bankw;
-		surface->tiling_info.gfx8.bank_height = bankh;
-		surface->tiling_info.gfx8.tile_aspect = mtaspect;
-		surface->tiling_info.gfx8.tile_mode =
+		plane_state->tiling_info.gfx8.tile_split = tile_split;
+		plane_state->tiling_info.gfx8.bank_width = bankw;
+		plane_state->tiling_info.gfx8.bank_height = bankh;
+		plane_state->tiling_info.gfx8.tile_aspect = mtaspect;
+		plane_state->tiling_info.gfx8.tile_mode =
 				DC_ADDR_SURF_MICRO_TILING_DISPLAY;
 	} else if (AMDGPU_TILING_GET(tiling_flags, ARRAY_MODE)
 			== DC_ARRAY_1D_TILED_THIN1) {
-		surface->tiling_info.gfx8.array_mode = DC_ARRAY_1D_TILED_THIN1;
+		plane_state->tiling_info.gfx8.array_mode = DC_ARRAY_1D_TILED_THIN1;
 	}
 
-	surface->tiling_info.gfx8.pipe_config =
+	plane_state->tiling_info.gfx8.pipe_config =
 			AMDGPU_TILING_GET(tiling_flags, PIPE_CONFIG);
 
 	if (adev->asic_type == CHIP_VEGA10 ||
 	    adev->asic_type == CHIP_RAVEN) {
 		/* Fill GFX9 params */
-		surface->tiling_info.gfx9.num_pipes =
+		plane_state->tiling_info.gfx9.num_pipes =
 			adev->gfx.config.gb_addr_config_fields.num_pipes;
-		surface->tiling_info.gfx9.num_banks =
+		plane_state->tiling_info.gfx9.num_banks =
 			adev->gfx.config.gb_addr_config_fields.num_banks;
-		surface->tiling_info.gfx9.pipe_interleave =
+		plane_state->tiling_info.gfx9.pipe_interleave =
 			adev->gfx.config.gb_addr_config_fields.pipe_interleave_size;
-		surface->tiling_info.gfx9.num_shader_engines =
+		plane_state->tiling_info.gfx9.num_shader_engines =
 			adev->gfx.config.gb_addr_config_fields.num_se;
-		surface->tiling_info.gfx9.max_compressed_frags =
+		plane_state->tiling_info.gfx9.max_compressed_frags =
 			adev->gfx.config.gb_addr_config_fields.max_compress_frags;
-		surface->tiling_info.gfx9.num_rb_per_se =
+		plane_state->tiling_info.gfx9.num_rb_per_se =
 			adev->gfx.config.gb_addr_config_fields.num_rb_per_se;
-		surface->tiling_info.gfx9.swizzle =
+		plane_state->tiling_info.gfx9.swizzle =
 			AMDGPU_TILING_GET(tiling_flags, SWIZZLE_MODE);
-		surface->tiling_info.gfx9.shaderEnable = 1;
+		plane_state->tiling_info.gfx9.shaderEnable = 1;
 	}
 
-	surface->visible = true;
-	surface->scaling_quality.h_taps_c = 0;
-	surface->scaling_quality.v_taps_c = 0;
+	plane_state->visible = true;
+	plane_state->scaling_quality.h_taps_c = 0;
+	plane_state->scaling_quality.v_taps_c = 0;
 
-	/* is this needed? is surface zeroed at allocation? */
-	surface->scaling_quality.h_taps = 0;
-	surface->scaling_quality.v_taps = 0;
-	surface->stereo_format = PLANE_STEREO_FORMAT_NONE;
+	/* is this needed? is plane_state zeroed at allocation? */
+	plane_state->scaling_quality.h_taps = 0;
+	plane_state->scaling_quality.v_taps = 0;
+	plane_state->stereo_format = PLANE_STEREO_FORMAT_NONE;
 
 	return ret;
 
@@ -2055,7 +2055,7 @@ static int fill_plane_attributes_from_fb(
 
 static void fill_gamma_from_crtc_state(
 	const struct drm_crtc_state *crtc_state,
-	struct dc_plane_state *dc_surface)
+	struct dc_plane_state *plane_state)
 {
 	int i;
 	struct dc_gamma *gamma;
@@ -2074,12 +2074,12 @@ static void fill_gamma_from_crtc_state(
 		gamma->blue[i] = lut[i].blue;
 	}
 
-	dc_surface->gamma_correction = gamma;
+	plane_state->gamma_correction = gamma;
 }
 
 static int fill_plane_attributes(
 			struct amdgpu_device *adev,
-			struct dc_plane_state *surface,
+			struct dc_plane_state *dc_plane_state,
 			struct drm_plane_state *plane_state,
 			struct drm_crtc_state *crtc_state,
 			bool addrReq)
@@ -2090,12 +2090,12 @@ static int fill_plane_attributes(
 	struct dc_transfer_func *input_tf;
 	int ret = 0;
 
-	if (!fill_rects_from_plane_state(plane_state, surface))
+	if (!fill_rects_from_plane_state(plane_state, dc_plane_state))
 		return -EINVAL;
 
 	ret = fill_plane_attributes_from_fb(
 		crtc->dev->dev_private,
-		surface,
+		dc_plane_state,
 		amdgpu_fb,
 		addrReq);
 
@@ -2110,11 +2110,11 @@ static int fill_plane_attributes(
 	input_tf->type = TF_TYPE_PREDEFINED;
 	input_tf->tf = TRANSFER_FUNCTION_SRGB;
 
-	surface->in_transfer_func = input_tf;
+	dc_plane_state->in_transfer_func = input_tf;
 
 	/* In case of gamma set, update gamma value */
 	if (crtc_state->gamma_lut)
-		fill_gamma_from_crtc_state(crtc_state, surface);
+		fill_gamma_from_crtc_state(crtc_state, dc_plane_state);
 
 	return ret;
 }
@@ -3140,9 +3140,9 @@ dm_drm_plane_duplicate_state(struct drm_plane *plane)
 
 	__drm_atomic_helper_plane_duplicate_state(plane, &dm_plane_state->base);
 
-	if (old_dm_plane_state->surface) {
-		dm_plane_state->surface = old_dm_plane_state->surface;
-		dc_surface_retain(dm_plane_state->surface);
+	if (old_dm_plane_state->dc_state) {
+		dm_plane_state->dc_state = old_dm_plane_state->dc_state;
+		dc_plane_state_retain(dm_plane_state->dc_state);
 	}
 
 	return &dm_plane_state->base;
@@ -3153,8 +3153,8 @@ void dm_drm_plane_destroy_state(struct drm_plane *plane,
 {
 	struct dm_plane_state *dm_plane_state = to_dm_plane_state(state);
 
-	if (dm_plane_state->surface)
-		dc_surface_release(dm_plane_state->surface);
+	if (dm_plane_state->dc_state)
+		dc_plane_state_release(dm_plane_state->dc_state);
 
 	__drm_atomic_helper_plane_destroy_state(state);
 	kfree(dm_plane_state);
@@ -3209,18 +3209,18 @@ static int dm_plane_helper_prepare_fb(
 
 	amdgpu_bo_ref(rbo);
 
-	if (dm_plane_state_new->surface &&
-			dm_plane_state_old->surface != dm_plane_state_new->surface) {
-		struct dc_plane_state *surface = dm_plane_state_new->surface;
+	if (dm_plane_state_new->dc_state &&
+			dm_plane_state_old->dc_state != dm_plane_state_new->dc_state) {
+		struct dc_plane_state *plane_state = dm_plane_state_new->dc_state;
 
-		if (surface->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
-			surface->address.grph.addr.low_part = lower_32_bits(afb->address);
-			surface->address.grph.addr.high_part = upper_32_bits(afb->address);
+		if (plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
+			plane_state->address.grph.addr.low_part = lower_32_bits(afb->address);
+			plane_state->address.grph.addr.high_part = upper_32_bits(afb->address);
 		} else {
 			awidth = ALIGN(new_state->fb->width, 64);
-			surface->address.video_progressive.luma_addr.low_part
+			plane_state->address.video_progressive.luma_addr.low_part
 							= lower_32_bits(afb->address);
-			surface->address.video_progressive.chroma_addr.low_part
+			plane_state->address.video_progressive.chroma_addr.low_part
 							= lower_32_bits(afb->address) +
 								(awidth * new_state->fb->height);
 		}
@@ -3309,10 +3309,10 @@ int dm_plane_atomic_check(struct drm_plane *plane,
 	struct dc *dc = adev->dm.dc;
 	struct dm_plane_state *dm_plane_state = to_dm_plane_state(state);
 
-	if (!dm_plane_state->surface)
+	if (!dm_plane_state->dc_state)
 		return true;
 
-	if (dc_validate_plane(dc, dm_plane_state->surface))
+	if (dc_validate_plane(dc, dm_plane_state->dc_state))
 		return 0;
 
 	return -EINVAL;
@@ -4006,6 +4006,7 @@ static void amdgpu_dm_do_flip(
 	struct amdgpu_device *adev = crtc->dev->dev_private;
 	bool async_flip = (acrtc->flip_flags & DRM_MODE_PAGE_FLIP_ASYNC) != 0;
 	struct dc_flip_addrs addr = { {0} };
+	/* TODO eliminate or rename surface_update */
 	struct dc_surface_update surface_updates[1] = { {0} };
 	struct dm_crtc_state *acrtc_state = to_dm_crtc_state(crtc->state);
 
@@ -4061,11 +4062,11 @@ static void amdgpu_dm_do_flip(
 	if (acrtc->base.state->event)
 		prepare_flip_isr(acrtc);
 
-	surface_updates->surface = dc_stream_get_status(acrtc_state->stream)->surfaces[0];
+	surface_updates->surface = dc_stream_get_status(acrtc_state->stream)->plane_states[0];
 	surface_updates->flip_addr = &addr;
 
 
-	dc_update_surfaces_and_stream(adev->dm.dc, surface_updates, 1, acrtc_state->stream, NULL);
+	dc_update_planes_and_stream(adev->dm.dc, surface_updates, 1, acrtc_state->stream, NULL);
 
 	DRM_DEBUG_DRIVER("%s Flipping to hi: 0x%x, low: 0x%x \n",
 			 __func__,
@@ -4076,7 +4077,7 @@ static void amdgpu_dm_do_flip(
 	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 }
 
-static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
+static void amdgpu_dm_commit_planes(struct drm_atomic_state *state,
 			struct drm_device *dev,
 			struct amdgpu_display_manager *dm,
 			struct drm_crtc *pcrtc,
@@ -4086,7 +4087,7 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 	struct drm_plane *plane;
 	struct drm_plane_state *old_plane_state;
 	struct dc_stream_state *dc_stream_attach;
-	struct dc_plane_state *dc_surfaces_constructed[MAX_SURFACES];
+	struct dc_plane_state *plane_states_constructed[MAX_SURFACES];
 	struct amdgpu_crtc *acrtc_attach = to_amdgpu_crtc(pcrtc);
 	struct dm_crtc_state *acrtc_state = to_dm_crtc_state(pcrtc->state);
 	int planes_count = 0;
@@ -4114,8 +4115,9 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 
 		spin_lock_irqsave(&crtc->dev->event_lock, flags);
 		if (acrtc_attach->pflip_status != AMDGPU_FLIP_NONE) {
-			DRM_ERROR("add_surface: acrtc %d, already busy\n",
-					acrtc_attach->crtc_id);
+			DRM_ERROR("%s: acrtc %d, already busy\n",
+				  __func__,
+				  acrtc_attach->crtc_id);
 			spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 			/* In commit tail framework this cannot happen */
 			WARN_ON(1);
@@ -4123,9 +4125,9 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 
 		if (!pflip_needed) {
-			WARN_ON(!dm_plane_state->surface);
+			WARN_ON(!dm_plane_state->dc_state);
 
-			dc_surfaces_constructed[planes_count] = dm_plane_state->surface;
+			plane_states_constructed[planes_count] = dm_plane_state->dc_state;
 
 			dc_stream_attach = acrtc_state->stream;
 			planes_count++;
@@ -4168,11 +4170,11 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 			spin_unlock_irqrestore(&pcrtc->dev->event_lock, flags);
 		}
 
-		if (false == dc_commit_surfaces_to_stream(dm->dc,
-							  dc_surfaces_constructed,
-							  planes_count,
-							  dc_stream_attach))
-			dm_error("%s: Failed to attach surface!\n", __func__);
+		if (false == dc_commit_planes_to_stream(dm->dc,
+							plane_states_constructed,
+							planes_count,
+							dc_stream_attach))
+			dm_error("%s: Failed to attach plane!\n", __func__);
 	} else {
 		/*TODO BUG Here should go disable planes on CRTC. */
 	}
@@ -4384,16 +4386,16 @@ void amdgpu_dm_atomic_commit_tail(
 
 		status = dc_stream_get_status(new_acrtc_state->stream);
 		WARN_ON(!status);
-		WARN_ON(!status->surface_count);
+		WARN_ON(!status->plane_count);
 
 		if (!new_acrtc_state->stream)
 			continue;
 
 		/*TODO How it works with MPO ?*/
-		if (!dc_commit_surfaces_to_stream(
+		if (!dc_commit_planes_to_stream(
 				dm->dc,
-				status->surfaces,
-				status->surface_count,
+				status->plane_states,
+				status->plane_count,
 				new_acrtc_state->stream))
 			dm_error("%s: Failed to update stream scaling!\n", __func__);
 	}
@@ -4418,7 +4420,7 @@ void amdgpu_dm_atomic_commit_tail(
 		new_acrtc_state = to_dm_crtc_state(pcrtc->state);
 
 		if (new_acrtc_state->stream)
-			amdgpu_dm_commit_surfaces(state, dev, dm, pcrtc, &wait_for_vblank);
+			amdgpu_dm_commit_planes(state, dev, dm, pcrtc, &wait_for_vblank);
 	}
 
 
@@ -4533,27 +4535,27 @@ void dm_restore_drm_connector_state(struct drm_device *dev, struct drm_connector
 		dm_force_atomic_commit(&aconnector->base);
 }
 
-static uint32_t add_val_sets_surface(
+static uint32_t add_val_sets_plane(
 	struct dc_validation_set *val_sets,
 	uint32_t set_count,
 	const struct dc_stream_state *stream,
-	struct dc_plane_state *surface)
+	struct dc_plane_state *plane_state)
 {
 	uint32_t i = 0, j = 0;
 
 	while (i < set_count) {
 		if (val_sets[i].stream == stream) {
-			while (val_sets[i].surfaces[j])
+			while (val_sets[i].plane_states[j])
 				j++;
 			break;
 		}
 		++i;
 	}
 
-	val_sets[i].surfaces[j] = surface;
-	val_sets[i].surface_count++;
+	val_sets[i].plane_states[j] = plane_state;
+	val_sets[i].plane_count++;
 
-	return val_sets[i].surface_count;
+	return val_sets[i].plane_count;
 }
 
 static uint32_t update_in_val_sets_stream(
@@ -4674,7 +4676,7 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 
 	/*
 	 * This bool will be set for true for any modeset/reset
-	 * or surface update which implies non fast surface update.
+	 * or plane update which implies non fast surface update.
 	 */
 	bool lock_and_validation_needed = false;
 
@@ -4859,13 +4861,13 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 
 			pflip_needed = !state->allow_modeset;
 			if (!pflip_needed) {
-				struct dc_plane_state *surface;
+				struct dc_plane_state *dc_plane_state;
 
-				surface = dc_create_surface(dc);
+				dc_plane_state = dc_create_plane_state(dc);
 
 				ret = fill_plane_attributes(
 					plane_crtc->dev->dev_private,
-					surface,
+					dc_plane_state,
 					plane_state,
 					crtc_state,
 					false);
@@ -4873,15 +4875,15 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 					goto fail;
 
 
-				if (dm_plane_state->surface)
-					dc_surface_release(dm_plane_state->surface);
+				if (dm_plane_state->dc_state)
+					dc_plane_state_release(dm_plane_state->dc_state);
 
-				dm_plane_state->surface = surface;
+				dm_plane_state->dc_state = dc_plane_state;
 
-				add_val_sets_surface(set,
+				add_val_sets_plane(set,
 						     set_count,
 						     new_acrtc_state->stream,
-						     surface);
+						     dc_plane_state);
 
 				lock_and_validation_needed = true;
 			}
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
index cca65a3..e0a5632 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
@@ -196,7 +196,7 @@ struct  dc_stream;
 
 struct dm_plane_state {
 	struct drm_plane_state base;
-	struct dc_plane_state *surface;
+	struct dc_plane_state *dc_state;
 };
 
 struct dm_crtc_state {
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
index 9a85022..28dbd18 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
@@ -2594,15 +2594,15 @@ static void populate_initial_data(
 		if (!pipe[i].stream || !pipe[i].bottom_pipe)
 			continue;
 
-		ASSERT(pipe[i].surface);
+		ASSERT(pipe[i].plane_state);
 
 		if (num_displays == 0) {
-			if (!pipe[i].surface->visible)
+			if (!pipe[i].plane_state->visible)
 				data->d0_underlay_mode = bw_def_underlay_only;
 			else
 				data->d0_underlay_mode = bw_def_blend;
 		} else {
-			if (!pipe[i].surface->visible)
+			if (!pipe[i].plane_state->visible)
 				data->d1_underlay_mode = bw_def_underlay_only;
 			else
 				data->d1_underlay_mode = bw_def_blend;
@@ -2620,7 +2620,7 @@ static void populate_initial_data(
 		data->v_taps[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.taps.v_taps);
 		data->h_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.horz.value);
 		data->v_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.vert.value);
-		switch (pipe[i].surface->rotation) {
+		switch (pipe[i].plane_state->rotation) {
 		case ROTATION_ANGLE_0:
 			data->rotation_angle[num_displays + 4] = bw_int_to_fixed(0);
 			break;
@@ -2636,7 +2636,7 @@ static void populate_initial_data(
 		default:
 			break;
 		}
-		switch (pipe[i].surface->format) {
+		switch (pipe[i].plane_state->format) {
 		case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 		case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
 		case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
@@ -2670,14 +2670,14 @@ static void populate_initial_data(
 			data->src_height[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.viewport.height);
 			data->src_width[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.viewport.width);
 			data->pitch_in_pixels[num_displays * 2 + j] = bw_int_to_fixed(
-					pipe[i].bottom_pipe->surface->plane_size.grph.surface_pitch);
+					pipe[i].bottom_pipe->plane_state->plane_size.grph.surface_pitch);
 			data->h_taps[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.taps.h_taps);
 			data->v_taps[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.taps.v_taps);
 			data->h_scale_ratio[num_displays * 2 + j] = fixed31_32_to_bw_fixed(
 					pipe[i].bottom_pipe->scl_data.ratios.horz.value);
 			data->v_scale_ratio[num_displays * 2 + j] = fixed31_32_to_bw_fixed(
 					pipe[i].bottom_pipe->scl_data.ratios.vert.value);
-			switch (pipe[i].bottom_pipe->surface->rotation) {
+			switch (pipe[i].bottom_pipe->plane_state->rotation) {
 			case ROTATION_ANGLE_0:
 				data->rotation_angle[num_displays * 2 + j] = bw_int_to_fixed(0);
 				break;
@@ -2710,7 +2710,7 @@ static void populate_initial_data(
 		data->h_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.h_total);
 		data->v_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.v_total);
 		data->pixel_rate[num_displays + 4] = bw_frc_to_fixed(pipe[i].stream->timing.pix_clk_khz, 1000);
-		if (pipe[i].surface) {
+		if (pipe[i].plane_state) {
 			data->src_width[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.viewport.width);
 			data->pitch_in_pixels[num_displays + 4] = data->src_width[num_displays + 4];
 			data->src_height[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.viewport.height);
@@ -2718,7 +2718,7 @@ static void populate_initial_data(
 			data->v_taps[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.taps.v_taps);
 			data->h_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.horz.value);
 			data->v_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.vert.value);
-			switch (pipe[i].surface->rotation) {
+			switch (pipe[i].plane_state->rotation) {
 			case ROTATION_ANGLE_0:
 				data->rotation_angle[num_displays + 4] = bw_int_to_fixed(0);
 				break;
@@ -2734,7 +2734,7 @@ static void populate_initial_data(
 			default:
 				break;
 			}
-			switch (pipe[i].surface->format) {
+			switch (pipe[i].plane_state->format) {
 			case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 			case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
 			case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
index 7f7cb8f..404b39e 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -233,16 +233,16 @@ static void pipe_ctx_to_e2e_pipe_params (
 		struct _vcs_dpi_display_pipe_params_st *input)
 {
 	input->src.is_hsplit = false;
-	if (pipe->top_pipe != NULL && pipe->top_pipe->surface == pipe->surface)
+	if (pipe->top_pipe != NULL && pipe->top_pipe->plane_state == pipe->plane_state)
 		input->src.is_hsplit = true;
-	else if (pipe->bottom_pipe != NULL && pipe->bottom_pipe->surface == pipe->surface)
+	else if (pipe->bottom_pipe != NULL && pipe->bottom_pipe->plane_state == pipe->plane_state)
 		input->src.is_hsplit = true;
 
-	input->src.dcc                 = pipe->surface->dcc.enable;
+	input->src.dcc                 = pipe->plane_state->dcc.enable;
 	input->src.dcc_rate            = 1;
-	input->src.meta_pitch          = pipe->surface->dcc.grph.meta_pitch;
+	input->src.meta_pitch          = pipe->plane_state->dcc.grph.meta_pitch;
 	input->src.source_scan         = dm_horz;
-	input->src.sw_mode             = pipe->surface->tiling_info.gfx9.swizzle;
+	input->src.sw_mode             = pipe->plane_state->tiling_info.gfx9.swizzle;
 
 	input->src.viewport_width      = pipe->scl_data.viewport.width;
 	input->src.viewport_height     = pipe->scl_data.viewport.height;
@@ -251,7 +251,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 	input->src.cur0_src_width      = 128; /* TODO: Cursor calcs, not curently stored */
 	input->src.cur0_bpp            = 32;
 
-	switch (pipe->surface->tiling_info.gfx9.swizzle) {
+	switch (pipe->plane_state->tiling_info.gfx9.swizzle) {
 	/* for 4/8/16 high tiles */
 	case DC_SW_LINEAR:
 		input->src.is_display_sw = 1;
@@ -299,7 +299,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 		break;
 	}
 
-	switch (pipe->surface->rotation) {
+	switch (pipe->plane_state->rotation) {
 	case ROTATION_ANGLE_0:
 	case ROTATION_ANGLE_180:
 		input->src.source_scan = dm_horz;
@@ -314,7 +314,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 	}
 
 	/* TODO: Fix pixel format mappings */
-	switch (pipe->surface->format) {
+	switch (pipe->plane_state->format) {
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
 		input->src.source_format = dm_420_8;
@@ -455,7 +455,7 @@ static void dcn_bw_calc_rq_dlg_ttu(
 			true,
 			true,
 			v->pte_enable == dcn_bw_yes,
-			pipe->surface->flip_immediate);
+			pipe->plane_state->flip_immediate);
 }
 
 static void dcn_dml_wm_override(
@@ -478,7 +478,7 @@ static void dcn_dml_wm_override(
 	for (i = 0, in_idx = 0; i < pool->pipe_count; i++) {
 		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe->stream || !pipe->surface)
+		if (!pipe->stream || !pipe->plane_state)
 			continue;
 
 		input[in_idx].clks_cfg.dcfclk_mhz = v->dcfclk;
@@ -516,7 +516,7 @@ static void dcn_dml_wm_override(
 	for (i = 0, in_idx = 0; i < pool->pipe_count; i++) {
 		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe->stream || !pipe->surface)
+		if (!pipe->stream || !pipe->plane_state)
 			continue;
 
 		dml_rq_dlg_get_dlg_reg(dml,
@@ -527,7 +527,7 @@ static void dcn_dml_wm_override(
 			true,
 			true,
 			v->pte_enable == dcn_bw_yes,
-			pipe->surface->flip_immediate);
+			pipe->plane_state->flip_immediate);
 		in_idx++;
 	}
 	dm_free(input);
@@ -541,7 +541,7 @@ static void split_stream_across_pipes(
 {
 	int pipe_idx = secondary_pipe->pipe_idx;
 
-	if (!primary_pipe->surface)
+	if (!primary_pipe->plane_state)
 		return;
 
 	*secondary_pipe = *primary_pipe;
@@ -843,7 +843,7 @@ bool dcn_validate_bandwidth(
 		if (!pipe->stream)
 			continue;
 		/* skip all but first of split pipes */
-		if (pipe->top_pipe && pipe->top_pipe->surface == pipe->surface)
+		if (pipe->top_pipe && pipe->top_pipe->plane_state == pipe->plane_state)
 			continue;
 
 		v->underscan_output[input_idx] = false; /* taken care of in recout already*/
@@ -869,7 +869,7 @@ bool dcn_validate_bandwidth(
 			}
 		}
 
-		if (!pipe->surface){
+		if (!pipe->plane_state) {
 			v->dcc_enable[input_idx] = dcn_bw_yes;
 			v->source_pixel_format[input_idx] = dcn_bw_rgb_sub_32;
 			v->source_surface_mode[input_idx] = dcn_bw_sw_4_kb_s;
@@ -889,8 +889,8 @@ bool dcn_validate_bandwidth(
 			v->viewport_width[input_idx] = pipe->scl_data.viewport.width;
 			v->scaler_rec_out_width[input_idx] = pipe->scl_data.recout.width;
 			v->scaler_recout_height[input_idx] = pipe->scl_data.recout.height;
-			if (pipe->bottom_pipe && pipe->bottom_pipe->surface == pipe->surface) {
-				if (pipe->surface->rotation % 2 == 0) {
+			if (pipe->bottom_pipe && pipe->bottom_pipe->plane_state == pipe->plane_state) {
+				if (pipe->plane_state->rotation % 2 == 0) {
 					int viewport_end = pipe->scl_data.viewport.width
 							+ pipe->scl_data.viewport.x;
 					int viewport_b_end = pipe->bottom_pipe->scl_data.viewport.width
@@ -919,17 +919,17 @@ bool dcn_validate_bandwidth(
 						+ pipe->bottom_pipe->scl_data.recout.width;
 			}
 
-			v->dcc_enable[input_idx] = pipe->surface->dcc.enable ? dcn_bw_yes : dcn_bw_no;
+			v->dcc_enable[input_idx] = pipe->plane_state->dcc.enable ? dcn_bw_yes : dcn_bw_no;
 			v->source_pixel_format[input_idx] = tl_pixel_format_to_bw_defs(
-					pipe->surface->format);
+					pipe->plane_state->format);
 			v->source_surface_mode[input_idx] = tl_sw_mode_to_bw_defs(
-					pipe->surface->tiling_info.gfx9.swizzle);
+					pipe->plane_state->tiling_info.gfx9.swizzle);
 			v->lb_bit_per_pixel[input_idx] = tl_lb_bpp_to_int(pipe->scl_data.lb_params.depth);
 			v->override_hta_ps[input_idx] = pipe->scl_data.taps.h_taps;
 			v->override_vta_ps[input_idx] = pipe->scl_data.taps.v_taps;
 			v->override_hta_pschroma[input_idx] = pipe->scl_data.taps.h_taps_c;
 			v->override_vta_pschroma[input_idx] = pipe->scl_data.taps.v_taps_c;
-			v->source_scan[input_idx] = (pipe->surface->rotation % 2) ? dcn_bw_vert : dcn_bw_hor;
+			v->source_scan[input_idx] = (pipe->plane_state->rotation % 2) ? dcn_bw_vert : dcn_bw_hor;
 		}
 		if (v->is_line_buffer_bpp_fixed == dcn_bw_yes)
 			v->lb_bit_per_pixel[input_idx] = v->line_buffer_fixed_bpp;
@@ -996,7 +996,7 @@ bool dcn_validate_bandwidth(
 			if (!pipe->stream)
 				continue;
 			/* skip all but first of split pipes */
-			if (pipe->top_pipe && pipe->top_pipe->surface == pipe->surface)
+			if (pipe->top_pipe && pipe->top_pipe->plane_state == pipe->plane_state)
 				continue;
 
 			pipe->pipe_dlg_param.vupdate_width = v->v_update_width[input_idx];
@@ -1024,7 +1024,7 @@ bool dcn_validate_bandwidth(
 			pipe->pipe_dlg_param.vblank_start = asic_blank_start;
 			pipe->pipe_dlg_param.vblank_end = asic_blank_end;
 
-			if (pipe->surface) {
+			if (pipe->plane_state) {
 				struct pipe_ctx *hsplit_pipe = pipe->bottom_pipe;
 
 				if (v->dpp_per_plane[input_idx] == 2 ||
@@ -1036,7 +1036,7 @@ bool dcn_validate_bandwidth(
 					 TIMING_3D_FORMAT_TOP_AND_BOTTOM ||
 					 pipe->stream->timing.timing_3d_format ==
 					 TIMING_3D_FORMAT_SIDE_BY_SIDE))) {
-					if (hsplit_pipe && hsplit_pipe->surface == pipe->surface) {
+					if (hsplit_pipe && hsplit_pipe->plane_state == pipe->plane_state) {
 						/* update previously split pipe */
 						hsplit_pipe->pipe_dlg_param.vupdate_width = v->v_update_width[input_idx];
 						hsplit_pipe->pipe_dlg_param.vupdate_offset = v->v_update_offset[input_idx];
@@ -1057,12 +1057,12 @@ bool dcn_validate_bandwidth(
 					}
 
 					dcn_bw_calc_rq_dlg_ttu(dc, v, hsplit_pipe);
-				} else if (hsplit_pipe && hsplit_pipe->surface == pipe->surface) {
+				} else if (hsplit_pipe && hsplit_pipe->plane_state == pipe->plane_state) {
 					/* merge previously split pipe */
 					pipe->bottom_pipe = hsplit_pipe->bottom_pipe;
 					if (hsplit_pipe->bottom_pipe)
 						hsplit_pipe->bottom_pipe->top_pipe = pipe;
-					hsplit_pipe->surface = NULL;
+					hsplit_pipe->plane_state = NULL;
 					hsplit_pipe->stream = NULL;
 					hsplit_pipe->top_pipe = NULL;
 					hsplit_pipe->bottom_pipe = NULL;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8b6b763..ffc9c05 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -639,21 +639,21 @@ static bool is_validation_required(
 
 	for (i = 0; i < set_count; i++) {
 
-		if (set[i].surface_count != context->stream_status[i].surface_count)
+		if (set[i].plane_count != context->stream_status[i].plane_count)
 			return true;
 		if (!dc_is_stream_unchanged(set[i].stream, context->streams[i]))
 			return true;
 
-		for (j = 0; j < set[i].surface_count; j++) {
-			struct dc_plane_state temp_surf;
-			memset(&temp_surf, 0, sizeof(temp_surf));
+		for (j = 0; j < set[i].plane_count; j++) {
+			struct dc_plane_state temp_plane;
+			memset(&temp_plane, 0, sizeof(temp_plane));
 
-			temp_surf = *context->stream_status[i].surfaces[j];
-			temp_surf.clip_rect = set[i].surfaces[j]->clip_rect;
-			temp_surf.dst_rect.x = set[i].surfaces[j]->dst_rect.x;
-			temp_surf.dst_rect.y = set[i].surfaces[j]->dst_rect.y;
+			temp_plane = *context->stream_status[i].plane_states[j];
+			temp_plane.clip_rect = set[i].plane_states[j]->clip_rect;
+			temp_plane.dst_rect.x = set[i].plane_states[j]->dst_rect.x;
+			temp_plane.dst_rect.y = set[i].plane_states[j]->dst_rect.y;
 
-			if (memcmp(&temp_surf, set[i].surfaces[j], sizeof(temp_surf)) != 0)
+			if (memcmp(&temp_plane, set[i].plane_states[j], sizeof(temp_plane)) != 0)
 				return true;
 		}
 	}
@@ -683,8 +683,8 @@ static bool validate_surfaces(
 	int i, j;
 
 	for (i = 0; i < set_count; i++)
-		for (j = 0; j < set[i].surface_count; j++)
-			if (!dc_validate_plane(dc, set[i].surfaces[j]))
+		for (j = 0; j < set[i].plane_count; j++)
+			if (!dc_validate_plane(dc, set[i].plane_states[j]))
 				return false;
 
 	return true;
@@ -977,11 +977,11 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
-		for (j = 0; j < context->stream_status[i].surface_count; j++) {
-			const struct dc_plane_state *surface =
-					context->stream_status[i].surfaces[j];
+		for (j = 0; j < context->stream_status[i].plane_count; j++) {
+			const struct dc_plane_state *plane_state =
+					context->stream_status[i].plane_states[j];
 
-			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
+			core_dc->hwss.apply_ctx_for_surface(core_dc, plane_state, context);
 
 			/*
 			 * enable stereo
@@ -1073,9 +1073,9 @@ bool dc_commit_streams(
 		set[i].stream = stream;
 
 		if (status) {
-			set[i].surface_count = status->surface_count;
-			for (j = 0; j < status->surface_count; j++)
-				set[i].surfaces[j] = status->surfaces[j];
+			set[i].plane_count = status->plane_count;
+			for (j = 0; j < status->plane_count; j++)
+				set[i].plane_states[j] = status->plane_states[j];
 		}
 
 	}
@@ -1122,7 +1122,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL
-				|| context->res_ctx.pipe_ctx[i].surface == NULL)
+				|| context->res_ctx.pipe_ctx[i].plane_state == NULL)
 			core_dc->hwss.power_down_front_end(core_dc, i);
 
 	/* 3rd param should be true, temp w/a for RV*/
@@ -1134,10 +1134,10 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	return true;
 }
 
-bool dc_commit_surfaces_to_stream(
+bool dc_commit_planes_to_stream(
 		struct dc *dc,
-		struct dc_plane_state **new_surfaces,
-		uint8_t new_surface_count,
+		struct dc_plane_state **plane_states,
+		uint8_t new_plane_count,
 		struct dc_stream_state *dc_stream)
 {
 	struct dc_surface_update updates[MAX_SURFACES];
@@ -1162,37 +1162,37 @@ bool dc_commit_surfaces_to_stream(
 	stream_update->dst = dc_stream->dst;
 	stream_update->out_transfer_func = dc_stream->out_transfer_func;
 
-	for (i = 0; i < new_surface_count; i++) {
-		updates[i].surface = new_surfaces[i];
+	for (i = 0; i < new_plane_count; i++) {
+		updates[i].surface = plane_states[i];
 		updates[i].gamma =
-			(struct dc_gamma *)new_surfaces[i]->gamma_correction;
-		updates[i].in_transfer_func = new_surfaces[i]->in_transfer_func;
-		flip_addr[i].address = new_surfaces[i]->address;
-		flip_addr[i].flip_immediate = new_surfaces[i]->flip_immediate;
-		plane_info[i].color_space = new_surfaces[i]->color_space;
-		plane_info[i].format = new_surfaces[i]->format;
-		plane_info[i].plane_size = new_surfaces[i]->plane_size;
-		plane_info[i].rotation = new_surfaces[i]->rotation;
-		plane_info[i].horizontal_mirror = new_surfaces[i]->horizontal_mirror;
-		plane_info[i].stereo_format = new_surfaces[i]->stereo_format;
-		plane_info[i].tiling_info = new_surfaces[i]->tiling_info;
-		plane_info[i].visible = new_surfaces[i]->visible;
-		plane_info[i].per_pixel_alpha = new_surfaces[i]->per_pixel_alpha;
-		plane_info[i].dcc = new_surfaces[i]->dcc;
-		scaling_info[i].scaling_quality = new_surfaces[i]->scaling_quality;
-		scaling_info[i].src_rect = new_surfaces[i]->src_rect;
-		scaling_info[i].dst_rect = new_surfaces[i]->dst_rect;
-		scaling_info[i].clip_rect = new_surfaces[i]->clip_rect;
+			(struct dc_gamma *)plane_states[i]->gamma_correction;
+		updates[i].in_transfer_func = plane_states[i]->in_transfer_func;
+		flip_addr[i].address = plane_states[i]->address;
+		flip_addr[i].flip_immediate = plane_states[i]->flip_immediate;
+		plane_info[i].color_space = plane_states[i]->color_space;
+		plane_info[i].format = plane_states[i]->format;
+		plane_info[i].plane_size = plane_states[i]->plane_size;
+		plane_info[i].rotation = plane_states[i]->rotation;
+		plane_info[i].horizontal_mirror = plane_states[i]->horizontal_mirror;
+		plane_info[i].stereo_format = plane_states[i]->stereo_format;
+		plane_info[i].tiling_info = plane_states[i]->tiling_info;
+		plane_info[i].visible = plane_states[i]->visible;
+		plane_info[i].per_pixel_alpha = plane_states[i]->per_pixel_alpha;
+		plane_info[i].dcc = plane_states[i]->dcc;
+		scaling_info[i].scaling_quality = plane_states[i]->scaling_quality;
+		scaling_info[i].src_rect = plane_states[i]->src_rect;
+		scaling_info[i].dst_rect = plane_states[i]->dst_rect;
+		scaling_info[i].clip_rect = plane_states[i]->clip_rect;
 
 		updates[i].flip_addr = &flip_addr[i];
 		updates[i].plane_info = &plane_info[i];
 		updates[i].scaling_info = &scaling_info[i];
 	}
 
-	dc_update_surfaces_and_stream(
+	dc_update_planes_and_stream(
 			dc,
 			updates,
-			new_surface_count,
+			new_plane_count,
 			dc_stream, stream_update);
 
 	dc_post_update_surfaces_to_stream(dc);
@@ -1220,14 +1220,14 @@ void dc_release_validate_context(struct validate_context *context)
 
 static bool is_surface_in_context(
 		const struct validate_context *context,
-		const struct dc_plane_state *surface)
+		const struct dc_plane_state *plane_state)
 {
 	int j;
 
 	for (j = 0; j < MAX_PIPES; j++) {
 		const struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (surface == pipe_ctx->surface) {
+		if (plane_state == pipe_ctx->plane_state) {
 			return true;
 		}
 	}
@@ -1371,7 +1371,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	int i;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
-	if (stream_status == NULL || stream_status->surface_count != surface_count)
+	if (stream_status == NULL || stream_status->plane_count != surface_count)
 		return UPDATE_TYPE_FULL;
 
 	if (stream_update)
@@ -1393,7 +1393,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 
 enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
-void dc_update_surfaces_and_stream(struct dc *dc,
+void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_surface_update *srf_updates, int surface_count,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update)
@@ -1470,10 +1470,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		update_surface_trace(dc, srf_updates, surface_count);
 
 	if (update_type >= UPDATE_TYPE_FULL) {
-		struct dc_plane_state *new_surfaces[MAX_SURFACES] = {0};
+		struct dc_plane_state *new_planes[MAX_SURFACES] = {0};
 
 		for (i = 0; i < surface_count; i++)
-			new_surfaces[i] = srf_updates[i].surface;
+			new_planes[i] = srf_updates[i].surface;
 
 		/* initialize scratch memory for building context */
 		context = dm_alloc(sizeof(*context));
@@ -1487,7 +1487,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* add surface to context */
 		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, stream,
+				new_planes, surface_count, stream,
 				context, core_dc->res_pool)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
@@ -1542,7 +1542,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-				if (pipe_ctx->surface != surface)
+				if (pipe_ctx->plane_state != surface)
 					continue;
 
 				resource_build_scaling_params(pipe_ctx);
@@ -1599,14 +1599,14 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = srf_updates[i].surface;
+		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->surface != surface)
+			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->plane_state != plane_state)
 				continue;
-			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
 			core_dc->hwss.pipe_control_lock(
@@ -1622,15 +1622,15 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 		struct pipe_ctx *cur_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
-		bool is_new_pipe_surface = cur_pipe_ctx->surface != pipe_ctx->surface;
+		bool is_new_pipe_surface = cur_pipe_ctx->plane_state != pipe_ctx->plane_state;
 		struct dc_cursor_position position = { 0 };
 
-		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->surface)
+		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->plane_state)
 			continue;
 
 		if (!pipe_ctx->top_pipe)
 			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, pipe_ctx->surface, context);
+					core_dc, pipe_ctx->plane_state, context);
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
 		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
@@ -1638,7 +1638,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		if (is_new_pipe_surface) {
 			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 			core_dc->hwss.set_input_transfer_func(
-					pipe_ctx, pipe_ctx->surface);
+					pipe_ctx, pipe_ctx->plane_state);
 			core_dc->hwss.set_output_transfer_func(
 					pipe_ctx, pipe_ctx->stream);
 		}
@@ -1649,16 +1649,16 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Perform requested Updates */
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = srf_updates[i].surface;
+		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
 		if (update_type == UPDATE_TYPE_MED)
 			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, surface, context);
+					core_dc, plane_state, context);
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (pipe_ctx->surface != surface)
+			if (pipe_ctx->plane_state != plane_state)
 				continue;
 
 			if (srf_updates[i].flip_addr)
@@ -1669,7 +1669,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 			if (srf_updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(
-						pipe_ctx, pipe_ctx->surface);
+						pipe_ctx, pipe_ctx->plane_state);
 
 			if (stream_update != NULL &&
 					stream_update->out_transfer_func != NULL) {
@@ -1690,9 +1690,9 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		for (j = 0; j < surface_count; j++) {
 			if (update_type != UPDATE_TYPE_FULL &&
-			    srf_updates[j].surface != pipe_ctx->surface)
+			    srf_updates[j].surface != pipe_ctx->plane_state)
 				continue;
-			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
 			core_dc->hwss.pipe_control_lock(
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_debug.c b/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
index e8d4b8c..ca4f1db 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
@@ -38,7 +38,7 @@
 
 void pre_surface_trace(
 		const struct dc *dc,
-		const struct dc_plane_state *const *surfaces,
+		const struct dc_plane_state *const *plane_states,
 		int surface_count)
 {
 	int i;
@@ -46,111 +46,111 @@ void pre_surface_trace(
 	struct dal_logger *logger =  core_dc->ctx->logger;
 
 	for (i = 0; i < surface_count; i++) {
-		const struct dc_plane_state *surface = surfaces[i];
+		const struct dc_plane_state *plane_state = plane_states[i];
 
-		SURFACE_TRACE("Surface %d:\n", i);
+		SURFACE_TRACE("Planes %d:\n", i);
 
 		SURFACE_TRACE(
-				"surface->visible = %d;\n"
-				"surface->flip_immediate = %d;\n"
-				"surface->address.type = %d;\n"
-				"surface->address.grph.addr.quad_part = 0x%X;\n"
-				"surface->address.grph.meta_addr.quad_part = 0x%X;\n"
-				"surface->scaling_quality.h_taps = %d;\n"
-				"surface->scaling_quality.v_taps = %d;\n"
-				"surface->scaling_quality.h_taps_c = %d;\n"
-				"surface->scaling_quality.v_taps_c = %d;\n",
-				surface->visible,
-				surface->flip_immediate,
-				surface->address.type,
-				surface->address.grph.addr.quad_part,
-				surface->address.grph.meta_addr.quad_part,
-				surface->scaling_quality.h_taps,
-				surface->scaling_quality.v_taps,
-				surface->scaling_quality.h_taps_c,
-				surface->scaling_quality.v_taps_c);
+				"plane_state->visible = %d;\n"
+				"plane_state->flip_immediate = %d;\n"
+				"plane_state->address.type = %d;\n"
+				"plane_state->address.grph.addr.quad_part = 0x%X;\n"
+				"plane_state->address.grph.meta_addr.quad_part = 0x%X;\n"
+				"plane_state->scaling_quality.h_taps = %d;\n"
+				"plane_state->scaling_quality.v_taps = %d;\n"
+				"plane_state->scaling_quality.h_taps_c = %d;\n"
+				"plane_state->scaling_quality.v_taps_c = %d;\n",
+				plane_state->visible,
+				plane_state->flip_immediate,
+				plane_state->address.type,
+				plane_state->address.grph.addr.quad_part,
+				plane_state->address.grph.meta_addr.quad_part,
+				plane_state->scaling_quality.h_taps,
+				plane_state->scaling_quality.v_taps,
+				plane_state->scaling_quality.h_taps_c,
+				plane_state->scaling_quality.v_taps_c);
 
 		SURFACE_TRACE(
-				"surface->src_rect.x = %d;\n"
-				"surface->src_rect.y = %d;\n"
-				"surface->src_rect.width = %d;\n"
-				"surface->src_rect.height = %d;\n"
-				"surface->dst_rect.x = %d;\n"
-				"surface->dst_rect.y = %d;\n"
-				"surface->dst_rect.width = %d;\n"
-				"surface->dst_rect.height = %d;\n"
-				"surface->clip_rect.x = %d;\n"
-				"surface->clip_rect.y = %d;\n"
-				"surface->clip_rect.width = %d;\n"
-				"surface->clip_rect.height = %d;\n",
-				surface->src_rect.x,
-				surface->src_rect.y,
-				surface->src_rect.width,
-				surface->src_rect.height,
-				surface->dst_rect.x,
-				surface->dst_rect.y,
-				surface->dst_rect.width,
-				surface->dst_rect.height,
-				surface->clip_rect.x,
-				surface->clip_rect.y,
-				surface->clip_rect.width,
-				surface->clip_rect.height);
+				"plane_state->src_rect.x = %d;\n"
+				"plane_state->src_rect.y = %d;\n"
+				"plane_state->src_rect.width = %d;\n"
+				"plane_state->src_rect.height = %d;\n"
+				"plane_state->dst_rect.x = %d;\n"
+				"plane_state->dst_rect.y = %d;\n"
+				"plane_state->dst_rect.width = %d;\n"
+				"plane_state->dst_rect.height = %d;\n"
+				"plane_state->clip_rect.x = %d;\n"
+				"plane_state->clip_rect.y = %d;\n"
+				"plane_state->clip_rect.width = %d;\n"
+				"plane_state->clip_rect.height = %d;\n",
+				plane_state->src_rect.x,
+				plane_state->src_rect.y,
+				plane_state->src_rect.width,
+				plane_state->src_rect.height,
+				plane_state->dst_rect.x,
+				plane_state->dst_rect.y,
+				plane_state->dst_rect.width,
+				plane_state->dst_rect.height,
+				plane_state->clip_rect.x,
+				plane_state->clip_rect.y,
+				plane_state->clip_rect.width,
+				plane_state->clip_rect.height);
 
 		SURFACE_TRACE(
-				"surface->plane_size.grph.surface_size.x = %d;\n"
-				"surface->plane_size.grph.surface_size.y = %d;\n"
-				"surface->plane_size.grph.surface_size.width = %d;\n"
-				"surface->plane_size.grph.surface_size.height = %d;\n"
-				"surface->plane_size.grph.surface_pitch = %d;\n",
-				surface->plane_size.grph.surface_size.x,
-				surface->plane_size.grph.surface_size.y,
-				surface->plane_size.grph.surface_size.width,
-				surface->plane_size.grph.surface_size.height,
-				surface->plane_size.grph.surface_pitch);
+				"plane_state->plane_size.grph.surface_size.x = %d;\n"
+				"plane_state->plane_size.grph.surface_size.y = %d;\n"
+				"plane_state->plane_size.grph.surface_size.width = %d;\n"
+				"plane_state->plane_size.grph.surface_size.height = %d;\n"
+				"plane_state->plane_size.grph.surface_pitch = %d;\n",
+				plane_state->plane_size.grph.surface_size.x,
+				plane_state->plane_size.grph.surface_size.y,
+				plane_state->plane_size.grph.surface_size.width,
+				plane_state->plane_size.grph.surface_size.height,
+				plane_state->plane_size.grph.surface_pitch);
 
 
 		SURFACE_TRACE(
-				"surface->tiling_info.gfx8.num_banks = %d;\n"
-				"surface->tiling_info.gfx8.bank_width = %d;\n"
-				"surface->tiling_info.gfx8.bank_width_c = %d;\n"
-				"surface->tiling_info.gfx8.bank_height = %d;\n"
-				"surface->tiling_info.gfx8.bank_height_c = %d;\n"
-				"surface->tiling_info.gfx8.tile_aspect = %d;\n"
-				"surface->tiling_info.gfx8.tile_aspect_c = %d;\n"
-				"surface->tiling_info.gfx8.tile_split = %d;\n"
-				"surface->tiling_info.gfx8.tile_split_c = %d;\n"
-				"surface->tiling_info.gfx8.tile_mode = %d;\n"
-				"surface->tiling_info.gfx8.tile_mode_c = %d;\n",
-				surface->tiling_info.gfx8.num_banks,
-				surface->tiling_info.gfx8.bank_width,
-				surface->tiling_info.gfx8.bank_width_c,
-				surface->tiling_info.gfx8.bank_height,
-				surface->tiling_info.gfx8.bank_height_c,
-				surface->tiling_info.gfx8.tile_aspect,
-				surface->tiling_info.gfx8.tile_aspect_c,
-				surface->tiling_info.gfx8.tile_split,
-				surface->tiling_info.gfx8.tile_split_c,
-				surface->tiling_info.gfx8.tile_mode,
-				surface->tiling_info.gfx8.tile_mode_c);
+				"plane_state->tiling_info.gfx8.num_banks = %d;\n"
+				"plane_state->tiling_info.gfx8.bank_width = %d;\n"
+				"plane_state->tiling_info.gfx8.bank_width_c = %d;\n"
+				"plane_state->tiling_info.gfx8.bank_height = %d;\n"
+				"plane_state->tiling_info.gfx8.bank_height_c = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_aspect = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_aspect_c = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_split = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_split_c = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_mode = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_mode_c = %d;\n",
+				plane_state->tiling_info.gfx8.num_banks,
+				plane_state->tiling_info.gfx8.bank_width,
+				plane_state->tiling_info.gfx8.bank_width_c,
+				plane_state->tiling_info.gfx8.bank_height,
+				plane_state->tiling_info.gfx8.bank_height_c,
+				plane_state->tiling_info.gfx8.tile_aspect,
+				plane_state->tiling_info.gfx8.tile_aspect_c,
+				plane_state->tiling_info.gfx8.tile_split,
+				plane_state->tiling_info.gfx8.tile_split_c,
+				plane_state->tiling_info.gfx8.tile_mode,
+				plane_state->tiling_info.gfx8.tile_mode_c);
 
 		SURFACE_TRACE(
-				"surface->tiling_info.gfx8.pipe_config = %d;\n"
-				"surface->tiling_info.gfx8.array_mode = %d;\n"
-				"surface->color_space = %d;\n"
-				"surface->dcc.enable = %d;\n"
-				"surface->format = %d;\n"
-				"surface->rotation = %d;\n"
-				"surface->stereo_format = %d;\n",
-				surface->tiling_info.gfx8.pipe_config,
-				surface->tiling_info.gfx8.array_mode,
-				surface->color_space,
-				surface->dcc.enable,
-				surface->format,
-				surface->rotation,
-				surface->stereo_format);
-
-		SURFACE_TRACE("surface->tiling_info.gfx9.swizzle = %d;\n",
-				surface->tiling_info.gfx9.swizzle);
+				"plane_state->tiling_info.gfx8.pipe_config = %d;\n"
+				"plane_state->tiling_info.gfx8.array_mode = %d;\n"
+				"plane_state->color_space = %d;\n"
+				"plane_state->dcc.enable = %d;\n"
+				"plane_state->format = %d;\n"
+				"plane_state->rotation = %d;\n"
+				"plane_state->stereo_format = %d;\n",
+				plane_state->tiling_info.gfx8.pipe_config,
+				plane_state->tiling_info.gfx8.array_mode,
+				plane_state->color_space,
+				plane_state->dcc.enable,
+				plane_state->format,
+				plane_state->rotation,
+				plane_state->stereo_format);
+
+		SURFACE_TRACE("plane_state->tiling_info.gfx9.swizzle = %d;\n",
+				plane_state->tiling_info.gfx9.swizzle);
 
 		SURFACE_TRACE("\n");
 	}
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7a1c84a..7c30962 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -430,17 +430,17 @@ static void rect_swap_helper(struct rect *rect)
 
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect surf_src = surface->src_rect;
+	struct rect surf_src = plane_state->src_rect;
 	struct rect clip = { 0 };
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 	bool pri_split = pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface;
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
-			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
+			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
 		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
@@ -448,41 +448,41 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		sec_split = false;
 	}
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	/* The actual clip is an intersection between stream
 	 * source and surface clip
 	 */
-	clip.x = stream->src.x > surface->clip_rect.x ?
-			stream->src.x : surface->clip_rect.x;
+	clip.x = stream->src.x > plane_state->clip_rect.x ?
+			stream->src.x : plane_state->clip_rect.x;
 
 	clip.width = stream->src.x + stream->src.width <
-			surface->clip_rect.x + surface->clip_rect.width ?
+			plane_state->clip_rect.x + plane_state->clip_rect.width ?
 			stream->src.x + stream->src.width - clip.x :
-			surface->clip_rect.x + surface->clip_rect.width - clip.x ;
+			plane_state->clip_rect.x + plane_state->clip_rect.width - clip.x ;
 
-	clip.y = stream->src.y > surface->clip_rect.y ?
-			stream->src.y : surface->clip_rect.y;
+	clip.y = stream->src.y > plane_state->clip_rect.y ?
+			stream->src.y : plane_state->clip_rect.y;
 
 	clip.height = stream->src.y + stream->src.height <
-			surface->clip_rect.y + surface->clip_rect.height ?
+			plane_state->clip_rect.y + plane_state->clip_rect.height ?
 			stream->src.y + stream->src.height - clip.y :
-			surface->clip_rect.y + surface->clip_rect.height - clip.y ;
+			plane_state->clip_rect.y + plane_state->clip_rect.height - clip.y ;
 
 	/* offset = surf_src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
 	 * num_pixels = clip.num_pix * scl_ratio
 	 */
-	data->viewport.x = surf_src.x + (clip.x - surface->dst_rect.x) *
-			surf_src.width / surface->dst_rect.width;
+	data->viewport.x = surf_src.x + (clip.x - plane_state->dst_rect.x) *
+			surf_src.width / plane_state->dst_rect.width;
 	data->viewport.width = clip.width *
-			surf_src.width / surface->dst_rect.width;
+			surf_src.width / plane_state->dst_rect.width;
 
-	data->viewport.y = surf_src.y + (clip.y - surface->dst_rect.y) *
-			surf_src.height / surface->dst_rect.height;
+	data->viewport.y = surf_src.y + (clip.y - plane_state->dst_rect.y) *
+			surf_src.height / plane_state->dst_rect.height;
 	data->viewport.height = clip.height *
-			surf_src.height / surface->dst_rect.height;
+			surf_src.height / plane_state->dst_rect.height;
 
 	/* Round down, compensate in init */
 	data->viewport_c.x = data->viewport.x / vpc_div;
@@ -498,13 +498,13 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	/* Handle hsplit */
 	if (pri_split || sec_split) {
 		/* HMirror XOR Secondary_pipe XOR Rotation_180 */
-		bool right_view = (sec_split != surface->horizontal_mirror) !=
-					(surface->rotation == ROTATION_ANGLE_180);
+		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
+					(plane_state->rotation == ROTATION_ANGLE_180);
 
-		if (surface->rotation == ROTATION_ANGLE_90
-				|| surface->rotation == ROTATION_ANGLE_270)
+		if (plane_state->rotation == ROTATION_ANGLE_90
+				|| plane_state->rotation == ROTATION_ANGLE_270)
 			/* Secondary_pipe XOR Rotation_270 */
-			right_view = (surface->rotation == ROTATION_ANGLE_270) != sec_split;
+			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
 
 		if (right_view) {
 			data->viewport.width /= 2;
@@ -520,8 +520,8 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		}
 	}
 
-	if (surface->rotation == ROTATION_ANGLE_90 ||
-			surface->rotation == ROTATION_ANGLE_270) {
+	if (plane_state->rotation == ROTATION_ANGLE_90 ||
+			plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}
@@ -529,14 +529,14 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
-	struct rect surf_src = surface->src_rect;
-	struct rect surf_clip = surface->clip_rect;
+	struct rect surf_src = plane_state->src_rect;
+	struct rect surf_clip = plane_state->clip_rect;
 	int recout_full_x, recout_full_y;
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.recout.x = stream->dst.x;
@@ -568,8 +568,8 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 						- pipe_ctx->scl_data.recout.y;
 
 	/* Handle h & vsplit */
-	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface ==
-		pipe_ctx->surface) {
+	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state ==
+		pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
 			pipe_ctx->scl_data.recout.height /= 2;
 			pipe_ctx->scl_data.recout.y += pipe_ctx->scl_data.recout.height;
@@ -581,7 +581,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->scl_data.recout.width += pipe_ctx->scl_data.recout.width % 2;
 		}
 	} else if (pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 			pipe_ctx->scl_data.recout.height /= 2;
 		else
@@ -592,13 +592,13 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
 	 * 				ratio)
 	 */
-	recout_full_x = stream->dst.x + (surface->dst_rect.x -  stream->src.x)
+	recout_full_x = stream->dst.x + (plane_state->dst_rect.x -  stream->src.x)
 					* stream->dst.width / stream->src.width -
-			surf_src.x * surface->dst_rect.width / surf_src.width
+			surf_src.x * plane_state->dst_rect.width / surf_src.width
 					* stream->dst.width / stream->src.width;
-	recout_full_y = stream->dst.y + (surface->dst_rect.y -  stream->src.y)
+	recout_full_y = stream->dst.y + (plane_state->dst_rect.y -  stream->src.y)
 					* stream->dst.height / stream->src.height -
-			surf_src.y * surface->dst_rect.height / surf_src.height
+			surf_src.y * plane_state->dst_rect.height / surf_src.height
 					* stream->dst.height / stream->src.height;
 
 	recout_skip->width = pipe_ctx->scl_data.recout.x - recout_full_x;
@@ -607,24 +607,24 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
-	struct rect surf_src = surface->src_rect;
+	struct rect surf_src = plane_state->src_rect;
 	const int in_w = stream->src.width;
 	const int in_h = stream->src.height;
 	const int out_w = stream->dst.width;
 	const int out_h = stream->dst.height;
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
 					surf_src.width,
-					surface->dst_rect.width);
+					plane_state->dst_rect.width);
 	pipe_ctx->scl_data.ratios.vert = dal_fixed31_32_from_fraction(
 					surf_src.height,
-					surface->dst_rect.height);
+					plane_state->dst_rect.height);
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
 		pipe_ctx->scl_data.ratios.horz.value *= 2;
@@ -649,13 +649,13 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect src = pipe_ctx->surface->src_rect;
+	struct rect src = pipe_ctx->plane_state->src_rect;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
@@ -805,8 +805,8 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	data->inits.v_bot = dal_fixed31_32_add(data->inits.v, data->ratios.vert);
 	data->inits.v_c_bot = dal_fixed31_32_add(data->inits.v_c, data->ratios.vert_c);
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}
@@ -814,7 +814,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
@@ -824,7 +824,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 * Inits require viewport, taps, ratios and recout of split pipe
 	 */
 	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(
-			pipe_ctx->surface->format);
+			pipe_ctx->plane_state->format);
 
 	calculate_scaling_ratios(pipe_ctx);
 
@@ -846,14 +846,14 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	/* Taps calculations */
 	res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-		pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
+		pipe_ctx->xfm, &pipe_ctx->scl_data, &plane_state->scaling_quality);
 
 	if (!res) {
 		/* Try 24 bpp linebuffer */
 		pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;
 
 		res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-			pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
+			pipe_ctx->xfm, &pipe_ctx->scl_data, &plane_state->scaling_quality);
 	}
 
 	if (res)
@@ -869,10 +869,10 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 				pipe_ctx->scl_data.viewport.width,
 				pipe_ctx->scl_data.viewport.x,
 				pipe_ctx->scl_data.viewport.y,
-				surface->dst_rect.height,
-				surface->dst_rect.width,
-				surface->dst_rect.x,
-				surface->dst_rect.y);
+				plane_state->dst_rect.height,
+				plane_state->dst_rect.width,
+				plane_state->dst_rect.x,
+				plane_state->dst_rect.y);
 
 	return res;
 }
@@ -885,7 +885,7 @@ enum dc_status resource_build_scaling_params_for_context(
 	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (context->res_ctx.pipe_ctx[i].surface != NULL &&
+		if (context->res_ctx.pipe_ctx[i].plane_state != NULL &&
 				context->res_ctx.pipe_ctx[i].stream != NULL)
 			if (!resource_build_scaling_params(&context->res_ctx.pipe_ctx[i]))
 				return DC_FAIL_SCALING;
@@ -954,13 +954,13 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 	if (!head_pipe)
 		ASSERT(0);
 
-	if (!head_pipe->surface)
+	if (!head_pipe->plane_state)
 		return head_pipe;
 
 	/* Re-use pipe already acquired for this stream if available*/
 	for (i = pool->pipe_count - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
-				!res_ctx->pipe_ctx[i].surface) {
+				!res_ctx->pipe_ctx[i].plane_state) {
 			return &res_ctx->pipe_ctx[i];
 		}
 	}
@@ -987,7 +987,7 @@ static void release_free_pipes_for_stream(
 		/* never release the topmost pipe*/
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				res_ctx->pipe_ctx[i].top_pipe &&
-				!res_ctx->pipe_ctx[i].surface) {
+				!res_ctx->pipe_ctx[i].plane_state) {
 			memset(&res_ctx->pipe_ctx[i], 0, sizeof(struct pipe_ctx));
 		}
 	}
@@ -1005,7 +1005,7 @@ static int acquire_first_split_pipe(
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
 		if (pipe_ctx->top_pipe &&
-				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
+				pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state) {
 			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
 			if (pipe_ctx->bottom_pipe)
 				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
@@ -1028,7 +1028,7 @@ static int acquire_first_split_pipe(
 #endif
 
 bool resource_attach_surfaces_to_context(
-		struct dc_plane_state * const *surfaces,
+		struct dc_plane_state * const *plane_states,
 		int surface_count,
 		struct dc_stream_state *stream,
 		struct validate_context *context,
@@ -1057,25 +1057,25 @@ bool resource_attach_surfaces_to_context(
 
 	/* retain new surfaces */
 	for (i = 0; i < surface_count; i++)
-		dc_surface_retain(surfaces[i]);
+		dc_plane_state_retain(plane_states[i]);
 
 	/* detach surfaces from pipes */
 	for (i = 0; i < pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == stream) {
-			context->res_ctx.pipe_ctx[i].surface = NULL;
+			context->res_ctx.pipe_ctx[i].plane_state = NULL;
 			context->res_ctx.pipe_ctx[i].bottom_pipe = NULL;
 		}
 
 	/* release existing surfaces*/
-	for (i = 0; i < stream_status->surface_count; i++)
-		dc_surface_release(stream_status->surfaces[i]);
+	for (i = 0; i < stream_status->plane_count; i++)
+		dc_plane_state_release(stream_status->plane_states[i]);
 
-	for (i = surface_count; i < stream_status->surface_count; i++)
-		stream_status->surfaces[i] = NULL;
+	for (i = surface_count; i < stream_status->plane_count; i++)
+		stream_status->plane_states[i] = NULL;
 
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = surfaces[i];
+		struct dc_plane_state *plane_state = plane_states[i];
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
 				context, pool, stream);
 
@@ -1087,11 +1087,11 @@ bool resource_attach_surfaces_to_context(
 		}
 #endif
 		if (!free_pipe) {
-			stream_status->surfaces[i] = NULL;
+			stream_status->plane_states[i] = NULL;
 			return false;
 		}
 
-		free_pipe->surface = surface;
+		free_pipe->plane_state = plane_state;
 
 		if (tail_pipe) {
 			free_pipe->tg = tail_pipe->tg;
@@ -1110,9 +1110,9 @@ bool resource_attach_surfaces_to_context(
 
 	/* assign new surfaces*/
 	for (i = 0; i < surface_count; i++)
-		stream_status->surfaces[i] = surfaces[i];
+		stream_status->plane_states[i] = plane_states[i];
 
-	stream_status->surface_count = surface_count;
+	stream_status->plane_count = surface_count;
 
 	return true;
 }
@@ -1180,17 +1180,17 @@ bool resource_validate_attach_surfaces(
 					old_context->streams[j],
 					context->streams[i])) {
 				if (!resource_attach_surfaces_to_context(
-						old_context->stream_status[j].surfaces,
-						old_context->stream_status[j].surface_count,
+						old_context->stream_status[j].plane_states,
+						old_context->stream_status[j].plane_count,
 						context->streams[i],
 						context, pool))
 					return false;
 				context->stream_status[i] = old_context->stream_status[j];
 			}
-		if (set[i].surface_count != 0)
+		if (set[i].plane_count != 0)
 			if (!resource_attach_surfaces_to_context(
-					set[i].surfaces,
-					set[i].surface_count,
+					set[i].plane_states,
+					set[i].plane_count,
 					context->streams[i],
 					context, pool))
 				return false;
@@ -1351,13 +1351,13 @@ bool resource_is_stream_unchanged(
 static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
-	struct dc_plane_state *surface = to_pipe_ctx->surface;
+	struct dc_plane_state *plane_state = to_pipe_ctx->plane_state;
 	struct dc_stream_state *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
 	to_pipe_ctx->stream = stream;
-	if (surface != NULL)
-		to_pipe_ctx->surface = surface;
+	if (plane_state != NULL)
+		to_pipe_ctx->plane_state = plane_state;
 }
 
 static struct dc_stream_state *find_pll_sharable_stream(
@@ -2055,7 +2055,7 @@ static void set_spd_info_packet(
 
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_plane_state *surface,
+		struct dc_plane_state *plane_state,
 		struct dc_stream_state *stream)
 {
 	uint16_t i = 0;
@@ -2063,10 +2063,10 @@ static void set_hdr_static_info_packet(
 	struct dc_hdr_static_metadata hdr_metadata;
 	uint32_t data;
 
-	if (!surface)
+	if (!plane_state)
 		return;
 
-	hdr_metadata = surface->hdr_static_ctx;
+	hdr_metadata = plane_state->hdr_static_ctx;
 
 	if (!hdr_metadata.hdr_supported)
 		return;
@@ -2204,11 +2204,11 @@ void dc_resource_validate_ctx_destruct(struct validate_context *context)
 	int i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		for (j = 0; j < context->stream_status[i].surface_count; j++)
-			dc_surface_release(
-				context->stream_status[i].surfaces[j]);
+		for (j = 0; j < context->stream_status[i].plane_count; j++)
+			dc_plane_state_release(
+				context->stream_status[i].plane_states[j]);
 
-		context->stream_status[i].surface_count = 0;
+		context->stream_status[i].plane_count = 0;
 		dc_stream_release(context->streams[i]);
 		context->streams[i] = NULL;
 	}
@@ -2240,9 +2240,9 @@ void dc_resource_validate_ctx_copy_construct(
 
 	for (i = 0; i < dst_ctx->stream_count; i++) {
 		dc_stream_retain(dst_ctx->streams[i]);
-		for (j = 0; j < dst_ctx->stream_status[i].surface_count; j++)
-			dc_surface_retain(
-				dst_ctx->stream_status[i].surfaces[j]);
+		for (j = 0; j < dst_ctx->stream_status[i].plane_count; j++)
+			dc_plane_state_retain(
+				dst_ctx->stream_status[i].plane_states[j]);
 	}
 
 	/* context refcount should not be overridden */
@@ -2288,7 +2288,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
 		set_hdr_static_info_packet(&info->hdrsmd,
-				pipe_ctx->surface, pipe_ctx->stream);
+				pipe_ctx->plane_state, pipe_ctx->stream);
 
 	} else if (dc_is_dp_signal(signal)) {
 		set_vsc_info_packet(&info->vsc, pipe_ctx->stream);
@@ -2296,7 +2296,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
 		set_hdr_static_info_packet(&info->hdrsmd,
-				pipe_ctx->surface, pipe_ctx->stream);
+				pipe_ctx->plane_state, pipe_ctx->stream);
 	}
 
 	patch_gamut_packet_checksum(&info->gamut);
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 7a87f38..2b65068 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -185,7 +185,7 @@ bool dc_stream_set_cursor_attributes(
 
 		if (pipe_ctx->stream != stream || !pipe_ctx->ipp)
 			continue;
-		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
 
 		pipe_ctx->ipp->funcs->ipp_cursor_set_attributes(
@@ -229,14 +229,14 @@ bool dc_stream_set_cursor_position(
 		};
 
 		if (pipe_ctx->stream != stream ||
-				!pipe_ctx->ipp || !pipe_ctx->surface)
+				!pipe_ctx->ipp || !pipe_ctx->plane_state)
 			continue;
 
-		if (pipe_ctx->surface->address.type
+		if (pipe_ctx->plane_state->address.type
 				== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 			pos_cpy.enable = false;
 
-		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			pos_cpy.enable = false;
 
 		ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 941b367..3bcca2d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -34,75 +34,75 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static bool construct(struct dc_context *ctx, struct dc_plane_state *surface)
+static bool construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
 {
-	surface->ctx = ctx;
-	memset(&surface->hdr_static_ctx,
+	plane_state->ctx = ctx;
+	memset(&plane_state->hdr_static_ctx,
 			0, sizeof(struct dc_hdr_static_metadata));
 	return true;
 }
 
-static void destruct(struct dc_plane_state *surface)
+static void destruct(struct dc_plane_state *plane_state)
 {
-	if (surface->gamma_correction != NULL) {
-		dc_gamma_release(&surface->gamma_correction);
+	if (plane_state->gamma_correction != NULL) {
+		dc_gamma_release(&plane_state->gamma_correction);
 	}
-	if (surface->in_transfer_func != NULL) {
+	if (plane_state->in_transfer_func != NULL) {
 		dc_transfer_func_release(
-				surface->in_transfer_func);
-		surface->in_transfer_func = NULL;
+				plane_state->in_transfer_func);
+		plane_state->in_transfer_func = NULL;
 	}
 }
 
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
-void enable_surface_flip_reporting(struct dc_plane_state *surface,
+void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 		uint32_t controller_id)
 {
-	surface->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
+	plane_state->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
 	/*register_flip_interrupt(surface);*/
 }
 
-struct dc_plane_state *dc_create_surface(const struct dc *dc)
+struct dc_plane_state *dc_create_plane_state(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct dc_plane_state *surface = dm_alloc(sizeof(*surface));
+	struct dc_plane_state *plane_state = dm_alloc(sizeof(*plane_state));
 
-	if (NULL == surface)
+	if (NULL == plane_state)
 		goto alloc_fail;
 
-	if (false == construct(core_dc->ctx, surface))
+	if (false == construct(core_dc->ctx, plane_state))
 		goto construct_fail;
 
-	++surface->ref_count;
+	++plane_state->ref_count;
 
-	return surface;
+	return plane_state;
 
 construct_fail:
-	dm_free(surface);
+	dm_free(plane_state);
 
 alloc_fail:
 	return NULL;
 }
 
-const struct dc_surface_status *dc_surface_get_status(
-		const struct dc_plane_state *dc_surface)
+const struct dc_plane_status *dc_plane_get_status(
+		const struct dc_plane_state *plane_state)
 {
-	const struct dc_surface_status *surface_status;
+	const struct dc_plane_status *plane_status;
 	struct core_dc *core_dc;
 	int i;
 
-	if (!dc_surface ||
-		!dc_surface->ctx ||
-		!dc_surface->ctx->dc) {
+	if (!plane_state ||
+		!plane_state->ctx ||
+		!plane_state->ctx->dc) {
 		ASSERT(0);
 		return NULL; /* remove this if above assert never hit */
 	}
 
-	surface_status = &dc_surface->status;
-	core_dc = DC_TO_CORE(dc_surface->ctx->dc);
+	plane_status = &plane_state->status;
+	core_dc = DC_TO_CORE(plane_state->ctx->dc);
 
 	if (core_dc->current_context == NULL)
 		return NULL;
@@ -111,29 +111,29 @@ const struct dc_surface_status *dc_surface_get_status(
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != dc_surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		core_dc->hwss.update_pending_status(pipe_ctx);
 	}
 
-	return surface_status;
+	return plane_status;
 }
 
-void dc_surface_retain(struct dc_plane_state *surface)
+void dc_plane_state_retain(struct dc_plane_state *plane_state)
 {
-	ASSERT(surface->ref_count > 0);
-	++surface->ref_count;
+	ASSERT(plane_state->ref_count > 0);
+	++plane_state->ref_count;
 }
 
-void dc_surface_release(struct dc_plane_state *surface)
+void dc_plane_state_release(struct dc_plane_state *plane_state)
 {
-	ASSERT(surface->ref_count > 0);
-	--surface->ref_count;
+	ASSERT(plane_state->ref_count > 0);
+	--plane_state->ref_count;
 
-	if (surface->ref_count == 0) {
-		destruct(surface);
-		dm_free(surface);
+	if (plane_state->ref_count == 0) {
+		destruct(plane_state);
+		dm_free(plane_state);
 	}
 }
 
diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index ab805965..d1a6398 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -47,7 +47,7 @@ struct dc_caps {
 	uint32_t max_links;
 	uint32_t max_audios;
 	uint32_t max_slave_planes;
-	uint32_t max_surfaces;
+	uint32_t max_planes;
 	uint32_t max_downscale_ratio;
 	uint32_t i2c_speed_in_khz;
 
@@ -303,7 +303,7 @@ struct dc_transfer_func {
  * the last requested address and the currently active address so the called
  * can determine if there are any outstanding flips
  */
-struct dc_surface_status {
+struct dc_plane_status {
 	struct dc_plane_address requested_address;
 	struct dc_plane_address current_address;
 	bool is_flip_pending;
@@ -338,7 +338,7 @@ struct dc_plane_state {
 	bool horizontal_mirror;
 
 	/* private to DC core */
-	struct dc_surface_status status;
+	struct dc_plane_status status;
 	struct dc_context *ctx;
 
 	/* private to dc_surface.c */
@@ -385,12 +385,12 @@ struct dc_surface_update {
 /*
  * Create a new surface with default parameters;
  */
-struct dc_plane_state *dc_create_surface(const struct dc *dc);
-const struct dc_surface_status *dc_surface_get_status(
-		const struct dc_plane_state *dc_surface);
+struct dc_plane_state *dc_create_plane_state(const struct dc *dc);
+const struct dc_plane_status *dc_plane_get_status(
+		const struct dc_plane_state *plane_state);
 
-void dc_surface_retain(struct dc_plane_state *dc_surface);
-void dc_surface_release(struct dc_plane_state *dc_surface);
+void dc_plane_state_retain(struct dc_plane_state *plane_state);
+void dc_plane_state_release(struct dc_plane_state *plane_state);
 
 void dc_gamma_retain(struct dc_gamma *dc_gamma);
 void dc_gamma_release(struct dc_gamma **dc_gamma);
@@ -422,10 +422,10 @@ struct dc_flip_addrs {
  *   This does not trigger a flip.  No surface address is programmed.
  */
 
-bool dc_commit_surfaces_to_stream(
+bool dc_commit_planes_to_stream(
 		struct dc *dc,
-		struct dc_plane_state **dc_surfaces,
-		uint8_t surface_count,
+		struct dc_plane_state **plane_states,
+		uint8_t new_plane_count,
 		struct dc_stream_state *stream);
 
 bool dc_post_update_surfaces_to_stream(
@@ -469,8 +469,8 @@ enum surface_update_type {
 
 struct dc_stream_status {
 	int primary_otg_inst;
-	int surface_count;
-	struct dc_plane_state *surfaces[MAX_SURFACE_NUM];
+	int plane_count;
+	struct dc_plane_state *plane_states[MAX_SURFACE_NUM];
 
 	/*
 	 * link this stream passes through
@@ -546,7 +546,7 @@ bool dc_is_stream_unchanged(
  *
  */
 
-void dc_update_surfaces_and_stream(struct dc *dc,
+void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_surface_update *surface_updates, int surface_count,
 		struct dc_stream_state *dc_stream,
 		struct dc_stream_update *stream_update);
@@ -582,8 +582,8 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
  */
 struct dc_validation_set {
 	struct dc_stream_state *stream;
-	struct dc_plane_state *surfaces[MAX_SURFACES];
-	uint8_t surface_count;
+	struct dc_plane_state *plane_states[MAX_SURFACES];
+	uint8_t plane_count;
 };
 
 bool dc_validate_stream(const struct dc *dc, struct dc_stream_state *stream);
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
index af59ab9..8140ff3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
@@ -197,9 +197,9 @@ void dce_crtc_switch_to_clk_src(struct dce_hwseq *hws,
 }
 
 /* Only use LUT for 8 bit formats */
-bool dce_use_lut(const struct dc_plane_state *surface)
+bool dce_use_lut(const struct dc_plane_state *plane_state)
 {
-	switch (surface->format) {
+	switch (plane_state->format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		return true;
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
index d5cb98a..a0531b3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
@@ -552,5 +552,5 @@ void dce_crtc_switch_to_clk_src(struct dce_hwseq *hws,
 		struct clock_source *clk_src,
 		unsigned int tg_inst);
 
-bool dce_use_lut(const struct dc_plane_state *surface);
+bool dce_use_lut(const struct dc_plane_state *plane_state);
 #endif   /*__DCE_HWSEQ_H__*/
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
index 98fb7f0..46f0c71 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
@@ -705,13 +705,13 @@ static bool dce100_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -958,7 +958,7 @@ static bool construct(
 		}
 	}
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e4310a3..ea9ce87 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -215,11 +215,11 @@ static bool dce110_enable_display_power_gating(
 }
 
 static void build_prescale_params(struct ipp_prescale_params *prescale_params,
-		const struct dc_plane_state *surface)
+		const struct dc_plane_state *plane_state)
 {
 	prescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;
 
-	switch (surface->format) {
+	switch (plane_state->format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		prescale_params->scale = 0x2020;
@@ -240,7 +240,7 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 
 static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct dc_plane_state *surface)
+	const struct dc_plane_state *plane_state)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -250,14 +250,14 @@ static bool dce110_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->in_transfer_func)
-		tf = surface->in_transfer_func;
+	if (plane_state->in_transfer_func)
+		tf = plane_state->in_transfer_func;
 
-	build_prescale_params(&prescale_params, surface);
+	build_prescale_params(&prescale_params, plane_state);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (surface->gamma_correction && dce_use_lut(surface))
-		ipp->funcs->ipp_program_input_lut(ipp, surface->gamma_correction);
+	if (plane_state->gamma_correction && dce_use_lut(plane_state))
+		ipp->funcs->ipp_program_input_lut(ipp, plane_state->gamma_correction);
 
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */
@@ -1119,7 +1119,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	if ((!pipe_ctx_old ||
 	     memcmp(&pipe_ctx_old->scl_data, &pipe_ctx->scl_data,
 		    sizeof(struct scaler_data)) != 0) &&
-	     pipe_ctx->surface) {
+	     pipe_ctx->plane_state) {
 		program_scaler(dc, pipe_ctx);
 	}
 
@@ -1916,11 +1916,11 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 	struct default_adjustment default_adjust = { 0 };
 
 	default_adjust.force_hw_default = false;
-	if (pipe_ctx->surface == NULL)
+	if (pipe_ctx->plane_state == NULL)
 		default_adjust.in_color_space = COLOR_SPACE_SRGB;
 	else
 		default_adjust.in_color_space =
-				pipe_ctx->surface->color_space;
+				pipe_ctx->plane_state->color_space;
 	if (pipe_ctx->stream == NULL)
 		default_adjust.out_color_space = COLOR_SPACE_SRGB;
 	else
@@ -1971,16 +1971,16 @@ static void program_surface_visibility(const struct core_dc *dc,
 		/* For now we are supporting only two pipes */
 		ASSERT(pipe_ctx->bottom_pipe->bottom_pipe == NULL);
 
-		if (pipe_ctx->bottom_pipe->surface->visible) {
-			if (pipe_ctx->surface->visible)
+		if (pipe_ctx->bottom_pipe->plane_state->visible) {
+			if (pipe_ctx->plane_state->visible)
 				blender_mode = BLND_MODE_BLENDING;
 			else
 				blender_mode = BLND_MODE_OTHER_PIPE;
 
-		} else if (!pipe_ctx->surface->visible)
+		} else if (!pipe_ctx->plane_state->visible)
 			blank_target = true;
 
-	} else if (!pipe_ctx->surface->visible)
+	} else if (!pipe_ctx->plane_state->visible)
 		blank_target = true;
 
 	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
@@ -2038,7 +2038,7 @@ static void set_plane_config(
 	struct resource_context *res_ctx)
 {
 	struct mem_input *mi = pipe_ctx->mi;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2103,57 +2103,57 @@ static void set_plane_config(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->format,
-			&surface->tiling_info,
-			&surface->plane_size,
-			surface->rotation,
+			plane_state->format,
+			&plane_state->tiling_info,
+			&plane_state->plane_size,
+			plane_state->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
+		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 }
 
 static void update_plane_addr(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->address,
-			surface->flip_immediate);
+			&plane_state->address,
+			plane_state->flip_immediate);
 
-	surface->status.requested_address = surface->address;
+	plane_state->status.requested_address = plane_state->address;
 }
 
 void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
-	surface->status.is_flip_pending =
+	plane_state->status.is_flip_pending =
 			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->mi);
 
-	if (surface->status.is_flip_pending && !surface->visible)
+	if (plane_state->status.is_flip_pending && !plane_state->visible)
 		pipe_ctx->mi->current_address = pipe_ctx->mi->request_address;
 
-	surface->status.current_address = pipe_ctx->mi->current_address;
+	plane_state->status.current_address = pipe_ctx->mi->current_address;
 	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			pipe_ctx->tg->funcs->is_stereo_left_eye) {
-		surface->status.is_right_eye =\
+		plane_state->status.is_right_eye =\
 				!pipe_ctx->tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
 	}
 }
@@ -2490,7 +2490,7 @@ static void dce110_program_front_end_for_pipe(
 {
 	struct mem_input *mi = pipe_ctx->mi;
 	struct pipe_ctx *old_pipe = NULL;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2558,21 +2558,21 @@ static void dce110_program_front_end_for_pipe(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->format,
-			&surface->tiling_info,
-			&surface->plane_size,
-			surface->rotation,
+			plane_state->format,
+			&plane_state->tiling_info,
+			&plane_state->plane_size,
+			plane_state->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
+		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe:%d 0x%x: addr hi:0x%x, "
@@ -2581,21 +2581,21 @@ static void dce110_program_front_end_for_pipe(
 			" %d; dst: %d, %d, %d, %d;"
 			"clip: %d, %d, %d, %d\n",
 			pipe_ctx->pipe_idx,
-			pipe_ctx->surface,
-			pipe_ctx->surface->address.grph.addr.high_part,
-			pipe_ctx->surface->address.grph.addr.low_part,
-			pipe_ctx->surface->src_rect.x,
-			pipe_ctx->surface->src_rect.y,
-			pipe_ctx->surface->src_rect.width,
-			pipe_ctx->surface->src_rect.height,
-			pipe_ctx->surface->dst_rect.x,
-			pipe_ctx->surface->dst_rect.y,
-			pipe_ctx->surface->dst_rect.width,
-			pipe_ctx->surface->dst_rect.height,
-			pipe_ctx->surface->clip_rect.x,
-			pipe_ctx->surface->clip_rect.y,
-			pipe_ctx->surface->clip_rect.width,
-			pipe_ctx->surface->clip_rect.height);
+			pipe_ctx->plane_state,
+			pipe_ctx->plane_state->address.grph.addr.high_part,
+			pipe_ctx->plane_state->address.grph.addr.low_part,
+			pipe_ctx->plane_state->src_rect.x,
+			pipe_ctx->plane_state->src_rect.y,
+			pipe_ctx->plane_state->src_rect.width,
+			pipe_ctx->plane_state->src_rect.height,
+			pipe_ctx->plane_state->dst_rect.x,
+			pipe_ctx->plane_state->dst_rect.y,
+			pipe_ctx->plane_state->dst_rect.width,
+			pipe_ctx->plane_state->dst_rect.height,
+			pipe_ctx->plane_state->clip_rect.x,
+			pipe_ctx->plane_state->clip_rect.y,
+			pipe_ctx->plane_state->clip_rect.width,
+			pipe_ctx->plane_state->clip_rect.height);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe %d: width, height, x, y\n"
@@ -2614,19 +2614,18 @@ static void dce110_program_front_end_for_pipe(
 
 static void dce110_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_plane_state *surface,
+		const struct dc_plane_state *plane_state,
 		struct validate_context *context)
 {
 	int i;
 
-	/* TODO remove when removing the surface reset workaroud*/
-	if (!surface)
+	if (!plane_state)
 		return;
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index 89b21bd..f580da1b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -764,9 +764,9 @@ static bool is_surface_pixel_format_supported(struct pipe_ctx *pipe_ctx, unsigne
 {
 	if (pipe_ctx->pipe_idx != underlay_idx)
 		return true;
-	if (!pipe_ctx->surface)
+	if (!pipe_ctx->plane_state)
 		return false;
-	if (pipe_ctx->surface->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
+	if (pipe_ctx->plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 		return false;
 	return true;
 }
@@ -901,22 +901,22 @@ static bool dce110_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 2)
+		if (set[i].plane_count > 2)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 
-		if (set[i].surface_count == 2) {
-			if (set[i].surfaces[1]->format
+		if (set[i].plane_count == 2) {
+			if (set[i].plane_states[1]->format
 					< SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 				return false;
-			if (set[i].surfaces[1]->src_rect.width > 1920
-					|| set[i].surfaces[1]->src_rect.height > 1080)
+			if (set[i].plane_states[1]->src_rect.width > 1920
+					|| set[i].plane_states[1]->src_rect.height > 1080)
 				return false;
 
 			if (set[i].stream->timing.pixel_encoding != PIXEL_ENCODING_RGB)
@@ -1351,7 +1351,7 @@ static bool construct(
 	if (!dce110_hw_sequencer_construct(dc))
 		goto res_create_fail;
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, dc->ctx->asic_id);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
index 68554d6..420434d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -889,13 +889,13 @@ static bool dce112_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -1319,7 +1319,7 @@ static bool construct(
 			  &res_create_funcs))
 		goto res_create_fail;
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	/* Create hardware sequencer */
 	if (!dce112_hw_sequencer_construct(dc))
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
index 45f5fd6..6448d15 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
@@ -982,7 +982,7 @@ static bool construct(
 	if (!dce120_hw_sequencer_create(dc))
 		goto controller_create_fail;
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, dc->ctx->asic_id);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 734b35e..7473f585 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -722,13 +722,13 @@ static bool dce80_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -959,7 +959,7 @@ static bool construct(
 		}
 	}
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 866f63d..5922cf8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -986,7 +986,7 @@ static void reset_hw_ctx_wrap(
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx->stream ||
-				!pipe_ctx->surface ||
+				!pipe_ctx->plane_state ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 
 			plane_atomic_disconnect(dc, i);
@@ -1010,13 +1010,13 @@ static void reset_hw_ctx_wrap(
 		/*if (!pipe_ctx_old->stream)
 			continue;*/
 
-		if (pipe_ctx->stream && pipe_ctx->surface
+		if (pipe_ctx->stream && pipe_ctx->plane_state
 				&& !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
 			continue;
 
 		plane_atomic_disable(dc, i);
 
-		if (!pipe_ctx->stream || !pipe_ctx->surface)
+		if (!pipe_ctx->stream || !pipe_ctx->plane_state)
 			plane_atomic_power_down(dc, i);
 	}
 
@@ -1038,24 +1038,24 @@ static void reset_hw_ctx_wrap(
 static bool patch_address_for_sbs_tb_stereo(
 		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
-			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
-	if (sec_split && surface->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
+	if (sec_split && plane_state->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 		(pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
 		 pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
-		*addr = surface->address.grph_stereo.left_addr;
-		surface->address.grph_stereo.left_addr =
-		surface->address.grph_stereo.right_addr;
+		*addr = plane_state->address.grph_stereo.left_addr;
+		plane_state->address.grph_stereo.left_addr =
+		plane_state->address.grph_stereo.right_addr;
 		return true;
 	} else {
 		if (pipe_ctx->stream->view_format != VIEW_3D_FORMAT_NONE &&
-			surface->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
-			surface->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
-			surface->address.grph_stereo.right_addr =
-			surface->address.grph_stereo.left_addr;
+			plane_state->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
+			plane_state->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
+			plane_state->address.grph_stereo.right_addr =
+			plane_state->address.grph_stereo.left_addr;
 		}
 	}
 	return false;
@@ -1065,22 +1065,22 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->address,
-			surface->flip_immediate);
-	surface->status.requested_address = surface->address;
+			&plane_state->address,
+			plane_state->flip_immediate);
+	plane_state->status.requested_address = plane_state->address;
 	if (addr_patched)
-		pipe_ctx->surface->address.grph_stereo.left_addr = addr;
+		pipe_ctx->plane_state->address.grph_stereo.left_addr = addr;
 }
 
 static bool dcn10_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *surface)
+	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -1089,12 +1089,12 @@ static bool dcn10_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->in_transfer_func)
-		tf = surface->in_transfer_func;
+	if (plane_state->in_transfer_func)
+		tf = plane_state->in_transfer_func;
 
-	if (surface->gamma_correction && dce_use_lut(surface))
+	if (plane_state->gamma_correction && dce_use_lut(plane_state))
 		ipp->funcs->ipp_program_input_lut(ipp,
-				surface->gamma_correction);
+				plane_state->gamma_correction);
 
 	if (tf == NULL)
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
@@ -1689,7 +1689,7 @@ static void dcn10_power_on_fe(
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
-	struct dc_plane_state *dc_surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dce_hwseq *hws = dc->hwseq;
 
 	power_on_plane(dc->hwseq,
@@ -1704,24 +1704,24 @@ static void dcn10_power_on_fe(
 			OPP_PIPE_CLOCK_EN, 1);
 	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
-	if (dc_surface) {
+	if (plane_state) {
 		dm_logger_write(dc->ctx->logger, LOG_DC,
 				"Pipe:%d 0x%x: addr hi:0x%x, "
 				"addr low:0x%x, "
 				"src: %d, %d, %d,"
 				" %d; dst: %d, %d, %d, %d;\n",
 				pipe_ctx->pipe_idx,
-				dc_surface,
-				dc_surface->address.grph.addr.high_part,
-				dc_surface->address.grph.addr.low_part,
-				dc_surface->src_rect.x,
-				dc_surface->src_rect.y,
-				dc_surface->src_rect.width,
-				dc_surface->src_rect.height,
-				dc_surface->dst_rect.x,
-				dc_surface->dst_rect.y,
-				dc_surface->dst_rect.width,
-				dc_surface->dst_rect.height);
+				plane_state,
+				plane_state->address.grph.addr.high_part,
+				plane_state->address.grph.addr.low_part,
+				plane_state->src_rect.x,
+				plane_state->src_rect.y,
+				plane_state->src_rect.width,
+				plane_state->src_rect.height,
+				plane_state->dst_rect.x,
+				plane_state->dst_rect.y,
+				plane_state->dst_rect.width,
+				plane_state->dst_rect.height);
 
 		dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
 				"Pipe %d: width, height, x, y\n"
@@ -1805,7 +1805,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
 		return true;
@@ -1814,7 +1814,7 @@ static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1823,7 +1823,7 @@ static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1898,12 +1898,12 @@ static void update_dchubp_dpp(
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->mi;
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
-	struct dc_plane_state *surface = pipe_ctx->surface;
-	union plane_size size = surface->plane_size;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
+	union plane_size size = plane_state->plane_size;
 	struct default_adjustment ocsc = {0};
 	struct mpcc_cfg mpcc_cfg = {0};
 	struct pipe_ctx *top_pipe;
-	bool per_pixel_alpha = surface->per_pixel_alpha && pipe_ctx->bottom_pipe;
+	bool per_pixel_alpha = plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
 
 	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
@@ -1936,12 +1936,12 @@ static void update_dchubp_dpp(
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 
 	ipp->funcs->ipp_setup(ipp,
-			surface->format,
+			plane_state->format,
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
@@ -1982,12 +1982,12 @@ static void update_dchubp_dpp(
 
 	mi->funcs->mem_input_program_surface_config(
 		mi,
-		surface->format,
-		&surface->tiling_info,
+		plane_state->format,
+		&plane_state->tiling_info,
 		&size,
-		surface->rotation,
-		&surface->dcc,
-		surface->horizontal_mirror);
+		plane_state->rotation,
+		&plane_state->dcc,
+		plane_state->horizontal_mirror);
 
 	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
 }
@@ -2025,7 +2025,7 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !is_pipe_tree_visible(pipe_ctx));
 	}
 
-	if (pipe_ctx->surface != NULL) {
+	if (pipe_ctx->plane_state != NULL) {
 		dcn10_power_on_fe(dc, pipe_ctx, context);
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}
@@ -2068,7 +2068,7 @@ static void dcn10_pplib_apply_display_requirements(
 
 static void dcn10_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_plane_state *surface,
+		const struct dc_plane_state *plane_state,
 		struct validate_context *context)
 {
 	int i, be_idx;
@@ -2076,11 +2076,11 @@ static void dcn10_apply_ctx_for_surface(
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
-	if (!surface)
+	if (!plane_state)
 		return;
 
 	for (be_idx = 0; be_idx < dc->res_pool->pipe_count; be_idx++)
-		if (surface == context->res_ctx.pipe_ctx[be_idx].surface)
+		if (plane_state == context->res_ctx.pipe_ctx[be_idx].plane_state)
 			break;
 
 	/* reset unused mpcc */
@@ -2089,7 +2089,7 @@ static void dcn10_apply_ctx_for_surface(
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (!pipe_ctx->surface && !old_pipe_ctx->surface)
+		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
 			continue;
 
 		/*
@@ -2097,7 +2097,7 @@ static void dcn10_apply_ctx_for_surface(
 		 * fairly hacky right now, using opp_id as indicator
 		 */
 
-		if (pipe_ctx->surface && !old_pipe_ctx->surface) {
+		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
 			if (pipe_ctx->mi->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 				/*
@@ -2109,7 +2109,7 @@ static void dcn10_apply_ctx_for_surface(
 		}
 
 
-		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
+		if ((!pipe_ctx->plane_state && old_pipe_ctx->plane_state)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
 			if (old_pipe_ctx->tg->inst != be_idx)
 				continue;
@@ -2135,7 +2135,7 @@ static void dcn10_apply_ctx_for_surface(
 
 			old_pipe_ctx->top_pipe = NULL;
 			old_pipe_ctx->bottom_pipe = NULL;
-			old_pipe_ctx->surface = NULL;
+			old_pipe_ctx->plane_state = NULL;
 
 			dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset mpcc for pipe %d\n",
@@ -2146,7 +2146,7 @@ static void dcn10_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		/* looking for top pipe to program */
@@ -2468,34 +2468,34 @@ static bool dcn10_dummy_display_power_gating(
 
 void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct timing_generator *tg = pipe_ctx->tg;
 
-	if (surface->ctx->dc->debug.sanity_checks) {
-		struct core_dc *dc = DC_TO_CORE(surface->ctx->dc);
+	if (plane_state->ctx->dc->debug.sanity_checks) {
+		struct core_dc *dc = DC_TO_CORE(plane_state->ctx->dc);
 
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
-	surface->status.is_flip_pending =
+	plane_state->status.is_flip_pending =
 			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->mi);
 
 	/* DCN we read INUSE address in MI, do we still need this wa? */
-	if (surface->status.is_flip_pending &&
-			!surface->visible) {
+	if (plane_state->status.is_flip_pending &&
+			!plane_state->visible) {
 		pipe_ctx->mi->current_address =
 				pipe_ctx->mi->request_address;
 		BREAK_TO_DEBUGGER();
 	}
 
-	surface->status.current_address = pipe_ctx->mi->current_address;
+	plane_state->status.current_address = pipe_ctx->mi->current_address;
 	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
-		surface->status.is_right_eye =
+		plane_state->status.is_right_eye =
 				!tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
 	}
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
index 5a9fcbc..3fe6df9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -1406,7 +1406,7 @@ static bool construct(
 			goto res_create_fail;
 
 	dcn10_hw_sequencer_construct(dc);
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	dc->public.cap_funcs = cap_funcs;
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index d5c0f9e..3b3330c 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -36,7 +36,7 @@
 
 #define MAX_CLOCK_SOURCES 7
 
-void enable_surface_flip_reporting(struct dc_plane_state *dc_surface,
+void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 		uint32_t controller_id);
 
 #include "grph_object_id.h"
@@ -153,7 +153,7 @@ struct resource_pool {
 };
 
 struct pipe_ctx {
-	struct dc_plane_state *surface;
+	struct dc_plane_state *plane_state;
 	struct dc_stream_state *stream;
 
 	struct mem_input *mi;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
index 7e03f8d..5d075f9 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
@@ -59,7 +59,7 @@ struct hw_sequencer_funcs {
 
 	void (*apply_ctx_for_surface)(
 			struct core_dc *dc,
-			const struct dc_plane_state *surface,
+			const struct dc_plane_state *plane_state,
 			struct validate_context *context);
 
 	void (*set_plane_config)(
@@ -88,7 +88,7 @@ struct hw_sequencer_funcs {
 
 	bool (*set_input_transfer_func)(
 				struct pipe_ctx *pipe_ctx,
-				const struct dc_plane_state *surface);
+				const struct dc_plane_state *plane_state);
 
 	bool (*set_output_transfer_func)(
 				struct pipe_ctx *pipe_ctx,
diff --git a/drivers/gpu/drm/amd/display/dc/inc/resource.h b/drivers/gpu/drm/amd/display/dc/inc/resource.h
index aef1197..7f30d99 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/resource.h
@@ -119,7 +119,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct dc_stream_state *stream);
 
 bool resource_attach_surfaces_to_context(
-		struct dc_plane_state *const *surfaces,
+		struct dc_plane_state *const *plane_state,
 		int surface_count,
 		struct dc_stream_state *dc_stream,
 		struct validate_context *context,
diff --git a/drivers/gpu/drm/amd/display/include/logger_interface.h b/drivers/gpu/drm/amd/display/include/logger_interface.h
index 0e978d9..beb7909 100644
--- a/drivers/gpu/drm/amd/display/include/logger_interface.h
+++ b/drivers/gpu/drm/amd/display/include/logger_interface.h
@@ -77,7 +77,7 @@ void logger_write(struct dal_logger *logger,
 
 void pre_surface_trace(
 		const struct dc *dc,
-		const struct dc_plane_state *const *surfaces,
+		const struct dc_plane_state *const *plane_states,
 		int surface_count);
 
 void update_surface_trace(
-- 
2.7.4

