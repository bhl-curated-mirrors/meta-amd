From 17900480aee05aa17c77f3ffc2149fc1a25bdaa6 Mon Sep 17 00:00:00 2001
From: Sudheesh Mavila <sudheesh.mavila@amd.com>
Date: Sat, 22 Jan 2022 22:33:28 +0530
Subject: [PATCH 24/48] phy aqr113 support on fox platform v1

Signed-off-by: Sudheesh Mavila <sudheesh.mavila@amd.com>
Signed-off-by: rgaridap <Ramesh.Garidapuri@amd.com>
Change-Id: If8c9c02d13577a62c4256bfe4c0a9c808146f3bd
---
 drivers/net/phy/aquantia_main.c | 131 +++++++++++++++++++++++++++++++-
 1 file changed, 130 insertions(+), 1 deletion(-)
 mode change 100644 => 100755 drivers/net/phy/aquantia_main.c

diff --git a/drivers/net/phy/aquantia_main.c b/drivers/net/phy/aquantia_main.c
old mode 100644
new mode 100755
index 968dd43a2b1e..b885deb58271
--- a/drivers/net/phy/aquantia_main.c
+++ b/drivers/net/phy/aquantia_main.c
@@ -22,6 +22,7 @@
 #define PHY_ID_AQR107	0x03a1b4e0
 #define PHY_ID_AQCS109	0x03a1b5c2
 #define PHY_ID_AQR405	0x03a1b4b0
+#define PHY_ID_AQR113   0x31c31c12
 
 #define MDIO_PHYXS_VEND_IF_STATUS		0xe812
 #define MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK	GENMASK(7, 3)
@@ -242,6 +243,84 @@ static int aqr_config_aneg(struct phy_device *phydev)
 	return genphy_c45_check_and_restart_aneg(phydev, changed);
 }
 
+
+#define SERDES_MODE_SGMII 0X3
+
+static int aqr113_config_aneg(struct phy_device *phydev)
+{
+	int val,ret;
+	int fw;
+	int build;
+
+	fw = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_FW_ID);
+	if (fw < 0)
+		return val;
+	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_RSVD_STAT1);
+	if (val < 0)
+		return val;
+
+	build = FIELD_GET(GENMASK(7,0), val);
+	if ((fw == 0x506) && (build = 0x16)) {
+		phydev->autoneg = AUTONEG_ENABLE;
+
+		if (linkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, phydev->advertising))
+			phydev->interface = PHY_INTERFACE_MODE_SGMII;
+		if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, phydev->advertising))
+			phydev->interface = PHY_INTERFACE_MODE_SGMII;
+		if (linkmode_test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, phydev->advertising))
+			phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
+		if (linkmode_test_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, phydev->advertising))
+			phydev->interface = PHY_INTERFACE_MODE_10GBASER;
+
+		if (phydev->interface == PHY_INTERFACE_MODE_SGMII ) {
+			/* set PHY in SGMI mode for 100M with system side AN */
+			val = phy_read_mmd(phydev, 0x1e, 0x31b);
+			val =  val & (~0x7);
+			val = val | SERDES_MODE_SGMII | (1 << 3) | (1 <<5 );
+			phy_write_mmd(phydev, 0x1e, 0x31b,val);
+
+			/* set PHY in SGMI mode for 1000M with system side AN */
+			val = phy_read_mmd(phydev, 0x1e, 0x31c);
+			val =  val & (~0x7);
+			val = val | SERDES_MODE_SGMII | (1 << 3)| (1 << 5);
+			phy_write_mmd(phydev, 0x1e, 0x31c,val);
+			/* clear 2.5G and 5G support */
+			val = phy_read_mmd(phydev, 0x7, 0xc400);
+			val =  val & (~( 1<<0xa | 1<< 0xb));
+			phy_write_mmd(phydev, 0x7, 0xc400,val);
+		}
+
+		if (phydev->interface == PHY_INTERFACE_MODE_2500BASEX ){
+			/* set PHY in SGMI mode for 2500M with system side AN */
+			val = phy_read_mmd(phydev, 0x1e, 0x31d);
+			val =  val & (~0x7);
+			val = val | 0x4 | (1 << 3)| (1 << 5);
+			phy_write_mmd(phydev, 0x1e, 0x31d,val);
+
+			/* clear 5G support */
+			val = phy_read_mmd(phydev, 0x7, 0xc400);
+			val =  val & (~( 1<< 0xb));
+			phy_write_mmd(phydev, 0x7, 0xc400,val);
+		}
+
+		if (phydev->interface == PHY_INTERFACE_MODE_10GBASER ){
+			val = phy_read_mmd(phydev, 0x1e, 0x31b);
+			val =  val & (~0xf);
+			ret = phy_write_mmd(phydev, 0x1e, 0x31b,val);
+			val = phy_read_mmd(phydev, 0x1e, 0x31c);
+			val =  val & (~0xf);
+			phy_write_mmd(phydev, 0x1e, 0x31c,val);
+
+			val = phy_read_mmd(phydev, 0x1e, 0x31F);
+			val =  val & (~0xF);
+			phy_write_mmd(phydev, 0x1e, 0x31F,val);
+		}
+	}
+
+	return aqr_config_aneg(phydev);
+}
+
+
 static int aqr_config_intr(struct phy_device *phydev)
 {
 	bool en = phydev->interrupts == PHY_INTERRUPT_ENABLED;
@@ -396,7 +475,10 @@ static int aqr107_read_status(struct phy_device *phydev)
 	}
 
 	/* Read possibly downshifted rate from vendor register */
-	return aqr107_read_rate(phydev);
+	ret = aqr107_read_rate(phydev);
+	phydev_dbg(phydev, "link_status %d  AN = %d  mode = %d  speed = %d",phydev->link,phydev->autoneg, phydev->interface, phydev->speed);
+
+	return ret;
 }
 
 static int aqr107_get_downshift(struct phy_device *phydev, u8 *data)
@@ -516,6 +598,28 @@ static int aqr107_config_init(struct phy_device *phydev)
 	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
 }
 
+
+static int aqr113_config_init(struct phy_device *phydev)
+{
+	int ret;
+
+	/* Check that the PHY interface type is compatible */
+	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&
+	    phydev->interface != PHY_INTERFACE_MODE_10GBASER)
+		return -ENODEV;
+
+	WARN(phydev->interface == PHY_INTERFACE_MODE_10GKR,
+	     "Your devicetree is out of date, please update it. The AQR113 family doesn't support 10GKR, maybe you mean 10GBASER.\n");
+
+	ret = aqr107_wait_reset_complete(phydev);
+	if (!ret)
+		aqr107_chip_info(phydev);
+
+
+	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
+}
+
 static int aqcs109_config_init(struct phy_device *phydev)
 {
 	int ret;
@@ -607,6 +711,17 @@ static int aqr107_probe(struct phy_device *phydev)
 	return aqr_hwmon_probe(phydev);
 }
 
+static int aqr113_probe(struct phy_device *phydev)
+{
+
+	phydev->priv = devm_kzalloc(&phydev->mdio.dev,
+				    sizeof(struct aqr107_priv), GFP_KERNEL);
+	if (!phydev->priv)
+		return -ENOMEM;
+
+	return aqr_hwmon_probe(phydev);
+}
+
 static struct phy_driver aqr_driver[] = {
 {
 	PHY_ID_MATCH_MODEL(PHY_ID_AQ1202),
@@ -660,6 +775,19 @@ static struct phy_driver aqr_driver[] = {
 	.get_stats	= aqr107_get_stats,
 	.link_change_notify = aqr107_link_change_notify,
 },
+
+{
+	PHY_ID_MATCH_MODEL(PHY_ID_AQR113),
+	.name		= "Aquantia AQR113",
+	.probe		= aqr113_probe,
+	.config_init	= aqr113_config_init,
+	.config_aneg    = aqr113_config_aneg,
+	.read_status	= aqr107_read_status,
+	.suspend	= aqr107_suspend,
+	.resume		= aqr107_resume,
+	.get_stats	= aqr107_get_stats,
+},
+
 {
 	PHY_ID_MATCH_MODEL(PHY_ID_AQCS109),
 	.name		= "Aquantia AQCS109",
@@ -696,6 +824,7 @@ static struct mdio_device_id __maybe_unused aqr_tbl[] = {
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR105) },
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR106) },
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR107) },
+	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113) },
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQCS109) },
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR405) },
 	{ }
-- 
2.27.0

