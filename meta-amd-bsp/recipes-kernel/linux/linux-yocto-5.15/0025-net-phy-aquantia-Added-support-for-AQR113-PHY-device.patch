From b1e442757132564096bc76d751e3325d8e86c2eb Mon Sep 17 00:00:00 2001
From: rgaridap <Ramesh.Garidapuri@amd.com>
Date: Tue, 26 Apr 2022 20:55:38 +0530
Subject: [PATCH 25/48] net: phy: aquantia: Added support for AQR113 PHY device

Add support for AQR113 family

Signed-off-by: rgaridap <Ramesh.Garidapuri@amd.com>
Change-Id: I5bb7940fb90f57ea9a6315331318ca9b042cef75
---
 drivers/net/phy/aquantia_main.c | 115 ++++++++++++++++----------------
 1 file changed, 58 insertions(+), 57 deletions(-)

diff --git a/drivers/net/phy/aquantia_main.c b/drivers/net/phy/aquantia_main.c
index b885deb58271..a16bfc591767 100755
--- a/drivers/net/phy/aquantia_main.c
+++ b/drivers/net/phy/aquantia_main.c
@@ -242,15 +242,13 @@ static int aqr_config_aneg(struct phy_device *phydev)
 
 	return genphy_c45_check_and_restart_aneg(phydev, changed);
 }
-
-
-#define SERDES_MODE_SGMII 0X3
-
-static int aqr113_config_aneg(struct phy_device *phydev)
+static int aqr113_set_mode(struct phy_device *phydev)
 {
-	int val,ret;
+
+	int val;
 	int fw;
 	int build;
+	int system_an;
 
 	fw = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_FW_ID);
 	if (fw < 0)
@@ -260,67 +258,52 @@ static int aqr113_config_aneg(struct phy_device *phydev)
 		return val;
 
 	build = FIELD_GET(GENMASK(7,0), val);
+
 	if ((fw == 0x506) && (build = 0x16)) {
-		phydev->autoneg = AUTONEG_ENABLE;
 
-		if (linkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, phydev->advertising))
-			phydev->interface = PHY_INTERFACE_MODE_SGMII;
+		/* set PHY in SGMI mode for 1000M with system side AN disabled*/
+		val = phy_read_mmd(phydev, 0x7, 0xc400);
 		if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, phydev->advertising))
-			phydev->interface = PHY_INTERFACE_MODE_SGMII;
+			val =  val | (3 << 0xe);
+		else
+			 val =  val & (~( 3<< 0xe));
+		phy_write_mmd(phydev, 0x7, 0xc400,val);
+
+
+		/* set PHY in SGMI mode for 2500M with system side AN disabled */
+		val = phy_read_mmd(phydev, 0x7, 0xc400);
 		if (linkmode_test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, phydev->advertising))
-			phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
+			val =  val | (1 << 0xa);
+		else
+			val =  val & (~( 1<< 0xa));
+		phy_write_mmd(phydev, 0x7, 0xc400,val);
+
+	/* clear 5G support */
+		val = phy_read_mmd(phydev, 0x7, 0xc400);
+		val =  val & (~( 1<< 0xb));
+		phy_write_mmd(phydev, 0x7, 0xc400,val);
+
+
+		val = phy_read_mmd(phydev, 0x7, 0x20);
 		if (linkmode_test_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, phydev->advertising))
-			phydev->interface = PHY_INTERFACE_MODE_10GBASER;
-
-		if (phydev->interface == PHY_INTERFACE_MODE_SGMII ) {
-			/* set PHY in SGMI mode for 100M with system side AN */
-			val = phy_read_mmd(phydev, 0x1e, 0x31b);
-			val =  val & (~0x7);
-			val = val | SERDES_MODE_SGMII | (1 << 3) | (1 <<5 );
-			phy_write_mmd(phydev, 0x1e, 0x31b,val);
-
-			/* set PHY in SGMI mode for 1000M with system side AN */
-			val = phy_read_mmd(phydev, 0x1e, 0x31c);
-			val =  val & (~0x7);
-			val = val | SERDES_MODE_SGMII | (1 << 3)| (1 << 5);
-			phy_write_mmd(phydev, 0x1e, 0x31c,val);
-			/* clear 2.5G and 5G support */
-			val = phy_read_mmd(phydev, 0x7, 0xc400);
-			val =  val & (~( 1<<0xa | 1<< 0xb));
-			phy_write_mmd(phydev, 0x7, 0xc400,val);
-		}
-
-		if (phydev->interface == PHY_INTERFACE_MODE_2500BASEX ){
-			/* set PHY in SGMI mode for 2500M with system side AN */
-			val = phy_read_mmd(phydev, 0x1e, 0x31d);
-			val =  val & (~0x7);
-			val = val | 0x4 | (1 << 3)| (1 << 5);
-			phy_write_mmd(phydev, 0x1e, 0x31d,val);
-
-			/* clear 5G support */
-			val = phy_read_mmd(phydev, 0x7, 0xc400);
-			val =  val & (~( 1<< 0xb));
-			phy_write_mmd(phydev, 0x7, 0xc400,val);
-		}
-
-		if (phydev->interface == PHY_INTERFACE_MODE_10GBASER ){
-			val = phy_read_mmd(phydev, 0x1e, 0x31b);
-			val =  val & (~0xf);
-			ret = phy_write_mmd(phydev, 0x1e, 0x31b,val);
-			val = phy_read_mmd(phydev, 0x1e, 0x31c);
-			val =  val & (~0xf);
-			phy_write_mmd(phydev, 0x1e, 0x31c,val);
-
-			val = phy_read_mmd(phydev, 0x1e, 0x31F);
-			val =  val & (~0xF);
-			phy_write_mmd(phydev, 0x1e, 0x31F,val);
-		}
+			val =  val | (1 << 0xc);
+		else
+			val =  val & (~( 1<< 0xc));
+		phy_write_mmd(phydev, 0x7, 0x20,val);
+
 	}
+	return 0;
+}
 
+
+#define SERDES_MODE_SGMII 0X3
+
+static int aqr113_config_aneg(struct phy_device *phydev)
+{
+    aqr113_set_mode(phydev);
 	return aqr_config_aneg(phydev);
 }
 
-
 static int aqr_config_intr(struct phy_device *phydev)
 {
 	bool en = phydev->interrupts == PHY_INTERRUPT_ENABLED;
@@ -602,6 +585,7 @@ static int aqr107_config_init(struct phy_device *phydev)
 static int aqr113_config_init(struct phy_device *phydev)
 {
 	int ret;
+	int val;
 
 	/* Check that the PHY interface type is compatible */
 	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
@@ -616,6 +600,10 @@ static int aqr113_config_init(struct phy_device *phydev)
 	if (!ret)
 		aqr107_chip_info(phydev);
 
+	/* clear 5G support */
+	val = phy_read_mmd(phydev, 0x7, 0xc400);
+	val =  val & (~( 1<< 0xb));
+	phy_write_mmd(phydev, 0x7, 0xc400,val);
 
 	return aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);
 }
@@ -806,6 +794,18 @@ static struct phy_driver aqr_driver[] = {
 	.get_stats	= aqr107_get_stats,
 	.link_change_notify = aqr107_link_change_notify,
 },
+
+{
+	 PHY_ID_MATCH_MODEL(PHY_ID_AQR113),
+	.name		= "Aquantia AQR113",
+	.probe		= aqr107_probe,
+	.config_init	= aqr113_config_init,
+	.config_aneg    = aqr113_config_aneg,
+	.read_status	= aqr107_read_status,
+	.suspend	= aqr107_suspend,
+	.resume		= aqr107_resume,
+	.get_stats	= aqr107_get_stats,
+},
 {
 	PHY_ID_MATCH_MODEL(PHY_ID_AQR405),
 	.name		= "Aquantia AQR405",
@@ -825,6 +825,7 @@ static struct mdio_device_id __maybe_unused aqr_tbl[] = {
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR106) },
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR107) },
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113) },
+	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113) },
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQCS109) },
 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR405) },
 	{ }
-- 
2.27.0

