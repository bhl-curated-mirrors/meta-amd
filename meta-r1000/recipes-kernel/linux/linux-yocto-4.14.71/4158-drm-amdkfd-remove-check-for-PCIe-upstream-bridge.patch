From b24f7a1d9fbb22a99f9ddef8dff05916fbc10ab6 Mon Sep 17 00:00:00 2001
From: welu <Wei.Lu2@amd.com>
Date: Wed, 4 Apr 2018 11:44:04 -0400
Subject: [PATCH 4158/5725] drm/amdkfd: remove check for PCIe upstream bridge

atomic support for GFX9 GPUs.
1. set vega10 needs_pci_atomics as false because vega10 do not need
pci atomics;
2. firstly try to enable atomics in pci_enable_atomic_ops_to_root()
and if this function failed and need_pic_atomics is true,
we need to report the error and return NULL.

Bug:SWDEV-149359

Change-Id: I71cbbe63cb1f03f606f8f4b5e4b8c796e164e0d1
Signed-off-by: welu <Wei.Lu2@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/amdkfd/kfd_device.c | 17 ++++++----
 drivers/pci/pci.c                       | 57 +++++++++++++++------------------
 include/linux/pci.h                     |  2 +-
 3 files changed, 37 insertions(+), 39 deletions(-)
 mode change 100755 => 100644 drivers/gpu/drm/amd/amdkfd/kfd_device.c

diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_device.c b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
old mode 100755
new mode 100644
index 768373f..4ee56ab
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
@@ -222,7 +222,7 @@ static const struct kfd_device_info vega10_device_info = {
 	.mqd_size_aligned = MQD_SIZE_ALIGNED,
 	.supports_cwsr = true,
 	.needs_iommu_device = false,
-	.needs_pci_atomics = true,
+	.needs_pci_atomics = false,
 	.num_sdma_engines = 2,
 };
 
@@ -358,7 +358,7 @@ struct kfd_dev *kgd2kfd_probe(struct kgd_dev *kgd,
 	struct pci_dev *pdev, const struct kfd2kgd_calls *f2g)
 {
 	struct kfd_dev *kfd;
-
+	int ret;
 	const struct kfd_device_info *device_info =
 					lookup_device_info(pdev->device);
 
@@ -372,11 +372,14 @@ struct kfd_dev *kgd2kfd_probe(struct kgd_dev *kgd,
 		 * 32 and 64-bit requests are possible and must be
 		 * supported.
 		 */
-                if (pci_enable_atomic_ops_to_root(pdev) < 0) {
-                        dev_info(kfd_device,
-                                "skipped device %x:%x, PCI rejects atomics",
-                                 pdev->vendor, pdev->device);
-                        return NULL;
+	ret = pci_enable_atomic_ops_to_root(pdev,
+			PCI_EXP_DEVCAP2_ATOMIC_COMP32 |
+			PCI_EXP_DEVCAP2_ATOMIC_COMP64);
+	if (device_info->needs_pci_atomics && ret  < 0) {
+		dev_info(kfd_device,
+			"skipped device %x:%x, PCI rejects atomics",
+			pdev->vendor, pdev->device);
+		return NULL;
                 }
 	}
 
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 06dfd52..1dde9da 100755
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2985,24 +2985,34 @@ bool pci_acs_path_enabled(struct pci_dev *start,
 /**
  * pci_enable_atomic_ops_to_root - enable AtomicOp requests to root port
  * @dev: the PCI device
+ * @cap_mask: mask of desired AtomicOp sizes, including one or more of:
+ *      PCI_EXP_DEVCAP2_ATOMIC_COMP32
+ *      PCI_EXP_DEVCAP2_ATOMIC_COMP64
+ *      PCI_EXP_DEVCAP2_ATOMIC_COMP128
+ *
+ * Return 0 if all upstream bridges support AtomicOp routing, egress
+ * blocking is disabled on all upstream ports, and the root port supports
+ * the requested completion capabilities (32-bit, 64-bit and/or 128-bit
+ * AtomicOp completion), or negative otherwise.
  *
- * Return 0 if the device is capable of generating AtomicOp requests,
- * all upstream bridges support AtomicOp routing, egress blocking is disabled
- * on all upstream ports, and the root port supports 32-bit, 64-bit and/or
- * 128-bit AtomicOp completion, or negative otherwise.
  */
-int pci_enable_atomic_ops_to_root(struct pci_dev *dev)
+int pci_enable_atomic_ops_to_root(struct pci_dev *dev, u32 cap_mask)
 {
 	struct pci_bus *bus = dev->bus;
+	struct pci_dev *bridge;
+	u32 cap, ctl2;
 
 	if (!pci_is_pcie(dev))
 		return -EINVAL;
 
-	switch (pci_pcie_type(dev)) {
 	/*
-	 * PCIe 3.0, 6.15 specifies that endpoints and root ports are permitted
-	 * to implement AtomicOp requester capabilities.
-	 */
+	 * Per PCIe r4.0, sec 6.15, endpoints and root ports may be
+	 * AtomicOp requesters.  For now, we only support endpoints as
+	 * requesters and root ports as completers.  No endpoints as
+	 * completers, and no peer-to-peer.
+	*/
+
+	switch (pci_pcie_type(dev)) {
 	case PCI_EXP_TYPE_ENDPOINT:
 	case PCI_EXP_TYPE_LEG_END:
 	case PCI_EXP_TYPE_RC_END:
@@ -3012,44 +3022,30 @@ int pci_enable_atomic_ops_to_root(struct pci_dev *dev)
 	}
 
 	while (bus->parent) {
-		struct pci_dev *bridge = bus->self;
-		u32 cap;
+		bridge = bus->self;
 
 		pcie_capability_read_dword(bridge, PCI_EXP_DEVCAP2, &cap);
 
 		switch (pci_pcie_type(bridge)) {
-		/*
-		 * Upstream, downstream and root ports may implement AtomicOp
-		 * routing capabilities. AtomicOp routing via a root port is
-		 * not considered.
-		 */
+		/* Ensure switch ports support AtomicOp routing */
 		case PCI_EXP_TYPE_UPSTREAM:
 		case PCI_EXP_TYPE_DOWNSTREAM:
 			if (!(cap & PCI_EXP_DEVCAP2_ATOMIC_ROUTE))
 				return -EINVAL;
 			break;
 
-		/*
-		 * Root ports are permitted to implement AtomicOp completion
-		 * capabilities.
-		 */
+		/* Ensure root port supports all the sizes we care about */
 		case PCI_EXP_TYPE_ROOT_PORT:
-			if (!(cap & (PCI_EXP_DEVCAP2_ATOMIC_COMP32 |
-				     PCI_EXP_DEVCAP2_ATOMIC_COMP64 |
-				     PCI_EXP_DEVCAP2_ATOMIC_COMP128)))
+			if ((cap & cap_mask) != cap_mask)
 				return -EINVAL;
 			break;
 		}
 
-		/*
-		 * Upstream ports may block AtomicOps on egress.
-		 */
-		if (pci_pcie_type(bridge) == PCI_EXP_TYPE_UPSTREAM) {
-			u32 ctl2;
-
+		/* Ensure upstream ports don't block AtomicOps on egress */
+		if (!bridge->has_secondary_link) {
 			pcie_capability_read_dword(bridge, PCI_EXP_DEVCTL2,
 						   &ctl2);
-			if (ctl2 & PCI_EXP_DEVCTL2_ATOMIC_BLOCK)
+			if (ctl2 & PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK)
 				return -EINVAL;
 		}
 
@@ -3058,7 +3054,6 @@ int pci_enable_atomic_ops_to_root(struct pci_dev *dev)
 
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL2,
 				 PCI_EXP_DEVCTL2_ATOMIC_REQ);
-
 	return 0;
 }
 EXPORT_SYMBOL(pci_enable_atomic_ops_to_root);
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 339f5b7..76a681f 100755
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -2075,7 +2075,7 @@ void pci_request_acs(void);
 bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags);
 bool pci_acs_path_enabled(struct pci_dev *start,
 			  struct pci_dev *end, u16 acs_flags);
-int pci_enable_atomic_ops_to_root(struct pci_dev *dev);
+int pci_enable_atomic_ops_to_root(struct pci_dev *dev, u32 cap_mask);
 
 #define PCI_VPD_LRDT			0x80	/* Large Resource Data Type */
 #define PCI_VPD_LRDT_ID(x)		((x) | PCI_VPD_LRDT)
-- 
2.7.4

