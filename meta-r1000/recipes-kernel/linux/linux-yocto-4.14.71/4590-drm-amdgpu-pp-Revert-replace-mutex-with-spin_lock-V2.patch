From d7a781f741fcd2ec96f4416711e0b1b49311af32 Mon Sep 17 00:00:00 2001
From: Christian Koenig <christian.koenig@amd.com>
Date: Mon, 4 Jun 2018 12:45:00 +0200
Subject: [PATCH 4590/5725] drm/amdgpu/pp: Revert "replace mutex with spin_lock
 (V2)"
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It breaks compilation. This reverts commit c68c36ebb3aeca3febfa839fd3f95e82525687aa.

Signed-off-by: Christian KÃ¶nig <christian.koenig@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/powerplay/amd_powerplay.c | 152 +++++++++++++-------------
 drivers/gpu/drm/amd/powerplay/inc/hwmgr.h     |   2 +-
 2 files changed, 77 insertions(+), 77 deletions(-)

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 3cdf852..76fc45f 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -182,10 +182,10 @@ static int pp_late_init(void *handle)
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 
 	if (hwmgr && hwmgr->pm_en) {
-		spin_lock(&hwmgr->smu_lock);
+		mutex_lock(&hwmgr->smu_lock);
 		hwmgr_handle_task(hwmgr,
 					AMD_PP_TASK_COMPLETE_INIT, NULL);
-		spin_unlock(&hwmgr->smu_lock);
+		mutex_unlock(&hwmgr->smu_lock);
 	}
 
 	if (adev->pm.smu_prv_buffer_size != 0)
@@ -368,11 +368,11 @@ static int pp_dpm_force_performance_level(void *handle,
 	if (level == hwmgr->dpm_level)
 		return 0;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	pp_dpm_en_umd_pstate(hwmgr, &level);
 	hwmgr->request_dpm_level = level;
 	hwmgr_handle_task(hwmgr, AMD_PP_TASK_READJUST_POWER_STATE, NULL);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return 0;
 }
@@ -386,9 +386,9 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	level = hwmgr->dpm_level;
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return level;
 }
 
@@ -404,9 +404,9 @@ static uint32_t pp_dpm_get_sclk(void *handle, bool low)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	clk = hwmgr->hwmgr_func->get_sclk(hwmgr, low);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return clk;
 }
 
@@ -422,9 +422,9 @@ static uint32_t pp_dpm_get_mclk(void *handle, bool low)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	clk = hwmgr->hwmgr_func->get_mclk(hwmgr, low);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return clk;
 }
 
@@ -439,9 +439,9 @@ static void pp_dpm_powergate_vce(void *handle, bool gate)
 		pr_info("%s was not implemented.\n", __func__);
 		return;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 }
 
 static void pp_dpm_powergate_uvd(void *handle, bool gate)
@@ -455,9 +455,9 @@ static void pp_dpm_powergate_uvd(void *handle, bool gate)
 		pr_info("%s was not implemented.\n", __func__);
 		return;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 }
 
 static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
@@ -469,9 +469,9 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr_handle_task(hwmgr, task_id, user_state);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;
 }
@@ -485,7 +485,7 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 	if (!hwmgr || !hwmgr->pm_en || !hwmgr->current_ps)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	state = hwmgr->current_ps;
 
@@ -506,7 +506,7 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 			pm_type = POWER_STATE_TYPE_DEFAULT;
 		break;
 	}
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return pm_type;
 }
@@ -522,9 +522,9 @@ static void pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 		pr_info("%s was not implemented.\n", __func__);
 		return;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 }
 
 static uint32_t pp_dpm_get_fan_control_mode(void *handle)
@@ -539,9 +539,9 @@ static uint32_t pp_dpm_get_fan_control_mode(void *handle)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	mode = hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return mode;
 }
 
@@ -557,9 +557,9 @@ static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->set_fan_speed_percent(hwmgr, percent);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -576,9 +576,9 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 		return 0;
 	}
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->get_fan_speed_percent(hwmgr, speed);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -593,9 +593,9 @@ static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 	if (hwmgr->hwmgr_func->get_fan_speed_rpm == NULL)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->get_fan_speed_rpm(hwmgr, rpm);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -610,7 +610,7 @@ static int pp_dpm_get_pp_num_states(void *handle,
 	if (!hwmgr || !hwmgr->pm_en ||!hwmgr->ps)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	data->nums = hwmgr->num_ps;
 
@@ -634,7 +634,7 @@ static int pp_dpm_get_pp_num_states(void *handle,
 				data->states[i] = POWER_STATE_TYPE_DEFAULT;
 		}
 	}
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
 }
 
@@ -646,10 +646,10 @@ static int pp_dpm_get_pp_table(void *handle, char **table)
 	if (!hwmgr || !hwmgr->pm_en ||!hwmgr->soft_pp_table)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	*table = (char *)hwmgr->soft_pp_table;
 	size = hwmgr->soft_pp_table_size;
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return size;
 }
 
@@ -677,7 +677,7 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	if (!hwmgr->hardcode_pp_table) {
 		hwmgr->hardcode_pp_table = kmemdup(hwmgr->soft_pp_table,
 						   hwmgr->soft_pp_table_size,
@@ -699,10 +699,10 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 		if (ret)
 			goto err;
 	}
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
 err:
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -719,12 +719,12 @@ static int pp_dpm_force_clock_level(void *handle,
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
 		ret = hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
 	else
 		ret = -EINVAL;
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -741,9 +741,9 @@ static int pp_dpm_print_clock_levels(void *handle,
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -759,9 +759,9 @@ static int pp_dpm_get_sclk_od(void *handle)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->get_sclk_od(hwmgr);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -778,9 +778,9 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 		return 0;
 	}
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -796,9 +796,9 @@ static int pp_dpm_get_mclk_od(void *handle)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->get_mclk_od(hwmgr);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -814,9 +814,9 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -837,9 +837,9 @@ static int pp_dpm_read_sensor(void *handle, int idx,
 		*((uint32_t *)value) = hwmgr->pstate_mclk;
 		return 0;
 	default:
-		spin_lock(&hwmgr->smu_lock);
+		mutex_lock(&hwmgr->smu_lock);
 		ret = hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);
-		spin_unlock(&hwmgr->smu_lock);
+		mutex_unlock(&hwmgr->smu_lock);
 		return ret;
 	}
 }
@@ -884,10 +884,10 @@ static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 		pr_info("%s was not implemented.\n", __func__);
 		return ret;
 	}
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
 		ret = hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -924,7 +924,7 @@ static int pp_dpm_switch_power_profile(void *handle,
 	if (!(type < PP_SMC_POWER_PROFILE_CUSTOM))
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	if (!en) {
 		hwmgr->workload_mask &= ~(1 << hwmgr->workload_prority[type]);
@@ -940,7 +940,7 @@ static int pp_dpm_switch_power_profile(void *handle,
 
 	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)
 		hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, &workload, 0);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return 0;
 }
@@ -963,10 +963,10 @@ static int pp_set_power_limit(void *handle, uint32_t limit)
 	if (limit > hwmgr->default_power_limit)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->set_power_limit(hwmgr, limit);
 	hwmgr->power_limit = limit;
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
 }
 
@@ -977,14 +977,14 @@ static int pp_get_power_limit(void *handle, uint32_t *limit, bool default_limit)
 	if (!hwmgr || !hwmgr->pm_en ||!limit)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	if (default_limit)
 		*limit = hwmgr->default_power_limit;
 	else
 		*limit = hwmgr->power_limit;
 
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return 0;
 }
@@ -997,9 +997,9 @@ static int pp_display_configuration_change(void *handle,
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	phm_store_dal_configuration_data(hwmgr, display_config);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
 }
 
@@ -1012,9 +1012,9 @@ static int pp_get_display_power_level(void *handle,
 	if (!hwmgr || !hwmgr->pm_en ||!output)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_get_dal_power_level(hwmgr, output);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -1029,7 +1029,7 @@ static int pp_get_current_clocks(void *handle,
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	phm_get_dal_power_level(hwmgr, &simple_clocks);
 
@@ -1043,7 +1043,7 @@ static int pp_get_current_clocks(void *handle,
 
 	if (ret) {
 		pr_info("Error in phm_get_clock_info \n");
-		spin_unlock(&hwmgr->smu_lock);
+		mutex_unlock(&hwmgr->smu_lock);
 		return -EINVAL;
 	}
 
@@ -1063,7 +1063,7 @@ static int pp_get_current_clocks(void *handle,
 		clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
 		clocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;
 	}
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
 }
 
@@ -1078,9 +1078,9 @@ static int pp_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struc
 	if (clocks == NULL)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_get_clock_by_type(hwmgr, type, clocks);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -1094,9 +1094,9 @@ static int pp_get_clock_by_type_with_latency(void *handle,
 	if (!hwmgr || !hwmgr->pm_en ||!clocks)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_get_clock_by_type_with_latency(hwmgr, type, clocks);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -1110,11 +1110,11 @@ static int pp_get_clock_by_type_with_voltage(void *handle,
 	if (!hwmgr || !hwmgr->pm_en ||!clocks)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	ret = phm_get_clock_by_type_with_voltage(hwmgr, type, clocks);
 
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -1127,10 +1127,10 @@ static int pp_set_watermarks_for_clocks_ranges(void *handle,
 	if (!hwmgr || !hwmgr->pm_en ||!wm_with_clock_ranges)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_set_watermarks_for_clocks_ranges(hwmgr,
 			wm_with_clock_ranges);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;
 }
@@ -1144,9 +1144,9 @@ static int pp_display_clock_voltage_request(void *handle,
 	if (!hwmgr || !hwmgr->pm_en ||!clock)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_display_clock_voltage_request(hwmgr, clock);
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;
 }
@@ -1160,12 +1160,12 @@ static int pp_get_display_mode_validation_clocks(void *handle,
 	if (!hwmgr || !hwmgr->pm_en ||!clocks)
 		return -EINVAL;
 
-	spin_lock(&hwmgr->smu_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))
 		ret = phm_get_max_high_clocks(hwmgr, clocks);
 
-	spin_unlock(&hwmgr->smu_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	
 	return ret;
 }
diff --git a/drivers/gpu/drm/amd/powerplay/inc/hwmgr.h b/drivers/gpu/drm/amd/powerplay/inc/hwmgr.h
index 37d1382..b99fb8a 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/hwmgr.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/hwmgr.h
@@ -709,7 +709,7 @@ struct pp_hwmgr {
 	uint32_t smu_version;
 	bool not_vf;
 	bool pm_en;
-	spinlock_t smu_lock;
+	struct mutex smu_lock;
 
 	uint32_t pp_table_version;
 	void *device;
-- 
2.7.4

