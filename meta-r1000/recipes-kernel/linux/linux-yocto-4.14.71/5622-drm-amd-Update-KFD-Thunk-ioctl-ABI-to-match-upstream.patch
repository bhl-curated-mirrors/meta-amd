From bd5bcbb17667e86b7225710b8bb4018ae942205d Mon Sep 17 00:00:00 2001
From: Felix Kuehling <Felix.Kuehling@amd.com>
Date: Thu, 24 May 2018 14:53:40 -0400
Subject: [PATCH 5622/5725] drm/amd: Update KFD-Thunk ioctl ABI to match
 upstream

- Clean up and renumber scratch memory ioctl
- Renumber get_tile_config ioctl
- Renumber set_trap_handler ioctl
- Update KFD_IOC_ALLOC_MEM_FLAGS
- Renumber GPUVM memory management ioctls
- Remove unused SEP_PROCESS_DGPU_APERTURE ioctl
- Update memory management ioctls
    Replace device_ids_array_size (in bytes) with n_devices. Fix error
    handling and use n_success to update device_id arrays in objects.

This commit breaks the ABI and requires a corresponding Thunk change.

Change-Id: I62149841f1603ec36143836d2eb5ab0fcaf37cf5
Signed-off-by: Felix Kuehling <Felix.Kuehling@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/amdkfd/kfd_chardev.c     | 131 ++++++++++-----------------
 drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c |  10 --
 drivers/gpu/drm/amd/amdkfd/kfd_priv.h        |   2 -
 drivers/gpu/drm/amd/amdkfd/kfd_process.c     |  11 ++-
 4 files changed, 53 insertions(+), 101 deletions(-)
 mode change 100644 => 100755 drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c

diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
index 33a5793..1b96337 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
@@ -1066,17 +1066,14 @@ static int kfd_ioctl_wait_events(struct file *filp, struct kfd_process *p,
 
 	return err;
 }
-static int kfd_ioctl_alloc_scratch_memory(struct file *filep,
+static int kfd_ioctl_set_scratch_backing_va(struct file *filep,
 					struct kfd_process *p, void *data)
 {
-	struct kfd_ioctl_alloc_memory_of_scratch_args *args = data;
+	struct kfd_ioctl_set_scratch_backing_va_args *args = data;
 	struct kfd_process_device *pdd;
 	struct kfd_dev *dev;
 	long err;
 
-	if (args->size == 0)
-		return -EINVAL;
-
 	dev = kfd_device_by_id(args->gpu_id);
 	if (!dev)
 		return -EINVAL;
@@ -1352,31 +1349,30 @@ static int kfd_ioctl_map_memory_to_gpu(struct file *filep,
 	void *mem;
 	struct kfd_dev *dev, *peer;
 	long err = 0;
-	int i, num_dev = 0;
+	int i;
 	uint32_t *devices_arr = NULL;
 
 	dev = kfd_device_by_id(GET_GPU_ID(args->handle));
 	if (!dev)
 		return -EINVAL;
 
-	if (args->device_ids_array_size == 0) {
-		pr_debug("Device ID array size is 0\n");
+	if (!args->n_devices) {
+		pr_debug("Device IDs array empty\n");
 		return -EINVAL;
 	}
-
-	if (args->device_ids_array_size % sizeof(uint32_t)) {
-		pr_debug("Node IDs array size %u\n",
-				args->device_ids_array_size);
+	if (args->n_success > args->n_devices) {
+		pr_debug("n_success exceeds n_devices\n");
 		return -EINVAL;
 	}
 
-	devices_arr = kmalloc(args->device_ids_array_size, GFP_KERNEL);
+	devices_arr = kmalloc_array(args->n_devices, sizeof(*devices_arr),
+				    GFP_KERNEL);
 	if (!devices_arr)
 		return -ENOMEM;
 
 	err = copy_from_user(devices_arr,
-			(void __user *)args->device_ids_array_ptr,
-			args->device_ids_array_size);
+			     (void __user *)args->device_ids_array_ptr,
+			     args->n_devices * sizeof(*devices_arr));
 	if (err != 0) {
 		err = -EFAULT;
 		goto copy_from_user_failed;
@@ -1397,12 +1393,11 @@ static int kfd_ioctl_map_memory_to_gpu(struct file *filep,
 		goto get_mem_obj_from_handle_failed;
 	}
 
-	num_dev = args->device_ids_array_size / sizeof(uint32_t);
-	for (i = 0 ; i < num_dev; i++) {
+	for (i = args->n_success; i < args->n_devices; i++) {
 		peer = kfd_device_by_id(devices_arr[i]);
 		if (!peer) {
 			pr_debug("Getting device by id failed for 0x%x\n",
-					devices_arr[i]);
+				 devices_arr[i]);
 			err = -EINVAL;
 			goto get_mem_obj_from_handle_failed;
 		}
@@ -1413,12 +1408,13 @@ static int kfd_ioctl_map_memory_to_gpu(struct file *filep,
 			goto get_mem_obj_from_handle_failed;
 		}
 		err = peer->kfd2kgd->map_memory_to_gpu(
-				peer->kgd, (struct kgd_mem *)mem, peer_pdd->vm);
-		if (err != 0) {
-			pr_err("Failed to map to gpu %d, num_dev=%d\n",
-					i, num_dev);
+			peer->kgd, (struct kgd_mem *)mem, peer_pdd->vm);
+		if (err) {
+			pr_err("Failed to map to gpu %d/%d\n",
+			       i, args->n_devices);
 			goto map_memory_to_gpu_failed;
 		}
+		args->n_success = i+1;
 	}
 
 	mutex_unlock(&p->mutex);
@@ -1430,7 +1426,7 @@ static int kfd_ioctl_map_memory_to_gpu(struct file *filep,
 	}
 
 	/* Flush TLBs after waiting for the page table updates to complete */
-	for (i = 0; i < num_dev; i++) {
+	for (i = 0; i < args->n_devices; i++) {
 		peer = kfd_device_by_id(devices_arr[i]);
 		if (WARN_ON_ONCE(!peer))
 			continue;
@@ -1463,30 +1459,29 @@ static int kfd_ioctl_unmap_memory_from_gpu(struct file *filep,
 	void *mem;
 	struct kfd_dev *dev, *peer;
 	long err = 0;
-	uint32_t *devices_arr = NULL, num_dev, i;
+	uint32_t *devices_arr = NULL, i;
 
 	dev = kfd_device_by_id(GET_GPU_ID(args->handle));
 	if (!dev)
 		return -EINVAL;
 
-	if (args->device_ids_array_size == 0) {
-		pr_debug("Device ID array size is 0\n");
+	if (!args->n_devices) {
+		pr_debug("Device IDs array empty\n");
 		return -EINVAL;
 	}
-
-	if (args->device_ids_array_size % sizeof(uint32_t)) {
-		pr_debug("Node IDs array size %u\n",
-				args->device_ids_array_size);
+	if (args->n_success > args->n_devices) {
+		pr_debug("n_success exceeds n_devices\n");
 		return -EINVAL;
 	}
 
-	devices_arr = kmalloc(args->device_ids_array_size, GFP_KERNEL);
+	devices_arr = kmalloc_array(args->n_devices, sizeof(*devices_arr),
+				    GFP_KERNEL);
 	if (!devices_arr)
 		return -ENOMEM;
 
 	err = copy_from_user(devices_arr,
-			(void __user *)args->device_ids_array_ptr,
-			args->device_ids_array_size);
+			     (void __user *)args->device_ids_array_ptr,
+			     args->n_devices * sizeof(*devices_arr));
 	if (err != 0) {
 		err = -EFAULT;
 		goto copy_from_user_failed;
@@ -1496,8 +1491,7 @@ static int kfd_ioctl_unmap_memory_from_gpu(struct file *filep,
 
 	pdd = kfd_get_process_device_data(dev, p);
 	if (!pdd) {
-		pr_debug("Process device data doesn't exist\n");
-		err = -ENODEV;
+		err = -EINVAL;
 		goto bind_process_to_device_failed;
 	}
 
@@ -1508,8 +1502,7 @@ static int kfd_ioctl_unmap_memory_from_gpu(struct file *filep,
 		goto get_mem_obj_from_handle_failed;
 	}
 
-	num_dev = args->device_ids_array_size / sizeof(uint32_t);
-	for (i = 0 ; i < num_dev; i++) {
+	for (i = args->n_success; i < args->n_devices; i++) {
 		peer = kfd_device_by_id(devices_arr[i]);
 		if (!peer) {
 			err = -EINVAL;
@@ -1525,9 +1518,10 @@ static int kfd_ioctl_unmap_memory_from_gpu(struct file *filep,
 			peer->kgd, (struct kgd_mem *)mem, peer_pdd->vm);
 		if (err) {
 			pr_err("Failed to unmap from gpu %d/%d\n",
-			       i, num_dev);
+			       i, args->n_devices);
 			goto unmap_memory_from_gpu_failed;
 		}
+		args->n_success = i+1;
 	}
 	kfree(devices_arr);
 
@@ -1544,34 +1538,6 @@ static int kfd_ioctl_unmap_memory_from_gpu(struct file *filep,
 	return err;
 }
 
-static int kfd_ioctl_set_process_dgpu_aperture(struct file *filep,
-		struct kfd_process *p, void *data)
-{
-	struct kfd_ioctl_set_process_dgpu_aperture_args *args = data;
-	struct kfd_dev *dev;
-	struct kfd_process_device *pdd;
-	long err;
-
-	dev = kfd_device_by_id(args->gpu_id);
-	if (!dev)
-		return -EINVAL;
-
-	mutex_lock(&p->mutex);
-
-	pdd = kfd_bind_process_to_device(dev, p);
-	if (IS_ERR(pdd)) {
-		err = PTR_ERR(pdd);
-		goto exit;
-	}
-
-	err = kfd_set_process_dgpu_aperture(pdd, args->dgpu_base,
-			args->dgpu_limit);
-
-exit:
-	mutex_unlock(&p->mutex);
-	return err;
-}
-
 static int kfd_ioctl_get_dmabuf_info(struct file *filep,
 		struct kfd_process *p, void *data)
 {
@@ -2012,6 +1978,21 @@ static const struct amdkfd_ioctl_desc amdkfd_ioctls[] = {
 	AMDKFD_IOCTL_DEF(AMDKFD_IOC_DBG_WAVE_CONTROL,
 			kfd_ioctl_dbg_wave_control, 0),
 
+	AMDKFD_IOCTL_DEF(AMDKFD_IOC_SET_SCRATCH_BACKING_VA,
+			kfd_ioctl_set_scratch_backing_va, 0),
+
+	AMDKFD_IOCTL_DEF(AMDKFD_IOC_GET_TILE_CONFIG,
+			kfd_ioctl_get_tile_config, 0),
+
+	AMDKFD_IOCTL_DEF(AMDKFD_IOC_SET_TRAP_HANDLER,
+			kfd_ioctl_set_trap_handler, 0),
+
+	AMDKFD_IOCTL_DEF(AMDKFD_IOC_GET_PROCESS_APERTURES_NEW,
+			kfd_ioctl_get_process_apertures_new, 0),
+
+	AMDKFD_IOCTL_DEF(AMDKFD_IOC_ACQUIRE_VM,
+			kfd_ioctl_acquire_vm, 0),
+
 	AMDKFD_IOCTL_DEF(AMDKFD_IOC_ALLOC_MEMORY_OF_GPU,
 			kfd_ioctl_alloc_memory_of_gpu, 0),
 
@@ -2024,30 +2005,15 @@ static const struct amdkfd_ioctl_desc amdkfd_ioctls[] = {
 	AMDKFD_IOCTL_DEF(AMDKFD_IOC_UNMAP_MEMORY_FROM_GPU,
 			kfd_ioctl_unmap_memory_from_gpu, 0),
 
-	AMDKFD_IOCTL_DEF(AMDKFD_IOC_ALLOC_MEMORY_OF_SCRATCH,
-			kfd_ioctl_alloc_scratch_memory, 0),
-
 	AMDKFD_IOCTL_DEF(AMDKFD_IOC_SET_CU_MASK,
 			kfd_ioctl_set_cu_mask, 0),
 
-	AMDKFD_IOCTL_DEF(AMDKFD_IOC_SET_PROCESS_DGPU_APERTURE,
-			kfd_ioctl_set_process_dgpu_aperture, 0),
-
-	AMDKFD_IOCTL_DEF(AMDKFD_IOC_SET_TRAP_HANDLER,
-			kfd_ioctl_set_trap_handler, 0),
-
-	AMDKFD_IOCTL_DEF(AMDKFD_IOC_GET_PROCESS_APERTURES_NEW,
-				kfd_ioctl_get_process_apertures_new, 0),
-
 	AMDKFD_IOCTL_DEF(AMDKFD_IOC_GET_DMABUF_INFO,
 				kfd_ioctl_get_dmabuf_info, 0),
 
 	AMDKFD_IOCTL_DEF(AMDKFD_IOC_IMPORT_DMABUF,
 				kfd_ioctl_import_dmabuf, 0),
 
-	AMDKFD_IOCTL_DEF(AMDKFD_IOC_GET_TILE_CONFIG,
-				kfd_ioctl_get_tile_config, 0),
-
 	AMDKFD_IOCTL_DEF(AMDKFD_IOC_IPC_IMPORT_HANDLE,
 				kfd_ioctl_ipc_import_handle, 0),
 
@@ -2060,9 +2026,6 @@ static const struct amdkfd_ioctl_desc amdkfd_ioctls[] = {
 	AMDKFD_IOCTL_DEF(AMDKFD_IOC_GET_QUEUE_WAVE_STATE,
 				kfd_ioctl_get_queue_wave_state, 0),
 
-	AMDKFD_IOCTL_DEF(AMDKFD_IOC_ACQUIRE_VM,
-				kfd_ioctl_acquire_vm, 0)
-
 };
 
 #define AMDKFD_CORE_IOCTL_COUNT	ARRAY_SIZE(amdkfd_ioctls)
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c b/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c
old mode 100644
new mode 100755
index 2c00711..be376d93
--- a/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c
@@ -313,16 +313,6 @@
 #define SVM_CWSR_BASE (SVM_USER_BASE - KFD_CWSR_TBA_TMA_SIZE)
 #define SVM_IB_BASE   (SVM_CWSR_BASE - PAGE_SIZE)
 
-int kfd_set_process_dgpu_aperture(struct kfd_process_device *pdd,
-					uint64_t base, uint64_t limit)
-{
-	if (base < SVM_USER_BASE) {
-		pr_err("Set dgpu vm base 0x%llx failed.\n", base);
-		return -EINVAL;
-	}
-	return 0;
-}
-
 void kfd_init_apertures_vi(struct kfd_process_device *pdd, uint8_t id)
 {
 	/*
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_priv.h b/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
index b2ef0f5..be66eae 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
@@ -875,8 +875,6 @@ int kgd2kfd_post_reset(struct kfd_dev *kfd);
 
 /* amdkfd Apertures */
 int kfd_init_apertures(struct kfd_process *process);
-int kfd_set_process_dgpu_aperture(struct kfd_process_device *pdd,
-				uint64_t base, uint64_t limit);
 
 /* Queue Context Management */
 int init_queue(struct queue **q, const struct queue_properties *properties);
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_process.c b/drivers/gpu/drm/amd/amdkfd/kfd_process.c
index 5fa3559..2b4c5bd 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_process.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_process.c
@@ -182,8 +182,10 @@ static int kfd_process_alloc_gpuvm(struct kfd_process_device *pdd,
 static int kfd_process_device_reserve_ib_mem(struct kfd_process_device *pdd)
 {
 	struct qcm_process_device *qpd = &pdd->qpd;
-	uint32_t flags = ALLOC_MEM_FLAGS_GTT | ALLOC_MEM_FLAGS_NONPAGED |
-		ALLOC_MEM_FLAGS_NO_SUBSTITUTE | ALLOC_MEM_FLAGS_EXECUTE_ACCESS;
+	uint32_t flags = ALLOC_MEM_FLAGS_GTT |
+			 ALLOC_MEM_FLAGS_NO_SUBSTITUTE |
+			 ALLOC_MEM_FLAGS_WRITABLE |
+			 ALLOC_MEM_FLAGS_EXECUTABLE;
 	void *kaddr;
 	int ret;
 
@@ -503,9 +505,8 @@ static int kfd_process_device_init_cwsr_dgpu(struct kfd_process_device *pdd)
 {
 	struct kfd_dev *dev = pdd->dev;
 	struct qcm_process_device *qpd = &pdd->qpd;
-	uint32_t flags = ALLOC_MEM_FLAGS_GTT | ALLOC_MEM_FLAGS_NONPAGED |
-		ALLOC_MEM_FLAGS_NO_SUBSTITUTE | ALLOC_MEM_FLAGS_READONLY |
-		ALLOC_MEM_FLAGS_EXECUTE_ACCESS;
+	uint32_t flags = ALLOC_MEM_FLAGS_GTT |
+		ALLOC_MEM_FLAGS_NO_SUBSTITUTE | ALLOC_MEM_FLAGS_EXECUTABLE;
 	void *kaddr;
 	int ret;
 
-- 
2.7.4

