From ca278304c96d37e534c22e33b4a8f41d7b133269 Mon Sep 17 00:00:00 2001
From: Rex Zhu <Rex.Zhu@amd.com>
Date: Fri, 16 Mar 2018 15:16:10 +0800
Subject: [PATCH 3816/4131] drm/amd/pp: Move functions to smu backend table for
 vega10

Change-Id: Ie0f0816ccdcd99309f5523408f98e1cb527137b2
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Reviewed-by: Evan Quan <evan.quan@amd.com>
Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
---
 drivers/gpu/drm/amd/powerplay/hwmgr/vega10_hwmgr.c | 36 ++++++++---------
 .../gpu/drm/amd/powerplay/hwmgr/vega10_thermal.c   |  7 ++--
 drivers/gpu/drm/amd/powerplay/inc/smumgr.h         |  8 ++++
 drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c |  4 +-
 .../gpu/drm/amd/powerplay/smumgr/vega10_smumgr.c   | 45 ++++++++++------------
 .../gpu/drm/amd/powerplay/smumgr/vega10_smumgr.h   | 14 +------
 6 files changed, 53 insertions(+), 61 deletions(-)

diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/vega10_hwmgr.c b/drivers/gpu/drm/amd/powerplay/hwmgr/vega10_hwmgr.c
index e1e97cf..0e82f90 100644
--- a/drivers/gpu/drm/amd/powerplay/hwmgr/vega10_hwmgr.c
+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/vega10_hwmgr.c
@@ -427,7 +427,7 @@ static void vega10_init_dpm_defaults(struct pp_hwmgr *hwmgr)
 		data->smu_features[GNLD_VR0HOT].supported = true;
 
 	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetSmuVersion);
-	vega10_read_arg_from_smc(hwmgr, &(hwmgr->smu_version));
+	hwmgr->smu_version = smum_get_argument(hwmgr);
 		/* ACG firmware has major version 5 */
 	if ((hwmgr->smu_version & 0xff000000) == 0x5000000)
 		data->smu_features[GNLD_ACG].supported = true;
@@ -2273,7 +2273,7 @@ static int vega10_acg_enable(struct pp_hwmgr *hwmgr)
 		smum_send_msg_to_smc(hwmgr, PPSMC_MSG_InitializeAcg);
 
 		smum_send_msg_to_smc(hwmgr, PPSMC_MSG_RunAcgBtc);
-		vega10_read_arg_from_smc(hwmgr, &agc_btc_response);
+		agc_btc_response = smum_get_argument(hwmgr);
 
 		if (1 == agc_btc_response) {
 			if (1 == data->acg_loop_state)
@@ -2380,10 +2380,10 @@ static int vega10_populate_and_upload_avfs_fuse_override(struct pp_hwmgr *hwmgr)
 	AvfsFuseOverride_t *avfs_fuse_table = &(data->smc_state_table.avfs_fuse_override_table);
 
 	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ReadSerialNumTop32);
-	vega10_read_arg_from_smc(hwmgr, &top32);
+	top32 = smum_get_argument(hwmgr);
 
 	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ReadSerialNumBottom32);
-	vega10_read_arg_from_smc(hwmgr, &bottom32);
+	bottom32 = smum_get_argument(hwmgr);
 
 	serial_number = ((uint64_t)bottom32 << 32) | top32;
 
@@ -2397,8 +2397,8 @@ static int vega10_populate_and_upload_avfs_fuse_override(struct pp_hwmgr *hwmgr)
 		avfs_fuse_table->VFT2_b  = fuse.VFT2_b;
 		avfs_fuse_table->VFT2_m1 = fuse.VFT2_m1;
 		avfs_fuse_table->VFT2_m2 = fuse.VFT2_m2;
-		result = vega10_copy_table_to_smc(hwmgr,
-			(uint8_t *)avfs_fuse_table, AVFSFUSETABLE);
+		result = smum_smc_table_manager(hwmgr,  (uint8_t *)avfs_fuse_table,
+						AVFSFUSETABLE, false);
 		PP_ASSERT_WITH_CODE(!result,
 			"Failed to upload FuseOVerride!",
 			);
@@ -2541,8 +2541,8 @@ static int vega10_init_smc_table(struct pp_hwmgr *hwmgr)
 
 	vega10_populate_and_upload_avfs_fuse_override(hwmgr);
 
-	result = vega10_copy_table_to_smc(hwmgr,
-			(uint8_t *)pp_table, PPTABLE);
+	result = smum_smc_table_manager(hwmgr, (uint8_t *)pp_table, PPTABLE, false);
+
 	PP_ASSERT_WITH_CODE(!result,
 			"Failed to upload PPtable!", return result);
 
@@ -3779,8 +3779,7 @@ static int vega10_set_power_state_tasks(struct pp_hwmgr *hwmgr,
 			"Failed to update SCLK threshold!",
 			result = tmp_result);
 
-	result = vega10_copy_table_to_smc(hwmgr,
-			(uint8_t *)pp_table, PPTABLE);
+	result = smum_smc_table_manager(hwmgr, (uint8_t *)pp_table, PPTABLE, false);
 	PP_ASSERT_WITH_CODE(!result,
 			"Failed to upload PPtable!", return result);
 
@@ -3840,7 +3839,7 @@ static int vega10_get_gpu_power(struct pp_hwmgr *hwmgr,
 	uint32_t value;
 
 	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrPkgPwr);
-	vega10_read_arg_from_smc(hwmgr, &value);
+	value = smum_get_argument(hwmgr);
 
 	/* power value is an integer */
 	memset(query, 0, sizeof *query);
@@ -3861,7 +3860,7 @@ static int vega10_read_sensor(struct pp_hwmgr *hwmgr, int idx,
 	switch (idx) {
 	case AMDGPU_PP_SENSOR_GFX_SCLK:
 		smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentGfxclkIndex);
-		vega10_read_arg_from_smc(hwmgr, &sclk_idx);
+		sclk_idx = smum_get_argument(hwmgr);
 		if (sclk_idx <  dpm_table->gfx_table.count) {
 			*((uint32_t *)value) = dpm_table->gfx_table.dpm_levels[sclk_idx].value;
 			*size = 4;
@@ -3871,7 +3870,7 @@ static int vega10_read_sensor(struct pp_hwmgr *hwmgr, int idx,
 		break;
 	case AMDGPU_PP_SENSOR_GFX_MCLK:
 		smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentUclkIndex);
-		vega10_read_arg_from_smc(hwmgr, &mclk_idx);
+		mclk_idx = smum_get_argument(hwmgr);
 		if (mclk_idx < dpm_table->mem_table.count) {
 			*((uint32_t *)value) = dpm_table->mem_table.dpm_levels[mclk_idx].value;
 			*size = 4;
@@ -3881,7 +3880,7 @@ static int vega10_read_sensor(struct pp_hwmgr *hwmgr, int idx,
 		break;
 	case AMDGPU_PP_SENSOR_GPU_LOAD:
 		smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_GetAverageGfxActivity, 0);
-		vega10_read_arg_from_smc(hwmgr, &activity_percent);
+		activity_percent = smum_get_argument(hwmgr);
 		*((uint32_t *)value) = activity_percent > 100 ? 100 : activity_percent;
 		*size = 4;
 		break;
@@ -4507,7 +4506,7 @@ static int vega10_print_clock_levels(struct pp_hwmgr *hwmgr,
 			break;
 
 		smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentGfxclkIndex);
-		vega10_read_arg_from_smc(hwmgr, &now);
+		now = smum_get_argument(hwmgr);
 
 		for (i = 0; i < sclk_table->count; i++)
 			size += sprintf(buf + size, "%d: %uMhz %s\n",
@@ -4519,7 +4518,7 @@ static int vega10_print_clock_levels(struct pp_hwmgr *hwmgr,
 			break;
 
 		smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentUclkIndex);
-		vega10_read_arg_from_smc(hwmgr, &now);
+		now = smum_get_argument(hwmgr);
 
 		for (i = 0; i < mclk_table->count; i++)
 			size += sprintf(buf + size, "%d: %uMhz %s\n",
@@ -4528,7 +4527,7 @@ static int vega10_print_clock_levels(struct pp_hwmgr *hwmgr,
 		break;
 	case PP_PCIE:
 		smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentLinkIndex);
-		vega10_read_arg_from_smc(hwmgr, &now);
+		now = smum_get_argument(hwmgr);
 
 		for (i = 0; i < pcie_table->count; i++)
 			size += sprintf(buf + size, "%d: %s %s\n", i,
@@ -4553,8 +4552,7 @@ static int vega10_display_configuration_changed_task(struct pp_hwmgr *hwmgr)
 
 	if ((data->water_marks_bitmap & WaterMarksExist) &&
 			!(data->water_marks_bitmap & WaterMarksLoaded)) {
-		result = vega10_copy_table_to_smc(hwmgr,
-			(uint8_t *)wm_table, WMTABLE);
+		result = smum_smc_table_manager(hwmgr, (uint8_t *)wm_table, WMTABLE, false);
 		PP_ASSERT_WITH_CODE(result, "Failed to update WMTABLE!", return EINVAL);
 		data->water_marks_bitmap |= WaterMarksLoaded;
 	}
diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/vega10_thermal.c b/drivers/gpu/drm/amd/powerplay/hwmgr/vega10_thermal.c
index fc2325e..0c1707a 100644
--- a/drivers/gpu/drm/amd/powerplay/hwmgr/vega10_thermal.c
+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/vega10_thermal.c
@@ -32,7 +32,7 @@
 static int vega10_get_current_rpm(struct pp_hwmgr *hwmgr, uint32_t *current_rpm)
 {
 	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentRpm);
-	vega10_read_arg_from_smc(hwmgr, current_rpm);
+	*current_rpm = smum_get_argument(hwmgr);
 	return 0;
 }
 
@@ -571,8 +571,9 @@ int vega10_thermal_setup_fan_table(struct pp_hwmgr *hwmgr)
 	table->FanStartTemp = hwmgr->thermal_controller.
 			advanceFanControlParameters.usZeroRPMStartTemperature;
 
-	ret = vega10_copy_table_to_smc(hwmgr,
-			(uint8_t *)(&(data->smc_state_table.pp_table)), PPTABLE);
+	ret = smum_smc_table_manager(hwmgr,
+				(uint8_t *)(&(data->smc_state_table.pp_table)),
+				PPTABLE, false);
 	if (ret)
 		pr_info("Failed to update Fan Control Table in PPTable!");
 
diff --git a/drivers/gpu/drm/amd/powerplay/inc/smumgr.h b/drivers/gpu/drm/amd/powerplay/inc/smumgr.h
index fc3a2a5..6c22ed9 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/smumgr.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/smumgr.h
@@ -69,6 +69,14 @@ enum SMU_MAC_DEFINITION {
 	SMU_UVD_MCLK_HANDSHAKE_DISABLE,
 };
 
+enum SMU9_TABLE_ID {
+	PPTABLE = 0,
+	WMTABLE,
+	AVFSTABLE,
+	TOOLSTABLE,
+	AVFSFUSETABLE
+};
+
 enum SMU10_TABLE_ID {
 	SMU10_WMTABLE = 0,
 	SMU10_CLOCKTABLE,
diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 8c49704..c861d30 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -52,7 +52,7 @@ static const enum smu8_scratch_entry firmware_list[] = {
 	SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G,
 };
 
-static int smu8_smum_get_argument(struct pp_hwmgr *hwmgr)
+static int smu8_get_argument(struct pp_hwmgr *hwmgr)
 {
 	if (hwmgr == NULL || hwmgr->device == NULL)
 		return -EINVAL;
@@ -881,7 +881,7 @@ const struct pp_smumgr_func smu8_smu_funcs = {
 	.check_fw_load_finish = smu8_check_fw_load_finish,
 	.request_smu_load_fw = NULL,
 	.request_smu_load_specific_fw = NULL,
-	.get_argument = smu8_smum_get_argument,
+	.get_argument = smu8_get_argument,
 	.send_msg_to_smc = smu8_send_msg_to_smc,
 	.send_msg_to_smc_with_parameter = smu8_send_msg_to_smc_with_parameter,
 	.download_pptable_settings = smu8_download_pptable_settings,
diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/vega10_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/vega10_smumgr.c
index d40edd5..af848de 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/vega10_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/vega10_smumgr.c
@@ -171,30 +171,17 @@ static int vega10_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr,
 	return 0;
 }
 
-/*
- * Retrieve an argument from SMC.
- * @param    hwmgr  the address of the powerplay hardware manager.
- * @param    arg     pointer to store the argument from SMC.
- * @return   Always return 0.
- */
-int vega10_read_arg_from_smc(struct pp_hwmgr *hwmgr, uint32_t *arg)
+static int vega10_get_argument(struct pp_hwmgr *hwmgr)
 {
 	uint32_t reg;
 
 	reg = soc15_get_register_offset(MP1_HWID, 0,
 			mmMP1_SMN_C2PMSG_82_BASE_IDX, mmMP1_SMN_C2PMSG_82);
 
-	*arg = cgs_read_register(hwmgr->device, reg);
-
-	return 0;
+	return cgs_read_register(hwmgr->device, reg);
 }
 
-/*
- * Copy table from SMC into driver FB
- * @param   hwmgr    the address of the HW manager
- * @param   table_id    the driver's table ID to copy from
- */
-int vega10_copy_table_from_smc(struct pp_hwmgr *hwmgr,
+static int vega10_copy_table_from_smc(struct pp_hwmgr *hwmgr,
 		uint8_t *table, int16_t table_id)
 {
 	struct vega10_smumgr *priv =
@@ -222,12 +209,7 @@ int vega10_copy_table_from_smc(struct pp_hwmgr *hwmgr,
 	return 0;
 }
 
-/*
- * Copy table from Driver FB into SMC
- * @param   hwmgr    the address of the HW manager
- * @param   table_id    the table to copy from
- */
-int vega10_copy_table_to_smc(struct pp_hwmgr *hwmgr,
+static int vega10_copy_table_to_smc(struct pp_hwmgr *hwmgr,
 		uint8_t *table, int16_t table_id)
 {
 	struct vega10_smumgr *priv =
@@ -273,7 +255,8 @@ static int vega10_get_smc_features(struct pp_hwmgr *hwmgr,
 		return -EINVAL;
 
 	vega10_send_msg_to_smc(hwmgr, PPSMC_MSG_GetEnabledSmuFeatures);
-	vega10_read_arg_from_smc(hwmgr, features_enabled);
+	*features_enabled = vega10_get_argument(hwmgr);
+
 	return 0;
 }
 
@@ -316,7 +299,7 @@ static int vega10_verify_smc_interface(struct pp_hwmgr *hwmgr)
 			PPSMC_MSG_GetDriverIfVersion),
 			"Attempt to get SMC IF Version Number Failed!",
 			return -EINVAL);
-	vega10_read_arg_from_smc(hwmgr, &smc_driver_if_version);
+	smc_driver_if_version = vega10_get_argument(hwmgr);
 
 	dev_id = adev->pdev->device;
 	rev_id = adev->pdev->revision;
@@ -501,6 +484,18 @@ static int vega10_start_smu(struct pp_hwmgr *hwmgr)
 	return 0;
 }
 
+static int vega10_smc_table_manager(struct pp_hwmgr *hwmgr, uint8_t *table, uint16_t table_id, bool rw)
+{
+	int ret;
+
+	if (rw)
+		ret = vega10_copy_table_from_smc(hwmgr, table, table_id);
+	else
+		ret = vega10_copy_table_to_smc(hwmgr, table, table_id);
+
+	return ret;
+}
+
 const struct pp_smumgr_func vega10_smu_funcs = {
 	.smu_init = &vega10_smu_init,
 	.smu_fini = &vega10_smu_fini,
@@ -511,4 +506,6 @@ const struct pp_smumgr_func vega10_smu_funcs = {
 	.download_pptable_settings = NULL,
 	.upload_pptable_settings = NULL,
 	.is_dpm_running = vega10_is_dpm_running,
+	.get_argument = vega10_get_argument,
+	.smc_table_manager = vega10_smc_table_manager,
 };
diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/vega10_smumgr.h b/drivers/gpu/drm/amd/powerplay/smumgr/vega10_smumgr.h
index 1f7f137..e8f8f78 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/vega10_smumgr.h
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/vega10_smumgr.h
@@ -25,14 +25,7 @@
 
 #include "vega10_hwmgr.h"
 
-enum smu_table_id {
-	PPTABLE = 0,
-	WMTABLE,
-	AVFSTABLE,
-	TOOLSTABLE,
-	AVFSFUSETABLE,
-	MAX_SMU_TABLE,
-};
+#define MAX_SMU_TABLE 5
 
 struct smu_table_entry {
 	uint32_t version;
@@ -51,11 +44,6 @@ struct vega10_smumgr {
 	struct smu_table_array            smu_tables;
 };
 
-int vega10_read_arg_from_smc(struct pp_hwmgr *hwmgr, uint32_t *arg);
-int vega10_copy_table_from_smc(struct pp_hwmgr *hwmgr,
-		uint8_t *table, int16_t table_id);
-int vega10_copy_table_to_smc(struct pp_hwmgr *hwmgr,
-		uint8_t *table, int16_t table_id);
 int vega10_enable_smc_features(struct pp_hwmgr *hwmgr,
 		bool enable, uint32_t feature_mask);
 
-- 
2.7.4

