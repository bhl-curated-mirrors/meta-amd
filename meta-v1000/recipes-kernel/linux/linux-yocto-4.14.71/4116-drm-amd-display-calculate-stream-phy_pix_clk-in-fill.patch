From 7d6e4faa2fc6559b8f30e1ccf15d32a9f07bccc4 Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Thu, 23 Aug 2018 21:02:11 +0530
Subject: [PATCH 4116/4131] drm/amd/display: calculate stream->phy_pix_clk in
 fill_stream_properties_from_drm_display_mode()

[why]
phy_pix_clk is one of the variable used to check if one PLL can be shared with displays having
common mode set configuration. As of now phy_pix_clock varialbe is calculated in function
dc_validate_stream(). dc_validate_stream() function is called after clocks are assigned for the
new display. Due to this during hotplug, when PLL sharing conditions are checked for new display
phy_pix_clk variable will be 0 and for displays that are already enabled phy_pix_clk will have
some value. Hence PLL will not be shared and if the display hardware doesn't have any more PLL
to assign, mode set will fail due to resource unavailability.

[how]
Instead of calculating the phy_pix_clk variable after the PLL is assigned for new display, this
patch calculates phy_pix_clk during the initialization of the new display which is be before
assigning the PLL for new display.

Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu at amd.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 43 +++++++++++++++++++++++
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c | 42 ----------------------
 2 files changed, 43 insertions(+), 42 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index a2f8857..20a1890 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -2234,6 +2234,47 @@ get_output_color_space(const struct dc_crtc_timing *dc_crtc_timing)
 
 /*****************************************************************************/
 
+static int
+get_norm_pix_clk(const struct dc_crtc_timing *timing)
+{
+	uint32_t pix_clk = timing->pix_clk_khz;
+	uint32_t normalized_pix_clk = pix_clk;
+
+	if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		pix_clk /= 2;
+	if (timing->pixel_encoding != PIXEL_ENCODING_YCBCR422) {
+		switch (timing->display_color_depth) {
+		case COLOR_DEPTH_888:
+			normalized_pix_clk = pix_clk;
+			break;
+		case COLOR_DEPTH_101010:
+			normalized_pix_clk = (pix_clk * 30) / 24;
+			break;
+		case COLOR_DEPTH_121212:
+			normalized_pix_clk = (pix_clk * 36) / 24;
+		break;
+		case COLOR_DEPTH_161616:
+			normalized_pix_clk = (pix_clk * 48) / 24;
+		break;
+		default:
+			ASSERT(0);
+		break;
+		}
+	}
+	return normalized_pix_clk;
+}
+
+static void
+calculate_phy_pix_clks(struct dc_stream_state *stream)
+{
+	if (dc_is_hdmi_signal(stream->signal))
+		stream->phy_pix_clk = get_norm_pix_clk(
+			&stream->timing);
+	else
+		stream->phy_pix_clk =
+			stream->timing.pix_clk_khz;
+}
+
 static void
 fill_stream_properties_from_drm_display_mode(struct dc_stream_state *stream,
 					     const struct drm_display_mode *mode_in,
@@ -2285,6 +2326,8 @@ fill_stream_properties_from_drm_display_mode(struct dc_stream_state *stream,
 
 	stream->out_transfer_func->type = TF_TYPE_PREDEFINED;
 	stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+
+	calculate_phy_pix_clks(stream);
 }
 
 static void fill_audio_info(struct audio_info *audio_info,
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 667fac8..ea76e02b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1630,46 +1630,6 @@ static struct dc_stream_state *find_pll_sharable_stream(
 	return NULL;
 }
 
-static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
-{
-	uint32_t pix_clk = timing->pix_clk_khz;
-	uint32_t normalized_pix_clk = pix_clk;
-
-	if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
-		pix_clk /= 2;
-	if (timing->pixel_encoding != PIXEL_ENCODING_YCBCR422) {
-		switch (timing->display_color_depth) {
-		case COLOR_DEPTH_888:
-			normalized_pix_clk = pix_clk;
-			break;
-		case COLOR_DEPTH_101010:
-			normalized_pix_clk = (pix_clk * 30) / 24;
-			break;
-		case COLOR_DEPTH_121212:
-			normalized_pix_clk = (pix_clk * 36) / 24;
-		break;
-		case COLOR_DEPTH_161616:
-			normalized_pix_clk = (pix_clk * 48) / 24;
-		break;
-		default:
-			ASSERT(0);
-		break;
-		}
-	}
-	return normalized_pix_clk;
-}
-
-static void calculate_phy_pix_clks(struct dc_stream_state *stream)
-{
-	/* update actual pixel clock on all streams */
-	if (dc_is_hdmi_signal(stream->signal))
-		stream->phy_pix_clk = get_norm_pix_clk(
-			&stream->timing);
-	else
-		stream->phy_pix_clk =
-			stream->timing.pix_clk_khz;
-}
-
 enum dc_status resource_map_pool_resources(
 		const struct dc  *dc,
 		struct dc_state *context,
@@ -2572,8 +2532,6 @@ enum dc_status dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
 	enum dc_status res = DC_OK;
 
-	calculate_phy_pix_clks(stream);
-
 	if (!tg->funcs->validate_timing(tg, &stream->timing))
 		res = DC_FAIL_CONTROLLER_VALIDATE;
 
-- 
2.7.4

