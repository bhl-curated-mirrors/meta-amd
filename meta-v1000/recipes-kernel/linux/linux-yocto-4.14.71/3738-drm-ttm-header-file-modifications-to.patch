From 9b15eb68994ec4b9abc176efc858f3c12829ad68 Mon Sep 17 00:00:00 2001
From: Kalyan Alle <kalyan.alle@amd.com>
Date: Mon, 23 Jul 2018 14:46:52 +0530
Subject: [PATCH 3738/4131] drm/ttm: header file modifications to

fix the build/compilation issues

Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 include/drm/ttm/ttm_bo_api.h     | 75 ++++++++++++++--------------------------
 include/drm/ttm/ttm_bo_driver.h  | 35 +++++++++++--------
 include/drm/ttm/ttm_memory.h     | 11 ++++--
 include/drm/ttm/ttm_page_alloc.h | 18 +++++++---
 4 files changed, 66 insertions(+), 73 deletions(-)

diff --git a/include/drm/ttm/ttm_bo_api.h b/include/drm/ttm/ttm_bo_api.h
index c18238f..f885bfc 100644
--- a/include/drm/ttm/ttm_bo_api.h
+++ b/include/drm/ttm/ttm_bo_api.h
@@ -41,6 +41,8 @@
 #include <linux/bitmap.h>
 #include <linux/reservation.h>
 
+struct ttm_bo_global;
+
 struct ttm_bo_device;
 
 struct drm_mm_node;
@@ -169,7 +171,6 @@ struct ttm_buffer_object {
 	 * Members constant at init.
 	 */
 
-	struct ttm_bo_global *glob;
 	struct ttm_bo_device *bdev;
 	enum ttm_bo_type type;
 	void (*destroy) (struct ttm_buffer_object *);
@@ -225,7 +226,6 @@ struct ttm_buffer_object {
 	 */
 
 	uint64_t offset; /* GPU address space is independent of CPU word size */
-	uint32_t cur_placement;
 
 	struct sg_table *sg;
 
@@ -471,7 +471,6 @@ size_t ttm_bo_dma_acc_size(struct ttm_bo_device *bdev,
  * @page_alignment: Data alignment in pages.
  * @interruptible: If needing to sleep to wait for GPU resources,
  * sleep interruptible.
- * @persistent_swap_storage: Usually the swap storage is deleted for buffers
  * pinned in physical memory. If this behaviour is not desired, this member
  * holds a pointer to a persistent shmem object. Typically, this would
  * point to the shmem object backing a GEM object if TTM is used to back a
@@ -500,19 +499,17 @@ size_t ttm_bo_dma_acc_size(struct ttm_bo_device *bdev,
  * -EINVAL: Invalid placement flags.
  * -ERESTARTSYS: Interrupted by signal while sleeping waiting for resources.
  */
-
 extern int ttm_bo_init_reserved(struct ttm_bo_device *bdev,
-				struct ttm_buffer_object *bo,
-				unsigned long size,
-				enum ttm_bo_type type,
-				struct ttm_placement *placement,
-				uint32_t page_alignment,
-				bool interrubtible,
-				struct file *persistent_swap_storage,
-				size_t acc_size,
-				struct sg_table *sg,
-				struct reservation_object *resv,
-				void (*destroy) (struct ttm_buffer_object *));
+			struct ttm_buffer_object *bo,
+			unsigned long size,
+			enum ttm_bo_type type,
+			struct ttm_placement *placement,
+			uint32_t page_alignment,
+			struct ttm_operation_ctx *ctx,
+			size_t acc_size,
+			struct sg_table *sg,
+			struct reservation_object *resv,
+			void (*destroy) (struct ttm_buffer_object *));
 
 /**
  * ttm_bo_init
@@ -523,13 +520,7 @@ extern int ttm_bo_init_reserved(struct ttm_bo_device *bdev,
  * @type: Requested type of buffer object.
  * @flags: Initial placement flags.
  * @page_alignment: Data alignment in pages.
- * @interruptible: If needing to sleep to wait for GPU resources,
- * sleep interruptible.
- * @persistent_swap_storage: Usually the swap storage is deleted for buffers
- * pinned in physical memory. If this behaviour is not desired, this member
- * holds a pointer to a persistent shmem object. Typically, this would
- * point to the shmem object backing a GEM object if TTM is used to back a
- * GEM user interface.
+ * @ctx: TTM operation context for memory allocation.
  * @acc_size: Accounted size for this object.
  * @resv: Pointer to a reservation_object, or NULL to let ttm allocate one.
  * @destroy: Destroy function. Use NULL for kfree().
@@ -552,19 +543,12 @@ extern int ttm_bo_init_reserved(struct ttm_bo_device *bdev,
  * -EINVAL: Invalid placement flags.
  * -ERESTARTSYS: Interrupted by signal while sleeping waiting for resources.
  */
-
-extern int ttm_bo_init(struct ttm_bo_device *bdev,
-			struct ttm_buffer_object *bo,
-			unsigned long size,
-			enum ttm_bo_type type,
-			struct ttm_placement *placement,
-			uint32_t page_alignment,
-			bool interrubtible,
-			struct file *persistent_swap_storage,
-			size_t acc_size,
-			struct sg_table *sg,
-			struct reservation_object *resv,
-			void (*destroy) (struct ttm_buffer_object *));
+extern int ttm_bo_init(struct ttm_bo_device *bdev, struct ttm_buffer_object *bo,
+		unsigned long size, enum ttm_bo_type type,
+		struct ttm_placement *placement,
+		uint32_t page_alignment, bool interrubtible, size_t acc_size,
+		struct sg_table *sg, struct reservation_object *resv,
+		void (*destroy) (struct ttm_buffer_object *));
 
 /**
  * ttm_bo_create
@@ -576,11 +560,6 @@ extern int ttm_bo_init(struct ttm_bo_device *bdev,
  * @page_alignment: Data alignment in pages.
  * @interruptible: If needing to sleep while waiting for GPU resources,
  * sleep interruptible.
- * @persistent_swap_storage: Usually the swap storage is deleted for buffers
- * pinned in physical memory. If this behaviour is not desired, this member
- * holds a pointer to a persistent shmem object. Typically, this would
- * point to the shmem object backing a GEM object if TTM is used to back a
- * GEM user interface.
  * @p_bo: On successful completion *p_bo points to the created object.
  *
  * This function allocates a ttm_buffer_object, and then calls ttm_bo_init
@@ -590,15 +569,10 @@ extern int ttm_bo_init(struct ttm_bo_device *bdev,
  * -EINVAL: Invalid placement flags.
  * -ERESTARTSYS: Interrupted by signal while waiting for resources.
  */
-
-extern int ttm_bo_create(struct ttm_bo_device *bdev,
-				unsigned long size,
-				enum ttm_bo_type type,
-				struct ttm_placement *placement,
-				uint32_t page_alignment,
-				bool interruptible,
-				struct file *persistent_swap_storage,
-				struct ttm_buffer_object **p_bo);
+extern int ttm_bo_create(struct ttm_bo_device *bdev, unsigned long size,
+		enum ttm_bo_type type, struct ttm_placement *placement,
+		uint32_t page_alignment, bool interruptible,
+		struct ttm_buffer_object **p_bo);
 
 /**
  * ttm_bo_init_mm
@@ -780,7 +754,8 @@ extern int ttm_bo_mmap(struct file *filp, struct vm_area_struct *vma,
 extern ssize_t ttm_bo_io(struct ttm_bo_device *bdev, struct file *filp,
 			 const char __user *wbuf, char __user *rbuf,
 			 size_t count, loff_t *f_pos, bool write);
-
+extern int ttm_bo_swapout(struct ttm_bo_global *glob,
+			struct ttm_operation_ctx *ctx);
 extern void ttm_bo_swapout_all(struct ttm_bo_device *bdev);
 extern int ttm_bo_wait_unreserved(struct ttm_buffer_object *bo);
 #endif
diff --git a/include/drm/ttm/ttm_bo_driver.h b/include/drm/ttm/ttm_bo_driver.h
index 4ff54e3..2f71269 100644
--- a/include/drm/ttm/ttm_bo_driver.h
+++ b/include/drm/ttm/ttm_bo_driver.h
@@ -330,7 +330,6 @@ struct ttm_bo_driver {
 	 * ttm_tt_create
 	 * @bo: The buffer object to create the ttm for.*
 	 * @page_flags: Page flags as identified by TTM_PAGE_FLAG_XX flags.
-	 * @dummy_read_page: See struct ttm_bo_device.
 	 *
 	 * Create a struct ttm_tt to back data with system memory pages.
 	 * No pages are actually allocated.
@@ -348,8 +347,8 @@ struct ttm_bo_driver {
 	 * Returns:
 	 * -ENOMEM: Out of memory.
 	 */
-	int (*ttm_tt_populate)(struct ttm_tt *ttm);
-
+	int (*ttm_tt_populate)(struct ttm_tt *ttm,
+			struct ttm_operation_ctx *ctx);
 	/**
 	 * ttm_tt_unpopulate
 	 *
@@ -405,15 +404,13 @@ struct ttm_bo_driver {
 	 * @bo: the buffer to move
 	 * @evict: whether this motion is evicting the buffer from
 	 * the graphics address space
-	 * @interruptible: Use interruptible sleeps if possible when sleeping.
-	 * @no_wait: whether this should give up and return -EBUSY
-	 * if this move would require sleeping
+	 * @ctx: context for this move with parameters
 	 * @new_mem: the new memory region receiving the buffer
 	 *
 	 * Move a buffer between two memory regions.
 	 */
 	int (*move)(struct ttm_buffer_object *bo, bool evict,
-		    bool interruptible, bool no_wait_gpu,
+		    struct ttm_operation_ctx *ctx,
 		    struct ttm_mem_reg *new_mem);
 
 	/**
@@ -520,7 +517,6 @@ struct ttm_bo_global {
 	struct kobject kobj;
 	struct ttm_mem_global *mem_glob;
 	struct page *dummy_read_page;
-	struct ttm_mem_shrink shrink;
 	struct mutex device_list_mutex;
 	spinlock_t lru_lock;
 
@@ -554,6 +550,7 @@ struct ttm_bo_global {
  * @dev_mapping: A pointer to the struct address_space representing the
  * device address space.
  * @wq: Work queue structure for the delayed delete workqueue.
+ * @no_retry: Don't retry allocation if it fails
  *
  */
 
@@ -959,9 +956,10 @@ static inline void __ttm_bo_unreserve(struct ttm_buffer_object *bo)
 static inline void ttm_bo_unreserve(struct ttm_buffer_object *bo)
 {
 	if (!(bo->mem.placement & TTM_PL_FLAG_NO_EVICT)) {
-		spin_lock(&bo->glob->lru_lock);
+		spin_lock(&bo->bdev->glob->lru_lock);
 		ttm_bo_add_to_lru(bo);
 		spin_unlock(&bo->glob->lru_lock);
+		spin_unlock(&bo->bdev->glob->lru_lock);
 	}
 	__ttm_bo_unreserve(bo);
 }
@@ -1004,10 +1002,9 @@ void ttm_mem_io_free(struct ttm_bo_device *bdev,
  * Returns:
  * !0: Failure.
  */
-
 extern int ttm_bo_move_ttm(struct ttm_buffer_object *bo,
-			   bool interruptible, bool no_wait_gpu,
-			   struct ttm_mem_reg *new_mem);
+			struct ttm_operation_ctx *ctx,
+			struct ttm_mem_reg *new_mem);
 
 /**
  * ttm_bo_move_memcpy
@@ -1026,10 +1023,9 @@ extern int ttm_bo_move_ttm(struct ttm_buffer_object *bo,
  * Returns:
  * !0: Failure.
  */
-
 extern int ttm_bo_move_memcpy(struct ttm_buffer_object *bo,
-			      bool interruptible, bool no_wait_gpu,
-			      struct ttm_mem_reg *new_mem);
+			struct ttm_operation_ctx *ctx,
+			struct ttm_mem_reg *new_mem);
 
 /**
  * ttm_bo_free_old_node
@@ -1076,6 +1072,15 @@ int ttm_bo_pipeline_move(struct ttm_buffer_object *bo,
 			 struct ttm_mem_reg *new_mem);
 
 /**
+ * ttm_bo_pipeline_gutting.
+ *
+ * @bo: A pointer to a struct ttm_buffer_object.
+ *
+ * Pipelined gutting a BO of it's backing store.
+ */
+int ttm_bo_pipeline_gutting(struct ttm_buffer_object *bo);
+
+/**
  * ttm_io_prot
  *
  * @c_state: Caching state.
diff --git a/include/drm/ttm/ttm_memory.h b/include/drm/ttm/ttm_memory.h
index 39197a2..c8885bc9 100644
--- a/include/drm/ttm/ttm_memory.h
+++ b/include/drm/ttm/ttm_memory.h
@@ -63,6 +63,8 @@ struct ttm_mem_shrink {
  * @work: The workqueue callback for the shrink queue.
  * @lock: Lock to protect the @shrink - and the memory accounting members,
  * that is, essentially the whole structure with some exceptions.
+ * @lower_mem_limit: include lower limit of swap space and lower limit of
+ * system memory.
  * @zones: Array of pointers to accounting zones.
  * @num_zones: Number of populated entries in the @zones array.
  * @zone_kernel: Pointer to the kernel zone.
@@ -77,10 +79,11 @@ struct ttm_mem_shrink {
 struct ttm_mem_zone;
 struct ttm_mem_global {
 	struct kobject kobj;
-	struct ttm_mem_shrink *shrink;
+	struct ttm_bo_global *bo_glob;
 	struct workqueue_struct *swap_queue;
 	struct work_struct work;
 	spinlock_t lock;
+	uint64_t lower_mem_limit;
 	struct ttm_mem_zone *zones[TTM_MEM_MAX_ZONES];
 	unsigned int num_zones;
 	struct ttm_mem_zone *zone_kernel;
@@ -151,10 +154,12 @@ extern int ttm_mem_global_alloc(struct ttm_mem_global *glob, uint64_t memory,
 extern void ttm_mem_global_free(struct ttm_mem_global *glob,
 				uint64_t amount);
 extern int ttm_mem_global_alloc_page(struct ttm_mem_global *glob,
-				     struct page *page,
-				     bool no_wait, bool interruptible);
+                                    struct page *page, uint64_t size,
+                                    struct ttm_operation_ctx *ctx);
 extern void ttm_mem_global_free_page(struct ttm_mem_global *glob,
 				     struct page *page);
 extern size_t ttm_round_pot(size_t size);
 extern uint64_t ttm_get_kernel_zone_memory_size(struct ttm_mem_global *glob);
+extern bool ttm_check_under_lowerlimit(struct ttm_mem_global *glob,
+                       uint64_t num_pages, struct ttm_operation_ctx *ctx);
 #endif
diff --git a/include/drm/ttm/ttm_page_alloc.h b/include/drm/ttm/ttm_page_alloc.h
index 8695918..80aa53c 100644
--- a/include/drm/ttm/ttm_page_alloc.h
+++ b/include/drm/ttm/ttm_page_alloc.h
@@ -47,7 +47,7 @@ void ttm_page_alloc_fini(void);
  *
  * Add backing pages to all of @ttm
  */
-extern int ttm_pool_populate(struct ttm_tt *ttm);
+extern int ttm_pool_populate(struct ttm_tt *ttm, struct ttm_operation_ctx *ctx);
 
 /**
  * ttm_pool_unpopulate:
@@ -58,12 +58,19 @@ extern int ttm_pool_populate(struct ttm_tt *ttm);
  */
 extern void ttm_pool_unpopulate(struct ttm_tt *ttm);
 
+extern +int ttm_populate_and_map_pages(struct device *dev, struct ttm_dma_tt *tt,
+                               struct ttm_operation_ctx *ctx);
+
+/**
+ * Unpopulates and DMA unmaps pages as part of a
+ * ttm_dma_unpopulate() request */
+extern void ttm_unmap_and_unpopulate_pages(struct device *dev, struct ttm_dma_tt *tt);
+
 /**
  * Output the state of pools to debugfs file
  */
 extern int ttm_page_alloc_debugfs(struct seq_file *m, void *data);
 
-
 #if defined(CONFIG_SWIOTLB) || defined(CONFIG_INTEL_IOMMU)
 /**
  * Initialize pool allocator.
@@ -80,10 +87,10 @@ void ttm_dma_page_alloc_fini(void);
  */
 extern int ttm_dma_page_alloc_debugfs(struct seq_file *m, void *data);
 
-extern int ttm_dma_populate(struct ttm_dma_tt *ttm_dma, struct device *dev);
+extern int ttm_dma_populate(struct ttm_dma_tt *ttm_dma, struct device *dev,
+                       struct ttm_operation_ctx *ctx);
 extern void ttm_dma_unpopulate(struct ttm_dma_tt *ttm_dma, struct device *dev);
 
-
 /**
  * Populates and DMA maps pages to fullfil a ttm_dma_populate() request
  */
@@ -108,7 +115,8 @@ static inline int ttm_dma_page_alloc_debugfs(struct seq_file *m, void *data)
 	return 0;
 }
 static inline int ttm_dma_populate(struct ttm_dma_tt *ttm_dma,
-				   struct device *dev)
+                               struct device *dev,
+                               struct ttm_operation_ctx *ctx)
 {
 	return -ENOMEM;
 }
-- 
2.7.4

