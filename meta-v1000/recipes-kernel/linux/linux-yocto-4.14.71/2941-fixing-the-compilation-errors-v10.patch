From 0ac0c106a97bd9a2fc75267bf32b371bf2bd4f18 Mon Sep 17 00:00:00 2001
From: Kalyan Alle <kalyan.alle@amd.com>
Date: Thu, 26 Apr 2018 12:13:19 +0530
Subject: [PATCH 2941/4131] fixing the compilation errors v10

This patch fixes the compilation errors prompted
during porting from branch: 1md-18.10, repo:brahma/ec/linux
till commit :cedeeafd3a09a0bb5aa7ce544bb99513183f14f2

Signed-off-by: kalyan alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/include/kgd_kfd_interface.h |   2 +
 drivers/gpu/drm/radeon/radeon_kfd.c             |   7 --
 drivers/pci/pci.c                               | 101 +++++++++++++++++++++++
 drivers/pci/pci.h                               |   8 ++
 drivers/pci/setup-bus.c                         | 103 ++++++++++++++++++++++++
 drivers/pci/setup-res.c                         |  58 +++++++++++++
 include/linux/pci.h                             |   3 +
 include/uapi/linux/pci_regs.h                   |  10 ++-
 8 files changed, 282 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/amd/include/kgd_kfd_interface.h b/drivers/gpu/drm/amd/include/kgd_kfd_interface.h
index 3271d86..f94f49b 100644
--- a/drivers/gpu/drm/amd/include/kgd_kfd_interface.h
+++ b/drivers/gpu/drm/amd/include/kgd_kfd_interface.h
@@ -340,6 +340,8 @@ struct kfd2kgd_calls {
 	uint16_t (*get_atc_vmid_pasid_mapping_pasid)(
 					struct kgd_dev *kgd,
 					uint8_t vmid);
+	void (*write_vmid_invalidate_request)(struct kgd_dev *kgd,
+						uint8_t vmid);
 	uint32_t (*read_vmid_from_vmfault_reg)(struct kgd_dev *kgd);
 
 	int (*invalidate_tlbs)(struct kgd_dev *kgd, uint16_t pasid);
diff --git a/drivers/gpu/drm/radeon/radeon_kfd.c b/drivers/gpu/drm/radeon/radeon_kfd.c
index e852be6..8908d1d 100755
--- a/drivers/gpu/drm/radeon/radeon_kfd.c
+++ b/drivers/gpu/drm/radeon/radeon_kfd.c
@@ -150,7 +150,6 @@ static int alloc_memory_of_scratch(struct kgd_dev *kgd,
 					 uint64_t va, uint32_t vmid);
 static int write_config_static_mem(struct kgd_dev *kgd, bool swizzle_enable,
 		uint8_t element_size, uint8_t index_stride, uint8_t mtype);
-static int mmap_bo(struct kgd_dev *kgd, struct vm_area_struct *vma);
 static int map_gtt_bo_to_kernel(struct kgd_dev *kgd,
 			struct kgd_mem *mem, void **kptr);
 static void set_vm_context_page_table_base(struct kgd_dev *kgd, uint32_t vmid,
@@ -192,7 +191,6 @@ static const struct kfd2kgd_calls kfd2kgd = {
 	.get_cu_info = get_cu_info,
 	.alloc_memory_of_scratch = alloc_memory_of_scratch,
 	.write_config_static_mem = write_config_static_mem,
-	.mmap_bo = mmap_bo,
 	.map_gtt_bo_to_kernel = map_gtt_bo_to_kernel,
 	.set_vm_context_page_table_base = set_vm_context_page_table_base,
 };
@@ -1645,11 +1643,6 @@ static void get_cu_info(struct kgd_dev *kgd, struct kfd_cu_info *cu_info)
 	cu_info->lds_size = rcu_info.lds_size;
 }
 
-static int mmap_bo(struct kgd_dev *kgd, struct vm_area_struct *vma)
-{
-	return 0;
-}
-
 static int map_gtt_bo_to_kernel(struct kgd_dev *kgd,
 			struct kgd_mem *mem, void **kptr)
 {
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 82d97f3..06dfd52 100755
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3064,6 +3064,107 @@ int pci_enable_atomic_ops_to_root(struct pci_dev *dev)
 EXPORT_SYMBOL(pci_enable_atomic_ops_to_root);
 
 /**
+ * pci_rebar_find_pos - find position of resize ctrl reg for BAR
+ * @pdev: PCI device
+ * @bar: BAR to find
+ *
+ * Helper to find the position of the ctrl register for a BAR.
+ * Returns -ENOTSUPP if resizable BARs are not supported at all.
+ * Returns -ENOENT if no ctrl register for the BAR could be found.
+ */
+static int pci_rebar_find_pos(struct pci_dev *pdev, int bar)
+{
+        unsigned int pos, nbars, i;
+        u32 ctrl;
+
+        pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_REBAR);
+        if (!pos)
+                return -ENOTSUPP;
+
+        pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+        nbars = (ctrl & PCI_REBAR_CTRL_NBAR_MASK) >>
+                    PCI_REBAR_CTRL_NBAR_SHIFT;
+
+        for (i = 0; i < nbars; i++, pos += 8) {
+                int bar_idx;
+
+                pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+                bar_idx = ctrl & PCI_REBAR_CTRL_BAR_IDX;
+                if (bar_idx == bar)
+                        return pos;
+        }
+
+        return -ENOENT;
+}
+
+/**
+ * pci_rebar_get_possible_sizes - get possible sizes for BAR
+ * @pdev: PCI device
+ * @bar: BAR to query
+ *
+ * Get the possible sizes of a resizable BAR as bitmask defined in the spec
+ * (bit 0=1MB, bit 19=512GB). Returns 0 if BAR isn't resizable.
+ */
+u32 pci_rebar_get_possible_sizes(struct pci_dev *pdev, int bar)
+{
+        int pos;
+        u32 cap;
+
+        pos = pci_rebar_find_pos(pdev, bar);
+        if (pos < 0)
+                return 0;
+
+        pci_read_config_dword(pdev, pos + PCI_REBAR_CAP, &cap);
+        return (cap & PCI_REBAR_CAP_SIZES) >> 4;
+}
+
+/**
+ * pci_rebar_get_current_size - get the current size of a BAR
+ * @pdev: PCI device
+ * @bar: BAR to set size to
+ *
+ * Read the size of a BAR from the resizable BAR config.
+ * Returns size if found or negative error code.
+ */
+int pci_rebar_get_current_size(struct pci_dev *pdev, int bar)
+{
+        int pos;
+        u32 ctrl;
+
+        pos = pci_rebar_find_pos(pdev, bar);
+        if (pos < 0)
+                return pos;
+
+        pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+        return (ctrl & PCI_REBAR_CTRL_BAR_SIZE) >> 8;
+}
+
+/**
+ * pci_rebar_set_size - set a new size for a BAR
+ * @pdev: PCI device
+ * @bar: BAR to set size to
+ * @size: new size as defined in the spec (0=1MB, 19=512GB)
+ *
+ * Set the new size of a BAR as defined in the spec.
+ * Returns zero if resizing was successful, error code otherwise.
+ */
+int pci_rebar_set_size(struct pci_dev *pdev, int bar, int size)
+{
+        int pos;
+        u32 ctrl;
+
+        pos = pci_rebar_find_pos(pdev, bar);
+        if (pos < 0)
+                return pos;
+
+        pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+        ctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;
+        ctrl |= size << 8;
+        pci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);
+        return 0;
+}
+
+/**
  * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge
  * @dev: the PCI device
  * @pin: the INTx pin (1=INTA, 2=INTB, 3=INTC, 4=INTD)
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
index fdb02c1..6e7a181 100644
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -367,4 +367,12 @@ int acpi_get_rc_resources(struct device *dev, const char *hid, u16 segment,
 			  struct resource *res);
 #endif
 
+u32 pci_rebar_get_possible_sizes(struct pci_dev *pdev, int bar);
+int pci_rebar_get_current_size(struct pci_dev *pdev, int bar);
+int pci_rebar_set_size(struct pci_dev *pdev, int bar, int size);
+static inline u64 pci_rebar_size_to_bytes(int size)
+{
+        return 1ULL << (size + 20);
+}
+
 #endif /* DRIVERS_PCI_H */
diff --git a/drivers/pci/setup-bus.c b/drivers/pci/setup-bus.c
index 958da7d..ffe5bb0 100644
--- a/drivers/pci/setup-bus.c
+++ b/drivers/pci/setup-bus.c
@@ -1518,6 +1518,11 @@ static void __pci_bridge_assign_resources(const struct pci_dev *bridge,
 		break;
 	}
 }
+
+#define PCI_RES_TYPE_MASK \
+        (IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_PREFETCH |\
+         IORESOURCE_MEM_64)
+
 static void pci_bridge_release_resources(struct pci_bus *bus,
 					  unsigned long type)
 {
@@ -1914,6 +1919,104 @@ void pci_assign_unassigned_bridge_resources(struct pci_dev *bridge)
 }
 EXPORT_SYMBOL_GPL(pci_assign_unassigned_bridge_resources);
 
+int pci_reassign_bridge_resources(struct pci_dev *bridge, unsigned long type)
+{
+        struct pci_dev_resource *dev_res;
+        struct pci_dev *next;
+        LIST_HEAD(saved);
+        LIST_HEAD(added);
+        LIST_HEAD(failed);
+        unsigned int i;
+        int ret;
+
+        /* Walk to the root hub, releasing bridge BARs when possible */
+        next = bridge;
+        do {
+                bridge = next;
+                for (i = PCI_BRIDGE_RESOURCES; i < PCI_BRIDGE_RESOURCE_END;
+                     i++) {
+                        struct resource *res = &bridge->resource[i];
+
+                        if ((res->flags ^ type) & PCI_RES_TYPE_MASK)
+                                continue;
+
+                        /* Ignore BARs which are still in use */
+                        if (res->child)
+                                continue;
+
+                        ret = add_to_list(&saved, bridge, res, 0, 0);
+                        if (ret)
+                                goto cleanup;
+
+                        dev_info(&bridge->dev, "BAR %d: releasing %pR\n",
+                                 i, res);
+
+                        if (res->parent)
+                                release_resource(res);
+                        res->start = 0;
+                        res->end = 0;
+                        break;
+                }
+                if (i == PCI_BRIDGE_RESOURCE_END)
+                        break;
+
+                next = bridge->bus ? bridge->bus->self : NULL;
+        } while (next);
+
+        if (list_empty(&saved))
+                return -ENOENT;
+
+        __pci_bus_size_bridges(bridge->subordinate, &added);
+        __pci_bridge_assign_resources(bridge, &added, &failed);
+        BUG_ON(!list_empty(&added));
+
+        if (!list_empty(&failed)) {
+                ret = -ENOSPC;
+                goto cleanup;
+        }
+
+        list_for_each_entry(dev_res, &saved, list) {
+                /* Skip the bridge we just assigned resources for. */
+                if (bridge == dev_res->dev)
+                        continue;
+
+                bridge = dev_res->dev;
+                pci_setup_bridge(bridge->subordinate);
+        }
+
+        free_list(&saved);
+        return 0;
+
+cleanup:
+        /* restore size and flags */
+        list_for_each_entry(dev_res, &failed, list) {
+                struct resource *res = dev_res->res;
+
+                res->start = dev_res->start;
+                res->end = dev_res->end;
+                res->flags = dev_res->flags;
+        }
+        free_list(&failed);
+
+        /* Revert to the old configuration */
+        list_for_each_entry(dev_res, &saved, list) {
+                struct resource *res = dev_res->res;
+
+                bridge = dev_res->dev;
+                i = res - bridge->resource;
+
+                res->start = dev_res->start;
+                res->end = dev_res->end;
+                res->flags = dev_res->flags;
+
+                pci_claim_resource(bridge, i);
+                pci_setup_bridge(bridge->subordinate);
+        }
+        free_list(&saved);
+
+        return ret;
+}
+
 void pci_assign_unassigned_bus_resources(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index c039149..54b3cb1 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -397,6 +397,64 @@ int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsiz
 	return 0;
 }
 
+void pci_release_resource(struct pci_dev *dev, int resno)
+{
+        struct resource *res = dev->resource + resno;
+
+        dev_info(&dev->dev, "BAR %d: releasing %pR\n", resno, res);
+        release_resource(res);
+        res->end = resource_size(res) - 1;
+        res->start = 0;
+        res->flags |= IORESOURCE_UNSET;
+}
+EXPORT_SYMBOL(pci_release_resource);
+
+int pci_resize_resource(struct pci_dev *dev, int resno, int size)
+{
+        struct resource *res = dev->resource + resno;
+        int old, ret;
+        u32 sizes;
+        u16 cmd;
+
+        /* Make sure the resource isn't assigned before resizing it. */
+        if (!(res->flags & IORESOURCE_UNSET))
+                return -EBUSY;
+
+        pci_read_config_word(dev, PCI_COMMAND, &cmd);
+        if (cmd & PCI_COMMAND_MEMORY)
+                return -EBUSY;
+
+        sizes = pci_rebar_get_possible_sizes(dev, resno);
+        if (!sizes)
+                return -ENOTSUPP;
+
+        if (!(sizes & BIT(size)))
+                return -EINVAL;
+
+        old = pci_rebar_get_current_size(dev, resno);
+        if (old < 0)
+                return old;
+
+        ret = pci_rebar_set_size(dev, resno, size);
+        if (ret)
+                return ret;
+
+        res->end = res->start + pci_rebar_size_to_bytes(size) - 1;
+
+        /* Check if the new config works by trying to assign everything. */
+        ret = pci_reassign_bridge_resources(dev->bus->self, res->flags);
+        if (ret)
+                goto error_resize;
+
+        return 0;
+
+error_resize:
+        pci_rebar_set_size(dev, resno, old);
+        res->end = res->start + pci_rebar_size_to_bytes(old) - 1;
+        return ret;
+}
+EXPORT_SYMBOL(pci_resize_resource);
+
 int pci_enable_resources(struct pci_dev *dev, int mask)
 {
 	u16 cmd, old_cmd;
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 3df545d..339f5b7 100755
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -1107,6 +1107,8 @@ void pci_reset_bridge_secondary_bus(struct pci_dev *dev);
 void pci_update_resource(struct pci_dev *dev, int resno);
 int __must_check pci_assign_resource(struct pci_dev *dev, int i);
 int __must_check pci_reassign_resource(struct pci_dev *dev, int i, resource_size_t add_size, resource_size_t align);
+void pci_release_resource(struct pci_dev *dev, int resno);
+int __must_check pci_resize_resource(struct pci_dev *dev, int i, int size);
 int pci_select_bars(struct pci_dev *dev, unsigned long flags);
 bool pci_device_is_present(struct pci_dev *pdev);
 void pci_ignore_hotplug(struct pci_dev *dev);
@@ -1186,6 +1188,7 @@ void pci_assign_unassigned_resources(void);
 void pci_assign_unassigned_bridge_resources(struct pci_dev *bridge);
 void pci_assign_unassigned_bus_resources(struct pci_bus *bus);
 void pci_assign_unassigned_root_bus_resources(struct pci_bus *bus);
+int pci_reassign_bridge_resources(struct pci_dev *bridge, unsigned long type);
 void pdev_enable_device(struct pci_dev *);
 int pci_enable_resources(struct pci_dev *, int mask);
 void pci_assign_irq(struct pci_dev *dev);
diff --git a/include/uapi/linux/pci_regs.h b/include/uapi/linux/pci_regs.h
index 1256851..009a432 100755
--- a/include/uapi/linux/pci_regs.h
+++ b/include/uapi/linux/pci_regs.h
@@ -943,9 +943,13 @@
 #define PCI_SATA_SIZEOF_LONG	16
 
 /* Resizable BARs */
-#define PCI_REBAR_CTRL		8	/* control register */
-#define  PCI_REBAR_CTRL_NBAR_MASK	(7 << 5)	/* mask for # bars */
-#define  PCI_REBAR_CTRL_NBAR_SHIFT	5	/* shift for # bars */
+#define PCI_REBAR_CAP           4       /* capability register */
+#define  PCI_REBAR_CAP_SIZES            0x00FFFFF0  /* supported BAR sizes */
+#define PCI_REBAR_CTRL          8       /* control register */
+#define  PCI_REBAR_CTRL_BAR_IDX         0x00000007  /* BAR index */
+#define  PCI_REBAR_CTRL_NBAR_MASK       0x000000E0  /* # of resizable BARs */
+#define  PCI_REBAR_CTRL_NBAR_SHIFT      5           /* shift for # of BARs */
+#define  PCI_REBAR_CTRL_BAR_SIZE        0x00001F00  /* BAR size */
 
 /* Dynamic Power Allocation */
 #define PCI_DPA_CAP		4	/* capability register */
-- 
2.7.4

