From deae27f7a94dbd5009815a3bc62443b3d5db9233 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christian=20K=C3=B6nig?= <christian.koenig@amd.com>
Date: Mon, 10 Sep 2018 20:02:46 +0200
Subject: [PATCH 5416/5725] drm/amdgpu: use a single linked list for
 amdgpu_vm_bo_base
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Instead of the double linked list. Gets the size of amdgpu_vm_pt down to
64 bytes again.

We could even reduce it down to 32 bytes, but that would require some
rather extreme hacks.

Signed-off-by: Christian KÃ¶nig <christian.koenig@amd.com>
Reviewed-by: Chunming Zhou <david1.zhou@amd.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Signed-off-by: Raveendra Talabattula <raveendra.talabattula@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.c |  4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.h |  4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c     | 72 +++++++++++++++++-------------
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h     |  2 +-
 4 files changed, 47 insertions(+), 35 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
index b2947f4..77f0d2e 100755
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
@@ -469,10 +469,10 @@ static int amdgpu_bo_do_create(struct amdgpu_device *adev,
 
 	bo = kzalloc(sizeof(struct amdgpu_bo), GFP_KERNEL);
 	if (bo == NULL)
-	return -ENOMEM;
+		return -ENOMEM;
 	drm_gem_private_object_init(adev->ddev, &bo->gem_base, size);
 	INIT_LIST_HEAD(&bo->shadow_list);
-	INIT_LIST_HEAD(&bo->va);
+	bo->vm_bo = NULL;
 	bo->preferred_domains = bp->preferred_domain ? bp->preferred_domain :
 		bp->domain;
 	bo->allowed_domains = bo->preferred_domains;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
index 3674265..9a5c138 100755
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
@@ -89,8 +89,8 @@ struct amdgpu_bo {
 	void				*metadata;
 	u32				metadata_size;
 	unsigned			prime_shared_count;
-	/* list of all virtual address to which this bo is associated to */
-	struct list_head		va;
+	/* per VM structure for page tables and with virtual addresses */
+	struct amdgpu_vm_bo_base        *vm_bo;
 	/* Constant after initialization */
 	struct drm_gem_object           gem_base;
 	struct amdgpu_bo		*parent;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index d359284..1e09cf3 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
@@ -273,33 +273,34 @@ static void amdgpu_vm_bo_done(struct amdgpu_vm_bo_base *vm_bo)
  *
  */
 static void amdgpu_vm_bo_base_init(struct amdgpu_vm_bo_base *base,
-                                   struct amdgpu_vm *vm,
-                                   struct amdgpu_bo *bo)
+		struct amdgpu_vm *vm,
+		struct amdgpu_bo *bo)
 {
-        base->vm = vm;
-        base->bo = bo;
-        INIT_LIST_HEAD(&base->bo_list);
-        INIT_LIST_HEAD(&base->vm_status);
+	base->vm = vm;
+	base->bo = bo;
+	base->next = NULL;
+	INIT_LIST_HEAD(&base->vm_status);
 
-        if (!bo)
-                return;
-        list_add_tail(&base->bo_list, &bo->va);
+	if (!bo)
+		return;
+	base->next = bo->vm_bo;
+	bo->vm_bo = base;
 
-        if (bo->tbo.type == ttm_bo_type_kernel)
-                amdgpu_vm_bo_relocated(base);
+	if (bo->tbo.type == ttm_bo_type_kernel)
+		amdgpu_vm_bo_relocated(base);
 
-        if (bo->tbo.resv != vm->root.base.bo->tbo.resv)
-                return;
+	if (bo->tbo.resv != vm->root.base.bo->tbo.resv)
+		return;
 
-        if (bo->preferred_domains &
-            amdgpu_mem_type_to_domain(bo->tbo.mem.mem_type))
-                return;
+	if (bo->preferred_domains &
+			amdgpu_mem_type_to_domain(bo->tbo.mem.mem_type))
+		return;
 
-        /*
-         * we checked all the prerequisites, but it looks like this per vm bo
-         * is currently evicted. add the bo to the evicted list to make sure it
-         * is validated on next vm use to avoid fault.
-         * */
+	/*
+	 * we checked all the prerequisites, but it looks like this per vm bo
+	 * is currently evicted. add the bo to the evicted list to make sure it
+	 * is validated on next vm use to avoid fault.
+	 * */
 	amdgpu_vm_bo_evicted(base);
 }
 
@@ -318,7 +319,7 @@ static struct amdgpu_vm_pt *amdgpu_vm_pt_parent(struct amdgpu_vm_pt *pt)
 	if (!parent)
 		return NULL;
 
-	return list_first_entry(&parent->va, struct amdgpu_vm_pt, base.bo_list);
+	return container_of(parent->vm_bo, struct amdgpu_vm_pt, base);
 }
 
 /**
@@ -883,7 +884,7 @@ static void amdgpu_vm_free_pts(struct amdgpu_device *adev,
 	for_each_amdgpu_vm_pt_dfs_safe(adev, vm, cursor, entry) {
 
 		if (entry->base.bo) {
-			list_del(&entry->base.bo_list);
+			entry->base.bo->vm_bo = NULL;
 			list_del(&entry->base.vm_status);
 			amdgpu_bo_unref(&entry->base.bo->shadow);
 			amdgpu_bo_unref(&entry->base.bo);
@@ -1091,12 +1092,13 @@ int amdgpu_vm_flush(struct amdgpu_ring *ring, struct amdgpu_job *job, bool need_
 struct amdgpu_bo_va *amdgpu_vm_bo_find(struct amdgpu_vm *vm,
 				       struct amdgpu_bo *bo)
 {
-	struct amdgpu_bo_va *bo_va;
+	struct amdgpu_vm_bo_base *base;
 
-	list_for_each_entry(bo_va, &bo->va, base.bo_list) {
-		if (bo_va->base.vm == vm) {
-			return bo_va;
-		}
+	for (base = bo->vm_bo; base; base = base->next) {
+		if (base->vm != vm)
+			continue;
+
+		return container_of(base, struct amdgpu_bo_va, base);
 	}
 	return NULL;
 }
@@ -2649,9 +2651,19 @@ void amdgpu_vm_bo_rmv(struct amdgpu_device *adev,
 		      struct amdgpu_bo_va *bo_va)
 {
 	struct amdgpu_bo_va_mapping *mapping, *next;
+	struct amdgpu_bo *bo = bo_va->base.bo;
 	struct amdgpu_vm *vm = bo_va->base.vm;
+	struct amdgpu_vm_bo_base **base;
 
-	list_del(&bo_va->base.bo_list);
+	if (bo) {
+		for (base = &bo_va->base.bo->vm_bo; *base;
+				base = &(*base)->next) {
+			if (*base != &bo_va->base)
+				continue;
+			*base = bo_va->base.next;
+			break;
+		}
+	}
 
 	spin_lock(&vm->moved_lock);
 	list_del(&bo_va->base.vm_status);
@@ -2693,7 +2705,7 @@ void amdgpu_vm_bo_invalidate(struct amdgpu_device *adev,
 	if (bo->parent && bo->parent->shadow == bo)
 		bo = bo->parent;
 
-	list_for_each_entry(bo_base, &bo->va, bo_list) {
+	for (bo_base = bo->vm_bo; bo_base; bo_base = bo_base->next) {
 		struct amdgpu_vm *vm = bo_base->vm;
 
 		if (evicted && bo->tbo.resv == vm->root.base.bo->tbo.resv) {
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
index a869ec8..ff711a4 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
@@ -132,7 +132,7 @@ struct amdgpu_vm_bo_base {
 	struct amdgpu_bo		*bo;
 
 	/* protected by bo being reserved */
-	struct list_head		bo_list;
+	struct amdgpu_vm_bo_base	*next;
 
 	/* protected by spinlock */
 	struct list_head		vm_status;
-- 
2.7.4

