From f8525598b2b0c327686910133fcc7c3df5e4c154 Mon Sep 17 00:00:00 2001
From: Harish Kasiviswanathan <Harish.Kasiviswanathan@amd.com>
Date: Mon, 9 Apr 2018 16:03:21 -0400
Subject: [PATCH 4255/5725] drm/amdkfd: CMA: Store mem_type in KFD BO

It is needed for supporting CMA when the BOs belong to different
devices.

Change-Id: I9acc5595e574141d8955e36ff0a98e5bac9b6fc1
Signed-off-by: Harish Kasiviswanathan <Harish.Kasiviswanathan@amd.com>
---
 drivers/gpu/drm/amd/amdkfd/kfd_chardev.c |  7 ++++++-
 drivers/gpu/drm/amd/amdkfd/kfd_ipc.c     |  2 +-
 drivers/gpu/drm/amd/amdkfd/kfd_priv.h    |  2 ++
 drivers/gpu/drm/amd/amdkfd/kfd_process.c | 10 +++++++++-
 4 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
index a216225..0972243 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
@@ -1246,6 +1246,7 @@ static int kfd_ioctl_alloc_memory_of_gpu(struct file *filep,
 	uint32_t flags = args->flags;
 	struct vm_area_struct *vma;
 	uint64_t cpuva = 0;
+	unsigned int mem_type = 0;
 
 	if (args->size == 0)
 		return -EINVAL;
@@ -1305,8 +1306,12 @@ static int kfd_ioctl_alloc_memory_of_gpu(struct file *filep,
 	if (err)
 		goto err_unlock;
 
+	mem_type = flags & (KFD_IOC_ALLOC_MEM_FLAGS_VRAM |
+			    KFD_IOC_ALLOC_MEM_FLAGS_GTT |
+			    KFD_IOC_ALLOC_MEM_FLAGS_USERPTR |
+			    KFD_IOC_ALLOC_MEM_FLAGS_DOORBELL);
 	idr_handle = kfd_process_device_create_obj_handle(pdd, mem,
-			args->va_addr, args->size, cpuva, NULL);
+			args->va_addr, args->size, cpuva, mem_type, NULL);
 	if (idr_handle < 0) {
 		err = -EFAULT;
 		goto err_free;
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_ipc.c b/drivers/gpu/drm/amd/amdkfd/kfd_ipc.c
index 845dbf7..a53d954 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_ipc.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_ipc.c
@@ -140,7 +140,7 @@ static int kfd_import_dmabuf_create_kfd_bo(struct kfd_dev *dev,
 		goto err_unlock;
 
 	idr_handle = kfd_process_device_create_obj_handle(pdd, mem,
-							  va_addr, size, 0,
+							  va_addr, size, 0, 0,
 							  ipc_obj);
 	if (idr_handle < 0) {
 		r = -EFAULT;
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_priv.h b/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
index cbb65b0..3f77bab 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_priv.h
@@ -303,6 +303,7 @@ struct kfd_bo {
 	struct kfd_ipc_obj *kfd_ipc_obj;
 	/* page-aligned VA address */
 	uint64_t cpuva;
+	unsigned int mem_type;
 };
 
 struct cma_system_bo {
@@ -819,6 +820,7 @@ int kfd_reserved_mem_mmap(struct kfd_process *process,
 int kfd_process_device_create_obj_handle(struct kfd_process_device *pdd,
 					void *mem, uint64_t start,
 					uint64_t length, uint64_t cpuva,
+					unsigned int mem_type,
 					struct kfd_ipc_obj *ipc_obj);
 void *kfd_process_device_translate_handle(struct kfd_process_device *p,
 					int handle);
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_process.c b/drivers/gpu/drm/amd/amdkfd/kfd_process.c
index ef71670..3650183 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_process.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_process.c
@@ -118,6 +118,7 @@ static int kfd_process_alloc_gpuvm(struct kfd_process_device *pdd,
 	struct kgd_mem *mem = NULL;
 	int handle;
 	int err;
+	unsigned int mem_type;
 
 	err = kdev->kfd2kgd->alloc_memory_of_gpu(kdev->kgd, gpu_va, size,
 						 pdd->vm, NULL, &mem, NULL,
@@ -135,13 +136,18 @@ static int kfd_process_alloc_gpuvm(struct kfd_process_device *pdd,
 		goto sync_memory_failed;
 	}
 
+	mem_type = flags & (KFD_IOC_ALLOC_MEM_FLAGS_VRAM |
+			    KFD_IOC_ALLOC_MEM_FLAGS_GTT |
+			    KFD_IOC_ALLOC_MEM_FLAGS_USERPTR |
+			    KFD_IOC_ALLOC_MEM_FLAGS_DOORBELL);
+
 	/* Create an obj handle so kfd_process_device_remove_obj_handle
 	 * will take care of the bo removal when the process finishes.
 	 * We do not need to take p->mutex, because the process is just
 	 * created and the ioctls have not had the chance to run.
 	 */
 	handle = kfd_process_device_create_obj_handle(
-			pdd, mem, gpu_va, size, 0, NULL);
+			pdd, mem, gpu_va, size, 0, mem_type, NULL);
 
 	if (handle < 0) {
 		err = handle;
@@ -808,6 +814,7 @@ bool kfd_has_process_device_data(struct kfd_process *p)
 int kfd_process_device_create_obj_handle(struct kfd_process_device *pdd,
 					void *mem, uint64_t start,
 					uint64_t length, uint64_t cpuva,
+					unsigned int mem_type,
 					struct kfd_ipc_obj *ipc_obj)
 {
 	int handle;
@@ -829,6 +836,7 @@ int kfd_process_device_create_obj_handle(struct kfd_process_device *pdd,
 	buf_obj->dev = pdd->dev;
 	buf_obj->kfd_ipc_obj = ipc_obj;
 	buf_obj->cpuva = cpuva;
+	buf_obj->mem_type = mem_type;
 
 	INIT_LIST_HEAD(&buf_obj->cb_data_head);
 
-- 
2.7.4

