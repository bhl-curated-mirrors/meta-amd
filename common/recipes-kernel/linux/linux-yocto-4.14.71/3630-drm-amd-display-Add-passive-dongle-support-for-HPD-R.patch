From df731cf1a1a240a5ab3c44d0ea53112c8eff9e70 Mon Sep 17 00:00:00 2001
From: John Barberiz <jbarberi@amd.com>
Date: Fri, 9 Feb 2018 17:48:18 -0500
Subject: [PATCH 3630/4131] drm/amd/display: Add passive dongle support for HPD
 Rearch

Add HPD delay timer support to
1. Single/dual link DVI.
2. DP to HDMI passive dongle
3. DP to DVI passive dongle.

Change-Id: I07abda93e8a8fb98da82a7701f59387f22392a8e
Signed-off-by: John Barberiz <jbarberi@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h  |  4 +-
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_color.c    | 92 +++++++++++++++++-----
 drivers/gpu/drm/amd/display/dc/core/dc_link.c      |  7 +-
 drivers/gpu/drm/amd/display/dc/dc_link.h           |  2 +-
 4 files changed, 80 insertions(+), 25 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
index 5b5fa80..b4c48c5 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
@@ -269,7 +269,9 @@ void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc);
 #define amdgpu_dm_crtc_handle_crc_irq(x)
 #endif
 
-#define MAX_COLOR_LUT_ENTRIES 256
+#define MAX_COLOR_LUT_ENTRIES 4096
+/* Legacy gamm LUT users such as X doesn't like large LUT sizes */
+#define MAX_COLOR_LEGACY_LUT_ENTRIES 256
 
 void amdgpu_dm_init_color_mod(void);
 int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index eeaf392..e845c51 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -27,26 +27,40 @@
 #include "amdgpu_dm.h"
 #include "modules/color/color_gamma.h"
 
+#define MAX_DRM_LUT_VALUE 0xFFFF
+
+/*
+ * Initialize the color module.
+ *
+ * We're not using the full color module, only certain components.
+ * Only call setup functions for components that we need.
+ */
+void amdgpu_dm_init_color_mod(void)
+{
+	setup_x_points_distribution();
+}
+
+
 /*
  * Return true if the given lut is a linear mapping of values, i.e. it acts
  * like a bypass LUT.
  *
  * It is considered linear if the lut represents:
- * f(a) = (0xFF00/MAX_LUT_ENTRIES-1)a; for integer a in [0, MAX_LUT_ENTRIES)
+ * f(a) = (0xFF00/MAX_COLOR_LUT_ENTRIES-1)a; for integer a in
+ *                                           [0, MAX_COLOR_LUT_ENTRIES)
  */
-static bool __is_lut_linear(struct drm_color_lut *lut)
+static bool __is_lut_linear(struct drm_color_lut *lut, uint32_t size)
 {
 	int i;
-	uint32_t max_os = 0xFF00;
 	uint32_t expected;
 	int delta;
 
-	for (i = 0; i < MAX_COLOR_LUT_ENTRIES; i++) {
+	for (i = 0; i < size; i++) {
 		/* All color values should equal */
 		if ((lut[i].red != lut[i].green) || (lut[i].green != lut[i].blue))
 			return false;
 
-		expected = i * max_os / (MAX_COLOR_LUT_ENTRIES-1);
+		expected = i * MAX_DRM_LUT_VALUE / (size-1);
 
 		/* Allow a +/-1 error. */
 		delta = lut[i].red - expected;
@@ -57,6 +71,42 @@ static bool __is_lut_linear(struct drm_color_lut *lut)
 }
 
 /**
+ * Convert the drm_color_lut to dc_gamma. The conversion depends on the size
+ * of the lut - whether or not it's legacy.
+ */
+static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
+				  struct dc_gamma *gamma,
+				  bool is_legacy)
+{
+	uint32_t r, g, b;
+	int i;
+
+	if (is_legacy) {
+		for (i = 0; i < MAX_COLOR_LEGACY_LUT_ENTRIES; i++) {
+			r = drm_color_lut_extract(lut[i].red, 16);
+			g = drm_color_lut_extract(lut[i].green, 16);
+			b = drm_color_lut_extract(lut[i].blue, 16);
+
+			gamma->entries.red[i] = dal_fixed31_32_from_int(r);
+			gamma->entries.green[i] = dal_fixed31_32_from_int(g);
+			gamma->entries.blue[i] = dal_fixed31_32_from_int(b);
+		}
+		return;
+	}
+
+	/* else */
+	for (i = 0; i < MAX_COLOR_LUT_ENTRIES; i++) {
+		r = drm_color_lut_extract(lut[i].red, 16);
+		g = drm_color_lut_extract(lut[i].green, 16);
+		b = drm_color_lut_extract(lut[i].blue, 16);
+
+		gamma->entries.red[i] = dal_fixed31_32_from_fraction(r, MAX_DRM_LUT_VALUE);
+		gamma->entries.green[i] = dal_fixed31_32_from_fraction(g, MAX_DRM_LUT_VALUE);
+		gamma->entries.blue[i] = dal_fixed31_32_from_fraction(b, MAX_DRM_LUT_VALUE);
+	}
+}
+
+/**
  * amdgpu_dm_set_regamma_lut: Set regamma lut for the given CRTC.
  * @crtc: amdgpu_dm crtc state
  *
@@ -72,11 +122,10 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	struct drm_property_blob *blob = crtc->base.gamma_lut;
 	struct dc_stream_state *stream = crtc->stream;
 	struct drm_color_lut *lut;
+	uint32_t lut_size;
 	struct dc_gamma *gamma;
 	enum dc_transfer_func_type old_type = stream->out_transfer_func->type;
 
-	uint32_t r, g, b;
-	int i;
 	bool ret;
 
 	if (!blob) {
@@ -87,8 +136,9 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	}
 
 	lut = (struct drm_color_lut *)blob->data;
+	lut_size = blob->length / sizeof(struct drm_color_lut);
 
-	if (__is_lut_linear(lut)) {
+	if (__is_lut_linear(lut, lut_size)) {
 		/* Set to bypass if lut is set to linear */
 		stream->out_transfer_func->type = TF_TYPE_BYPASS;
 		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
@@ -99,20 +149,20 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	if (!gamma)
 		return -ENOMEM;
 
-	gamma->num_entries = MAX_LUT_ENTRIES;
-	gamma->type = GAMMA_RGB_256;
-
-	/* Truncate, and store in dc_gamma for output tf calculation */
-	for (i = 0; i < gamma->num_entries; i++) {
-		r = drm_color_lut_extract(lut[i].red, 16);
-		g = drm_color_lut_extract(lut[i].green, 16);
-		b = drm_color_lut_extract(lut[i].blue, 16);
-
-		gamma->entries.red[i] = dal_fixed31_32_from_int(r);
-		gamma->entries.green[i] = dal_fixed31_32_from_int(g);
-		gamma->entries.blue[i] = dal_fixed31_32_from_int(b);
+	gamma->num_entries = lut_size;
+	if (gamma->num_entries == MAX_COLOR_LEGACY_LUT_ENTRIES)
+		gamma->type = GAMMA_RGB_256;
+	else if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
+		gamma->type = GAMMA_CS_TFM_1D;
+	else {
+		/* Invalid lut size */
+		dc_gamma_release(&gamma);
+		return -EINVAL;
 	}
 
+	/* Convert drm_lut into dc_gamma */
+	__drm_lut_to_dc_gamma(lut, gamma, gamma->type == GAMMA_RGB_256);
+
 	/* Call color module to translate into something DC understands. Namely
 	 * a transfer function.
 	 */
@@ -199,7 +249,7 @@ int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
 	}
 
 	lut = (struct drm_color_lut *)blob->data;
-	if (__is_lut_linear(lut)) {
+	if (__is_lut_linear(lut, MAX_COLOR_LUT_ENTRIES)) {
 		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
 		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
 		return 0;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link.c b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
index f40c9c7..556b155 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -2358,11 +2358,14 @@ void core_link_set_avmute(struct pipe_ctx *pipe_ctx, bool enable)
 	core_dc->hwss.set_avmute(pipe_ctx, enable);
 }
 
-void dc_link_disable_hpd_filter(struct dc_link *link)
+void dc_link_enable_hpd_filter(struct dc_link *link, bool enable)
 {
 	struct gpio *hpd;
 
-	if (!link->is_hpd_filter_disabled) {
+	if (enable) {
+		link->is_hpd_filter_disabled = false;
+		program_hpd_filter(link);
+	} else {
 		link->is_hpd_filter_disabled = true;
 		/* Obtain HPD handle */
 		hpd = get_hpd_gpio(link->ctx->dc_bios, link->link_id, link->ctx->gpio_service);
diff --git a/drivers/gpu/drm/amd/display/dc/dc_link.h b/drivers/gpu/drm/amd/display/dc/dc_link.h
index ac0f617..fb4d9ea 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_link.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_link.h
@@ -197,7 +197,7 @@ bool dc_link_dp_set_test_pattern(
 	const unsigned char *p_custom_pattern,
 	unsigned int cust_pattern_size);
 
-void dc_link_disable_hpd_filter(struct dc_link *link);
+void dc_link_enable_hpd_filter(struct dc_link *link, bool enable);
 
 /*
  * DPCD access interfaces
-- 
2.7.4

