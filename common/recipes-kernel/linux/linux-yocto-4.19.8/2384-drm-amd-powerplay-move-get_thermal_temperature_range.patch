From 99da7bc520767fc1df8cce1d9e8b259745da7669 Mon Sep 17 00:00:00 2001
From: Hawking Zhang <Hawking.Zhang@amd.com>
Date: Mon, 10 Jun 2019 21:39:29 +0800
Subject: [PATCH 2384/2940] drm/amd/powerplay: move
 get_thermal_temperature_range to ppt funcs

The thermal policy could be ASIC specific ones and depends on structures
in pptable. As a result, get_thermal_temperature_range should be implemented
as ppt funcs instead of smu funcs

Signed-off-by: Hawking Zhang <Hawking.Zhang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../gpu/drm/amd/powerplay/inc/amdgpu_smu.h    | 14 +++
 drivers/gpu/drm/amd/powerplay/smu_v11_0.c     | 90 +++----------------
 drivers/gpu/drm/amd/powerplay/vega20_ppt.c    | 47 +++++++++-
 3 files changed, 70 insertions(+), 81 deletions(-)

diff --git a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
index 0fd3d89386be..f89971992e6f 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
@@ -26,6 +26,10 @@
 #include "kgd_pp_interface.h"
 #include "dm_pp_interface.h"
 
+#define SMU_THERMAL_MINIMUM_ALERT_TEMP		0
+#define SMU_THERMAL_MAXIMUM_ALERT_TEMP		255
+#define SMU_TEMPERATURE_UNITS_PER_CENTIGRADES	1000
+
 struct smu_hw_power_state {
 	unsigned int magic;
 };
@@ -106,6 +110,13 @@ struct smu_state_software_algorithm_block {
 struct smu_temperature_range {
 	int min;
 	int max;
+	int edge_emergency_max;
+	int hotspot_min;
+	int hotspot_crit_max;
+	int hotspot_emergency_max;
+	int mem_min;
+	int mem_crit_max;
+	int mem_emergency_max;
 };
 
 struct smu_state_validation_block {
@@ -597,6 +608,7 @@ struct pptable_funcs {
 	int (*get_current_clk_freq_by_table)(struct smu_context *smu,
 					     enum smu_clk_type clk_type,
 					     uint32_t *value);
+	int (*get_thermal_temperature_range)(struct smu_context *smu, struct smu_temperature_range *range);
 };
 
 struct smu_funcs
@@ -881,6 +893,8 @@ struct smu_funcs
 	((smu)->ppt_funcs->set_watermarks_table ? (smu)->ppt_funcs->set_watermarks_table((smu), (tab), (clock_ranges)) : 0)
 #define smu_get_current_clk_freq_by_table(smu, clk_type, value) \
 	((smu)->ppt_funcs->get_current_clk_freq_by_table ? (smu)->ppt_funcs->get_current_clk_freq_by_table((smu), (clk_type), (value)) : 0)
+#define smu_get_thermal_temperature_range(smu, range) \
+	((smu)->ppt_funcs->get_thermal_temperature_range? (smu)->ppt_funcs->get_thermal_temperature_range((smu), (range)) : 0)
 
 extern int smu_get_atom_data_table(struct smu_context *smu, uint32_t table,
 				   uint16_t *size, uint8_t *frev, uint8_t *crev,
diff --git a/drivers/gpu/drm/amd/powerplay/smu_v11_0.c b/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
index 175463d9aa2d..c6dc2a6d8093 100644
--- a/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
+++ b/drivers/gpu/drm/amd/powerplay/smu_v11_0.c
@@ -31,7 +31,6 @@
 #include "atom.h"
 #include "vega20_ppt.h"
 #include "navi10_ppt.h"
-#include "pp_thermal.h"
 
 #include "asic_reg/thm/thm_11_0_2_offset.h"
 #include "asic_reg/thm/thm_11_0_2_sh_mask.h"
@@ -44,10 +43,6 @@
 MODULE_FIRMWARE("amdgpu/vega20_smc.bin");
 MODULE_FIRMWARE("amdgpu/navi10_smc.bin");
 
-#define SMU11_THERMAL_MINIMUM_ALERT_TEMP      0
-#define SMU11_THERMAL_MAXIMUM_ALERT_TEMP      255
-
-#define SMU11_TEMPERATURE_UNITS_PER_CENTIGRADES 1000
 #define SMU11_VOLTAGE_SCALE 4
 
 static int smu_v11_0_send_msg_without_waiting(struct smu_context *smu,
@@ -1112,38 +1107,19 @@ static int smu_v11_0_get_current_clk_freq(struct smu_context *smu,
 	return ret;
 }
 
-static int smu_v11_0_get_thermal_range(struct smu_context *smu,
-				struct PP_TemperatureRange *range)
-{
-	PPTable_t *pptable = smu->smu_table.driver_pptable;
-	memcpy(range, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange));
-
-	range->max = pptable->TedgeLimit *
-		PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-	range->edge_emergency_max = (pptable->TedgeLimit + CTF_OFFSET_EDGE) *
-		PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-	range->hotspot_crit_max = pptable->ThotspotLimit *
-		PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-	range->hotspot_emergency_max = (pptable->ThotspotLimit + CTF_OFFSET_HOTSPOT) *
-		PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-	range->mem_crit_max = pptable->ThbmLimit *
-		PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-	range->mem_emergency_max = (pptable->ThbmLimit + CTF_OFFSET_HBM)*
-		PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-
-	return 0;
-}
-
 static int smu_v11_0_set_thermal_range(struct smu_context *smu,
-			struct PP_TemperatureRange *range)
+				       struct smu_temperature_range *range)
 {
 	struct amdgpu_device *adev = smu->adev;
-	int low = SMU11_THERMAL_MINIMUM_ALERT_TEMP *
-		PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-	int high = SMU11_THERMAL_MAXIMUM_ALERT_TEMP *
-		PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
+	int low = SMU_THERMAL_MINIMUM_ALERT_TEMP *
+		SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
+	int high = SMU_THERMAL_MAXIMUM_ALERT_TEMP *
+		SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
 	uint32_t val;
 
+	if (!range)
+		return -EINVAL;
+
 	if (low < range->min)
 		low = range->min;
 	if (high > range->max)
@@ -1155,8 +1131,8 @@ static int smu_v11_0_set_thermal_range(struct smu_context *smu,
 	val = RREG32_SOC15(THM, 0, mmTHM_THERMAL_INT_CTRL);
 	val = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, MAX_IH_CREDIT, 5);
 	val = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_IH_HW_ENA, 1);
-	val = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, DIG_THERM_INTH, (high / PP_TEMPERATURE_UNITS_PER_CENTIGRADES));
-	val = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, DIG_THERM_INTL, (low / PP_TEMPERATURE_UNITS_PER_CENTIGRADES));
+	val = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, DIG_THERM_INTH, (high / SMU_TEMPERATURE_UNITS_PER_CENTIGRADES));
+	val = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, DIG_THERM_INTL, (low / SMU_TEMPERATURE_UNITS_PER_CENTIGRADES));
 	val = val & (~THM_THERMAL_INT_CTRL__THERM_TRIGGER_MASK_MASK);
 
 	WREG32_SOC15(THM, 0, mmTHM_THERMAL_INT_CTRL, val);
@@ -1181,7 +1157,7 @@ static int smu_v11_0_enable_thermal_alert(struct smu_context *smu)
 static int smu_v11_0_start_thermal_control(struct smu_context *smu)
 {
 	int ret = 0;
-	struct PP_TemperatureRange range = {
+	struct smu_temperature_range range = {
 		TEMP_RANGE_MIN,
 		TEMP_RANGE_MAX,
 		TEMP_RANGE_MAX,
@@ -1195,7 +1171,7 @@ static int smu_v11_0_start_thermal_control(struct smu_context *smu)
 
 	if (!smu->pm_enabled)
 		return ret;
-	smu_v11_0_get_thermal_range(smu, &range);
+	ret = smu_get_thermal_temperature_range(smu, &range);
 
 	if (smu->smu_table.thermal_controller_type) {
 		ret = smu_v11_0_set_thermal_range(smu, &range);
@@ -1223,48 +1199,6 @@ static int smu_v11_0_start_thermal_control(struct smu_context *smu)
 	return ret;
 }
 
-static int smu_v11_0_thermal_get_temperature(struct smu_context *smu,
-					     enum amd_pp_sensors sensor,
-					     uint32_t *value)
-{
-	struct amdgpu_device *adev = smu->adev;
-	SmuMetrics_t metrics;
-	uint32_t temp = 0;
-	int ret = 0;
-
-	if (!value)
-		return -EINVAL;
-
-	ret = smu_v11_0_get_metrics_table(smu, &metrics);
-	if (ret)
-		return ret;
-
-	switch (sensor) {
-	case AMDGPU_PP_SENSOR_HOTSPOT_TEMP:
-		temp = RREG32_SOC15(THM, 0, mmCG_MULT_THERMAL_STATUS);
-		temp = (temp & CG_MULT_THERMAL_STATUS__CTF_TEMP_MASK) >>
-				CG_MULT_THERMAL_STATUS__CTF_TEMP__SHIFT;
-
-		temp = temp & 0x1ff;
-		temp *= SMU11_TEMPERATURE_UNITS_PER_CENTIGRADES;
-
-		*value = temp;
-		break;
-	case AMDGPU_PP_SENSOR_EDGE_TEMP:
-		*value = metrics.TemperatureEdge *
-			PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-		break;
-	case AMDGPU_PP_SENSOR_MEM_TEMP:
-		*value = metrics.TemperatureHBM *
-			PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
-		break;
-	default:
-		pr_err("Invalid sensor for retrieving temp\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
 static uint16_t convert_to_vddc(uint8_t vid)
 {
 	return (uint16_t) ((6200 - (vid * 25)) / SMU11_VOLTAGE_SCALE);
diff --git a/drivers/gpu/drm/amd/powerplay/vega20_ppt.c b/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
index 625718cc8b63..1d91739d18e0 100644
--- a/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
@@ -36,10 +36,16 @@
 #include "vega20_pptable.h"
 #include "vega20_ppsmc.h"
 #include "nbio/nbio_7_4_sh_mask.h"
+#include "asic_reg/thm/thm_11_0_2_offset.h"
+#include "asic_reg/thm/thm_11_0_2_sh_mask.h"
 
 #define smnPCIE_LC_SPEED_CNTL			0x11140290
 #define smnPCIE_LC_LINK_WIDTH_CNTL		0x11140288
 
+#define CTF_OFFSET_EDGE			5
+#define CTF_OFFSET_HOTSPOT		5
+#define CTF_OFFSET_HBM			5
+
 #define MSG_MAP(msg) \
 	[SMU_MSG_##msg] = PPSMC_MSG_##msg
 
@@ -3023,17 +3029,17 @@ static int vega20_thermal_get_temperature(struct smu_context *smu,
 				CG_MULT_THERMAL_STATUS__CTF_TEMP__SHIFT;
 
 		temp = temp & 0x1ff;
-		temp *= SMU11_TEMPERATURE_UNITS_PER_CENTIGRADES;
+		temp *= SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
 
 		*value = temp;
 		break;
 	case AMDGPU_PP_SENSOR_EDGE_TEMP:
 		*value = metrics.TemperatureEdge *
-			PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
+			SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
 		break;
 	case AMDGPU_PP_SENSOR_MEM_TEMP:
 		*value = metrics.TemperatureHBM *
-			PP_TEMPERATURE_UNITS_PER_CENTIGRADES;
+			SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
 		break;
 	default:
 		pr_err("Invalid sensor for retrieving temp\n");
@@ -3139,6 +3145,40 @@ static int vega20_set_watermarks_table(struct smu_context *smu,
 	return 0;
 }
 
+static const struct smu_temperature_range vega20_thermal_policy[] =
+{
+	{-273150,  99000, 99000, -273150, 99000, 99000, -273150, 99000, 99000},
+	{ 120000, 120000, 120000, 120000, 120000, 120000, 120000, 120000, 120000},
+};
+
+static int vega20_get_thermal_temperature_range(struct smu_context *smu,
+						struct smu_temperature_range*range)
+{
+
+	PPTable_t *pptable = smu->smu_table.driver_pptable;
+
+	if (!range)
+		return -EINVAL;
+
+	memcpy(range, &vega20_thermal_policy[0], sizeof(struct smu_temperature_range));
+
+	range->max = pptable->TedgeLimit *
+		SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
+	range->edge_emergency_max = (pptable->TedgeLimit + CTF_OFFSET_EDGE) *
+		SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
+	range->hotspot_crit_max = pptable->ThotspotLimit *
+		SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
+	range->hotspot_emergency_max = (pptable->ThotspotLimit + CTF_OFFSET_HOTSPOT) *
+		SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
+	range->mem_crit_max = pptable->ThbmLimit *
+		SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
+	range->mem_emergency_max = (pptable->ThbmLimit + CTF_OFFSET_HBM)*
+		SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;
+
+
+	return 0;
+}
+
 static const struct pptable_funcs vega20_ppt_funcs = {
 	.tables_init = vega20_tables_init,
 	.alloc_dpm_context = vega20_allocate_dpm_context,
@@ -3183,6 +3223,7 @@ static const struct pptable_funcs vega20_ppt_funcs = {
 	.set_thermal_fan_table = vega20_set_thermal_fan_table,
 	.get_fan_speed_percent = vega20_get_fan_speed_percent,
 	.set_watermarks_table = vega20_set_watermarks_table,
+	.get_thermal_temperature_range = vega20_get_thermal_temperature_range
 };
 
 void vega20_set_ppt_funcs(struct smu_context *smu)
-- 
2.17.1

