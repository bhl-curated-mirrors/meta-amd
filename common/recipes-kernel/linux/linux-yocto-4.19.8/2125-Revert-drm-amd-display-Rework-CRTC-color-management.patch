From b142b07f8faa7c761ac9b2b956ec50aae6bbb694 Mon Sep 17 00:00:00 2001
From: Chaudhary Amit Kumar <Chaudharyamit.Kumar@amd.com>
Date: Thu, 27 Jun 2019 15:53:04 +0530
Subject: [PATCH 2125/2940] Revert "drm/amd/display: Rework CRTC color
 management"

This reverts commit ec4f8502602b4fe52d06e796552d125604270346.
---
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c |  18 +-
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h |  10 +-
 .../amd/display/amdgpu_dm/amdgpu_dm_color.c   | 473 ++++++------------
 3 files changed, 157 insertions(+), 344 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 7203ac71c582..e9a2186c9545 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -2943,7 +2943,6 @@ static int fill_dc_plane_attributes(struct amdgpu_device *adev,
                                     struct drm_plane_state *plane_state,
                                     struct drm_crtc_state *crtc_state)
 {
-	struct dm_crtc_state *dm_crtc_state = to_dm_crtc_state(crtc_state);
 	const struct amdgpu_framebuffer *amdgpu_fb =
 		to_amdgpu_framebuffer(plane_state->fb);
         struct dc_scaling_info scaling_info;
@@ -2988,11 +2987,13 @@ static int fill_dc_plane_attributes(struct amdgpu_device *adev,
 	 * Always set input transfer function, since plane state is refreshed
 	 * every time.
 	 */
+	ret = amdgpu_dm_set_degamma_lut(crtc_state, dc_plane_state);
+	if (ret) {
+		dc_transfer_func_release(dc_plane_state->in_transfer_func);
+		dc_plane_state->in_transfer_func = NULL;
+	}
 
-	ret = amdgpu_dm_update_plane_color_mgmt(dm_crtc_state, dc_plane_state);
-	if (ret)
-		return ret;
-	return 0;
+	return ret;
 }
 
 static void update_stream_scaling_settings(const struct drm_display_mode *mode,
@@ -3565,8 +3566,6 @@ dm_crtc_duplicate_state(struct drm_crtc *crtc)
         state->vrr_supported = cur->vrr_supported;
         state->freesync_config = cur->freesync_config;
 	state->crc_enabled = cur->crc_enabled;
-	state->cm_has_degamma = cur->cm_has_degamma;
-	state->cm_is_degamma_srgb = cur->cm_is_degamma_srgb;
 
 	/* TODO Duplicate dc_stream after objects are stream object is flattened */
 
@@ -6433,9 +6432,10 @@ static int dm_update_crtc_state(struct amdgpu_display_manager *dm,
          */
         if (dm_new_crtc_state->base.color_mgmt_changed ||
             drm_atomic_crtc_needs_modeset(new_crtc_state)) {
-		ret = amdgpu_dm_update_crtc_color_mgmt(dm_new_crtc_state);
+                ret = amdgpu_dm_set_regamma_lut(dm_new_crtc_state);
                 if (ret)
                         goto fail;
+                amdgpu_dm_set_ctm(dm_new_crtc_state);
 	}
         /* Update Freesync settings. */
         get_freesync_config_for_crtc(dm_new_crtc_state,
@@ -6738,8 +6738,6 @@ dm_determine_update_type_for_commit(struct amdgpu_display_manager *dm,
 						new_dm_plane_state->dc_state->in_transfer_func;
 				stream_update.gamut_remap =
 						&new_dm_crtc_state->stream->gamut_remap_matrix;
-				stream_update.output_csc_transform =
-						&new_dm_crtc_state->stream->csc_color_matrix;
 				stream_update.out_transfer_func =
 						new_dm_crtc_state->stream->out_transfer_func;
 			}
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
index 208198d2b482..715a2d66a0a7 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
@@ -268,9 +268,6 @@ struct dm_crtc_state {
 	struct drm_crtc_state base;
 	struct dc_stream_state *stream;
 
-	bool cm_has_degamma;
-	bool cm_is_degamma_srgb;
-
 	int active_planes;
 	bool interrupts_enabled;
 
@@ -362,9 +359,10 @@ void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc);
 #define MAX_COLOR_LEGACY_LUT_ENTRIES 256
 
 void amdgpu_dm_init_color_mod(void);
-int amdgpu_dm_update_crtc_color_mgmt(struct dm_crtc_state *crtc);
-int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
-                                      struct dc_plane_state *dc_plane_state);
+int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
+			      struct dc_plane_state *dc_plane_state);
+void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc);
+int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc);
 
 extern const struct drm_encoder_helper_funcs amdgpu_dm_encoder_helper_funcs;
 
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index b1bd10a41609..7258c992a2bf 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -27,47 +27,6 @@
 #include "amdgpu_dm.h"
 #include "dc.h"
 #include "modules/color/color_gamma.h"
-#include "basics/conversion.h"
-
-/*
- * The DC interface to HW gives us the following color management blocks
- * per pipe (surface):
- *
- * - Input gamma LUT (de-normalized)
- * - Input CSC (normalized)
- * - Surface degamma LUT (normalized)
- * - Surface CSC (normalized)
- * - Surface regamma LUT (normalized)
- * - Output CSC (normalized)
- *
- * But these aren't a direct mapping to DRM color properties. The current DRM
- * interface exposes CRTC degamma, CRTC CTM and CRTC regamma while our hardware
- * is essentially giving:
- *
- * Plane CTM -> Plane degamma -> Plane CTM -> Plane regamma -> Plane CTM
- *
- * The input gamma LUT block isn't really applicable here since it operates
- * on the actual input data itself rather than the HW fp representation. The
- * input and output CSC blocks are technically available to use as part of
- * the DC interface but are typically used internally by DC for conversions
- * between color spaces. These could be blended together with user
- * adjustments in the future but for now these should remain untouched.
- *
- * The pipe blending also happens after these blocks so we don't actually
- * support any CRTC props with correct blending with multiple planes - but we
- * can still support CRTC color management properties in DM in most single
- * plane cases correctly with clever management of the DC interface in DM.
- *
- * As per DRM documentation, blocks should be in hardware bypass when their
- * respective property is set to NULL. A linear DGM/RGM LUT should also
- * considered as putting the respective block into bypass mode.
- *
- * This means that the following
- * configuration is assumed to be the default:
- *
- * Plane DGM Bypass -> Plane CTM Bypass -> Plane RGM Bypass -> ...
- * CRTC DGM Bypass -> CRTC CTM Bypass -> CRTC RGM Bypass
- */
 
 #define MAX_DRM_LUT_VALUE 0xFFFF
 
@@ -82,13 +41,6 @@ void amdgpu_dm_init_color_mod(void)
 	setup_x_points_distribution();
 }
 
-/* Extracts the DRM lut and lut size from a blob. */
-static const struct drm_color_lut *
-__extract_blob_lut(const struct drm_property_blob *blob, uint32_t *size)
-{
-	*size = blob ? drm_color_lut_size(blob) : 0;
-	return blob ? (struct drm_color_lut *)blob->data : NULL;
-}
 
 /*
  * Return true if the given lut is a linear mapping of values, i.e. it acts
@@ -98,7 +50,7 @@ __extract_blob_lut(const struct drm_property_blob *blob, uint32_t *size)
  * f(a) = (0xFF00/MAX_COLOR_LUT_ENTRIES-1)a; for integer a in
  *                                           [0, MAX_COLOR_LUT_ENTRIES)
  */
-static bool __is_lut_linear(const struct drm_color_lut *lut, uint32_t size)
+static bool __is_lut_linear(struct drm_color_lut *lut, uint32_t size)
 {
 	int i;
 	uint32_t expected;
@@ -123,8 +75,9 @@ static bool __is_lut_linear(const struct drm_color_lut *lut, uint32_t size)
  * Convert the drm_color_lut to dc_gamma. The conversion depends on the size
  * of the lut - whether or not it's legacy.
  */
-static void __drm_lut_to_dc_gamma(const struct drm_color_lut *lut,
-				  struct dc_gamma *gamma, bool is_legacy)
+static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
+				  struct dc_gamma *gamma,
+				  bool is_legacy)
 {
 	uint32_t r, g, b;
 	int i;
@@ -154,16 +107,103 @@ static void __drm_lut_to_dc_gamma(const struct drm_color_lut *lut,
 	}
 }
 
-/*
- * Converts a DRM CTM to a DC CSC float matrix.
- * The matrix needs to be a 3x4 (12 entry) matrix.
+/**
+ * amdgpu_dm_set_regamma_lut: Set regamma lut for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's output transfer function (OTF) in
+ * preparation for hardware commit. If no lut is specified by user, we default
+ * to SRGB.
+ *
+ * RETURNS:
+ * 0 on success, -ENOMEM if memory cannot be allocated to calculate the OTF.
  */
-static void __drm_ctm_to_dc_matrix(const struct drm_color_ctm *ctm,
-				   struct fixed31_32 *matrix)
+int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 {
+	struct drm_property_blob *blob = crtc->base.gamma_lut;
+	struct dc_stream_state *stream = crtc->stream;
+	struct amdgpu_device *adev = (struct amdgpu_device *)
+		crtc->base.state->dev->dev_private;
+	struct drm_color_lut *lut;
+	uint32_t lut_size;
+	struct dc_gamma *gamma = NULL;
+	enum dc_transfer_func_type old_type = stream->out_transfer_func->type;
+
+	bool ret;
+
+	if (!blob && adev->asic_type <= CHIP_RAVEN) {
+		/* By default, use the SRGB predefined curve.*/
+		stream->out_transfer_func->type = TF_TYPE_PREDEFINED;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+		return 0;
+	}
+
+	if (blob) {
+		lut = (struct drm_color_lut *)blob->data;
+		lut_size = blob->length / sizeof(struct drm_color_lut);
+
+		gamma = dc_create_gamma();
+		if (!gamma)
+			return -ENOMEM;
+
+		gamma->num_entries = lut_size;
+		if (gamma->num_entries == MAX_COLOR_LEGACY_LUT_ENTRIES)
+			gamma->type = GAMMA_RGB_256;
+		else if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
+			gamma->type = GAMMA_CS_TFM_1D;
+		else {
+			/* Invalid lut size */
+			dc_gamma_release(&gamma);
+			return -EINVAL;
+		}
+
+		/* Convert drm_lut into dc_gamma */
+		__drm_lut_to_dc_gamma(lut, gamma, gamma->type == GAMMA_RGB_256);
+	}
+
+	/* predefined gamma ROM only exist for RAVEN and pre-RAVEN ASIC,
+	 * set canRomBeUsed accordingly
+	 */
+	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
+			gamma, true, adev->asic_type <= CHIP_RAVEN, NULL);
+
+	if (gamma)
+		dc_gamma_release(&gamma);
+
+	if (!ret) {
+		stream->out_transfer_func->type = old_type;
+		DRM_ERROR("Out of memory when calculating regamma params\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/**
+ * amdgpu_dm_set_ctm: Set the color transform matrix for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's gamut remap matrix in preparation
+ * for hardware commit. If no matrix is specified by user, gamut remap will be
+ * disabled.
+ */
+void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
+{
+
+	struct drm_property_blob *blob = crtc->base.ctm;
+	struct dc_stream_state *stream = crtc->stream;
+	struct drm_color_ctm *ctm;
 	int64_t val;
 	int i;
 
+	if (!blob) {
+		stream->gamut_remap_matrix.enable_remap = false;
+		return;
+	}
+
+	stream->gamut_remap_matrix.enable_remap = true;
+	ctm = (struct drm_color_ctm *)blob->data;
 	/*
 	 * DRM gives a 3x3 matrix, but DC wants 3x4. Assuming we're operating
 	 * with homogeneous coordinates, augment the matrix with 0's.
@@ -175,306 +215,83 @@ static void __drm_ctm_to_dc_matrix(const struct drm_color_ctm *ctm,
 	for (i = 0; i < 12; i++) {
 		/* Skip 4th element */
 		if (i % 4 == 3) {
-			matrix[i] = dc_fixpt_zero;
+			stream->gamut_remap_matrix.matrix[i] = dc_fixpt_zero;
 			continue;
 		}
 
 		/* gamut_remap_matrix[i] = ctm[i - floor(i/4)] */
-		val = ctm->matrix[i - (i / 4)];
+		val = ctm->matrix[i - (i/4)];
 		/* If negative, convert to 2's complement. */
 		if (val & (1ULL << 63))
 			val = -(val & ~(1ULL << 63));
 
-		matrix[i].value = val;
+		stream->gamut_remap_matrix.matrix[i].value = val;
 	}
 }
 
 
-/* Calculates the legacy transfer function - only for sRGB input space. */
-static int __set_legacy_tf(struct dc_transfer_func *func,
-                           const struct drm_color_lut *lut, uint32_t lut_size,
-                           bool has_rom)
-{
-        struct dc_gamma *gamma = NULL;
-        bool res;
-
-        ASSERT(lut && lut_size == MAX_COLOR_LEGACY_LUT_ENTRIES);
-
-        gamma = dc_create_gamma();
-        if (!gamma)
-                return -ENOMEM;
-
-        gamma->type = GAMMA_RGB_256;
-        gamma->num_entries = lut_size;
-        __drm_lut_to_dc_gamma(lut, gamma, true);
-
-        res = mod_color_calculate_regamma_params(func, gamma, true, has_rom,
-                                                 NULL);
-
-        return res ? 0 : -ENOMEM;
-}
-
-/* Calculates the output transfer function based on expected input space. */
-static int __set_output_tf(struct dc_transfer_func *func,
-                           const struct drm_color_lut *lut, uint32_t lut_size,
-                           bool has_rom)
+/**
+ * amdgpu_dm_set_degamma_lut: Set degamma lut for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's input transfer function (ITF) in
+ * preparation for hardware commit. If no lut is specified by user, we default
+ * to SRGB degamma.
+ *
+ * We support degamma bypass, predefined SRGB, and custom degamma
+ *
+ * RETURNS:
+ * 0 on success
+ * -EINVAL if crtc_state has a degamma_lut of invalid size
+ * -ENOMEM if gamma allocation fails
+ */
+int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
+			      struct dc_plane_state *dc_plane_state)
 {
-        struct dc_gamma *gamma = NULL;
-        bool res;
+	struct drm_property_blob *blob = crtc_state->degamma_lut;
+	struct drm_color_lut *lut;
+	uint32_t lut_size;
+	struct dc_gamma *gamma;
+	bool ret;
+
+	if (!blob) {
+		/* Default to SRGB */
+		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+		return 0;
+	}
 
-	ASSERT(lut && lut_size == MAX_COLOR_LUT_ENTRIES);
+	lut = (struct drm_color_lut *)blob->data;
+	if (__is_lut_linear(lut, MAX_COLOR_LUT_ENTRIES)) {
+		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+		return 0;
+	}
 
 	gamma = dc_create_gamma();
 	if (!gamma)
 		return -ENOMEM;
 
+	lut_size = blob->length / sizeof(struct drm_color_lut);
 	gamma->num_entries = lut_size;
-	__drm_lut_to_dc_gamma(lut, gamma, false);
-
-	if (func->tf == TRANSFER_FUNCTION_LINEAR) {
-		/*
-                 * Color module doesn't like calculating regamma params
-                 * on top of a linear input. But degamma params can be used
-                 * instead to simulate this.
-                 */
+	if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
 		gamma->type = GAMMA_CUSTOM;
-		res = mod_color_calculate_degamma_params(func, gamma, true);
-	} else {
-                /*
-                 * Assume sRGB. The actual mapping will depend on whether the
-                 * input was legacy or not.
-                 */
-                gamma->type = GAMMA_CS_TFM_1D;
-                res = mod_color_calculate_regamma_params(func, gamma, false,
-                                                         has_rom, NULL);
+	else {
+		dc_gamma_release(&gamma);
+		return -EINVAL;
 	}
-	dc_gamma_release(&gamma);
-
-	return res ? 0 : -ENOMEM;
-}
-
-/* Caculates the input transfer function based on expected input space. */
-static int __set_input_tf(struct dc_transfer_func *func,
-                          const struct drm_color_lut *lut, uint32_t lut_size)
-{
-        struct dc_gamma *gamma = NULL;
-        bool res;
-
-        gamma = dc_create_gamma();
-        if (!gamma)
-                return -ENOMEM;
-
-        gamma->type = GAMMA_CUSTOM;
-        gamma->num_entries = lut_size;
 
 	__drm_lut_to_dc_gamma(lut, gamma, false);
 
-	res = mod_color_calculate_degamma_params(func, gamma, true);
+	dc_plane_state->in_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+	ret = mod_color_calculate_degamma_params(dc_plane_state->in_transfer_func, gamma, true);
 	dc_gamma_release(&gamma);
-
-	return res ? 0 : -ENOMEM;
-}
-
-/**
- * amdgpu_dm_update_crtc_color_mgmt: Maps DRM color management to DC stream.
- * @crtc: amdgpu_dm crtc state
- *
- * With no plane level color management properties we're free to use any
- * of the HW blocks as long as the CRTC CTM always comes before the
- * CRTC RGM and after the CRTC DGM.
- *
- * The CRTC RGM block will be placed in the RGM LUT block if it is non-linear.
- * The CRTC DGM block will be placed in the DGM LUT block if it is non-linear.
- * The CRTC CTM will be placed in the gamut remap block if it is non-linear.
- *
- * The RGM block is typically more fully featured and accurate across
- * all ASICs - DCE can't support a custom non-linear CRTC DGM.
- *
- * For supporting both plane level color management and CRTC level color
- * management at once we have to either restrict the usage of CRTC properties
- * or blend adjustments together.
- *
- * Returns 0 on success.
- */
-int amdgpu_dm_update_crtc_color_mgmt(struct dm_crtc_state *crtc)
-{
-        struct dc_stream_state *stream = crtc->stream;
-        struct amdgpu_device *adev =
-                (struct amdgpu_device *)crtc->base.state->dev->dev_private;
-        bool has_rom = adev->asic_type <= CHIP_RAVEN;
-        struct drm_color_ctm *ctm = NULL;
-        const struct drm_color_lut *degamma_lut, *regamma_lut;
-        uint32_t degamma_size, regamma_size;
-        bool has_regamma, has_degamma;
-        bool is_legacy;
-        int r;
-
-        degamma_lut = __extract_blob_lut(crtc->base.degamma_lut, &degamma_size);
-        if (degamma_lut && degamma_size != MAX_COLOR_LUT_ENTRIES)
-                return -EINVAL;
-
-        regamma_lut = __extract_blob_lut(crtc->base.gamma_lut, &regamma_size);
-        if (regamma_lut && regamma_size != MAX_COLOR_LUT_ENTRIES &&
-            regamma_size != MAX_COLOR_LEGACY_LUT_ENTRIES)
-                return -EINVAL;
-
-        has_degamma =
-                degamma_lut && !__is_lut_linear(degamma_lut, degamma_size);
-
-        has_regamma =
-                regamma_lut && !__is_lut_linear(regamma_lut, regamma_size);
-
-        is_legacy = regamma_size == MAX_COLOR_LEGACY_LUT_ENTRIES;
-
-        /* Reset all adjustments. */
-        crtc->cm_has_degamma = false;
-        crtc->cm_is_degamma_srgb = false;
-
-        /* Setup regamma and degamma. */
-        if (is_legacy) {
-                /*
-                 * Legacy regamma forces us to use the sRGB RGM as a base.
-                 * This also means we can't use linear DGM since DGM needs
-                 * to use sRGB as a base as well, resulting in incorrect CRTC
-                 * DGM and CRTC CTM.
-                 *
-                 * TODO: Just map this to the standard regamma interface
-                 * instead since this isn't really right. One of the cases
-                 * where this setup currently fails is trying to do an
-                 * inverse color ramp in legacy userspace.
-                 */
-                crtc->cm_is_degamma_srgb = true;
-                stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
-                stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-
-                r = __set_legacy_tf(stream->out_transfer_func, regamma_lut,
-                                    regamma_size, has_rom);
-                if (r)
-                        return r;
-        } else if (has_regamma) {
-                /* CRTC RGM goes into RGM LUT. */
-                stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
-                stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
-
-                r = __set_output_tf(stream->out_transfer_func, regamma_lut,
-                                    regamma_size, has_rom);
-                if (r)
-                        return r;
-        } else {
-                /*
-                 * No CRTC RGM means we can just put the block into bypass
-                 * since we don't have any plane level adjustments using it.
-                 */
-                stream->out_transfer_func->type = TF_TYPE_BYPASS;
-                stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
-        }
-
-        /*
-         * CRTC DGM goes into DGM LUT. It would be nice to place it
-         * into the RGM since it's a more featured block but we'd
-         * have to place the CTM in the OCSC in that case.
-         */
-        crtc->cm_has_degamma = has_degamma;
-	        /* Setup CRTC CTM. */
-        if (crtc->base.ctm) {
-                ctm = (struct drm_color_ctm *)crtc->base.ctm->data;
-
-                /*
-                 * Gamut remapping must be used for gamma correction
-                 * since it comes before the regamma correction.
-                 *
-                 * OCSC could be used for gamma correction, but we'd need to
-                 * blend the adjustments together with the required output
-                 * conversion matrix - so just use the gamut remap block
-                 * for now.
-                 */
-                __drm_ctm_to_dc_matrix(ctm, stream->gamut_remap_matrix.matrix);
-
-                stream->gamut_remap_matrix.enable_remap = true;
-                stream->csc_color_matrix.enable_adjustment = false;
-        } else {
-                /* Bypass CTM. */
-                stream->gamut_remap_matrix.enable_remap = false;
-                stream->csc_color_matrix.enable_adjustment = false;
+	if (!ret) {
+		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+		DRM_ERROR("Out of memory when calculating degamma params\n");
+		return -ENOMEM;
 	}
 
 	return 0;
 }
 
-/**
- * amdgpu_dm_update_plane_color_mgmt: Maps DRM color management to DC plane.
- * @crtc: amdgpu_dm crtc state
- * @ dc_plane_state: target DC surface
- *
- * Update the underlying dc_stream_state's input transfer function (ITF) in
- * preparation for hardware commit. The transfer function used depends on
- * the prepartion done on the stream for color management.
- *
- * Returns 0 on success.
- */
-int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
-                                      struct dc_plane_state *dc_plane_state)
-{
-        const struct drm_color_lut *degamma_lut;
-        uint32_t degamma_size;
-        int r;
-
-        if (crtc->cm_has_degamma) {
-                degamma_lut = __extract_blob_lut(crtc->base.degamma_lut,
-                                                 &degamma_size);
-                ASSERT(degamma_size == MAX_COLOR_LUT_ENTRIES);
-
-                dc_plane_state->in_transfer_func->type =
-                        TF_TYPE_DISTRIBUTED_POINTS;
-
-                /*
-                 * This case isn't fully correct, but also fairly
-                 * uncommon. This is userspace trying to use a
-                 * legacy gamma LUT + atomic degamma LUT
-                 * at the same time.
-                 *
-                 * Legacy gamma requires the input to be in linear
-                 * space, so that means we need to apply an sRGB
-                 * degamma. But color module also doesn't support
-                 * a user ramp in this case so the degamma will
-                 * be lost.
-                 *
-                 * Even if we did support it, it's still not right:
-                 *
-                 * Input -> CRTC DGM -> sRGB DGM -> CRTC CTM ->
-                 * sRGB RGM -> CRTC RGM -> Output
-                 *
-                 * The CSC will be done in the wrong space since
-                 * we're applying an sRGB DGM on top of the CRTC
-                 * DGM.
-                 *
-                 * TODO: Don't use the legacy gamma interface and just
-                 * map these to the atomic one instead.
-                 */
-                if (crtc->cm_is_degamma_srgb)
-                        dc_plane_state->in_transfer_func->tf =
-                                TRANSFER_FUNCTION_SRGB;
-                else
-                        dc_plane_state->in_transfer_func->tf =
-                                TRANSFER_FUNCTION_LINEAR;
-
-                r = __set_input_tf(dc_plane_state->in_transfer_func,
-                                   degamma_lut, degamma_size);
-                if (r)
-                        return r;
-        } else if (crtc->cm_is_degamma_srgb) {
-                /*
-                 * For legacy gamma support we need the regamma input
-                 * in linear space. Assume that the input is sRGB.
-                 */
-                dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
-                dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-        } else {
-                /* ...Otherwise we can just bypass the DGM block. */
-                dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
-                dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
-        }
-
-        return 0;
-}
-
-- 
2.17.1

