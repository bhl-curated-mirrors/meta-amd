From c7ed3ee82f4d7308afc7076b3bd9fc44ca383e9f Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Tue, 14 Aug 2018 16:12:54 -0400
Subject: [PATCH 0327/2940] drm/amd/display: remove dead dc vbios code

Change-Id: Id1e7c39db419f13cf478c6a0c6f4b84c039acffe
Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
---
 .../gpu/drm/amd/display/dc/bios/bios_parser.c | 1177 -----------------
 .../drm/amd/display/dc/bios/bios_parser2.c    |  312 +----
 .../gpu/drm/amd/display/dc/dc_bios_types.h    |   64 -
 3 files changed, 39 insertions(+), 1514 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c b/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c
index bfa5816cfc92..0e1dc1b1a48d 100644
--- a/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c
@@ -52,24 +52,13 @@
 #define DC_LOGGER \
 	bp->base.ctx->logger
 
-/* GUID to validate external display connection info table (aka OPM module) */
-static const uint8_t ext_display_connection_guid[NUMBER_OF_UCHAR_FOR_GUID] = {
-	0x91, 0x6E, 0x57, 0x09,
-	0x3F, 0x6D, 0xD2, 0x11,
-	0x39, 0x8E, 0x00, 0xA0,
-	0xC9, 0x69, 0x72, 0x3B};
-
 #define DATA_TABLES(table) (bp->master_data_tbl->ListOfDataTables.table)
 
 static void get_atom_data_table_revision(
 	ATOM_COMMON_TABLE_HEADER *atom_data_tbl,
 	struct atom_data_revision *tbl_revision);
-static uint32_t get_dst_number_from_object(struct bios_parser *bp,
-	ATOM_OBJECT *object);
 static uint32_t get_src_obj_list(struct bios_parser *bp, ATOM_OBJECT *object,
 	uint16_t **id_list);
-static uint32_t get_dest_obj_list(struct bios_parser *bp,
-	ATOM_OBJECT *object, uint16_t **id_list);
 static ATOM_OBJECT *get_bios_object(struct bios_parser *bp,
 	struct graphics_object_id id);
 static enum bp_result get_gpio_i2c_info(struct bios_parser *bp,
@@ -163,29 +152,6 @@ static uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb)
 		le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset));
 }
 
-static struct graphics_object_id bios_parser_get_encoder_id(
-	struct dc_bios *dcb,
-	uint32_t i)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-	struct graphics_object_id object_id = dal_graphics_object_id_init(
-		0, ENUM_ID_UNKNOWN, OBJECT_TYPE_UNKNOWN);
-
-	uint32_t encoder_table_offset = bp->object_info_tbl_offset
-		+ le16_to_cpu(bp->object_info_tbl.v1_1->usEncoderObjectTableOffset);
-
-	ATOM_OBJECT_TABLE *tbl =
-		GET_IMAGE(ATOM_OBJECT_TABLE, encoder_table_offset);
-
-	if (tbl && tbl->ucNumberOfObjects > i) {
-		const uint16_t id = le16_to_cpu(tbl->asObjects[i].usObjectID);
-
-		object_id = object_id_from_bios_object_id(id);
-	}
-
-	return object_id;
-}
-
 static struct graphics_object_id bios_parser_get_connector_id(
 	struct dc_bios *dcb,
 	uint8_t i)
@@ -217,15 +183,6 @@ static struct graphics_object_id bios_parser_get_connector_id(
 	return object_id;
 }
 
-static uint32_t bios_parser_get_dst_number(struct dc_bios *dcb,
-	struct graphics_object_id id)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-	ATOM_OBJECT *object = get_bios_object(bp, id);
-
-	return get_dst_number_from_object(bp, object);
-}
-
 static enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,
 	struct graphics_object_id object_id, uint32_t index,
 	struct graphics_object_id *src_object_id)
@@ -255,30 +212,6 @@ static enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,
 	return BP_RESULT_OK;
 }
 
-static enum bp_result bios_parser_get_dst_obj(struct dc_bios *dcb,
-	struct graphics_object_id object_id, uint32_t index,
-	struct graphics_object_id *dest_object_id)
-{
-	uint32_t number;
-	uint16_t *id = NULL;
-	ATOM_OBJECT *object;
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!dest_object_id)
-		return BP_RESULT_BADINPUT;
-
-	object = get_bios_object(bp, object_id);
-
-	number = get_dest_obj_list(bp, object, &id);
-
-	if (number <= index || !id)
-		return BP_RESULT_BADINPUT;
-
-	*dest_object_id = object_id_from_bios_object_id(id[index]);
-
-	return BP_RESULT_OK;
-}
-
 static enum bp_result bios_parser_get_i2c_info(struct dc_bios *dcb,
 	struct graphics_object_id id,
 	struct graphics_object_i2c_info *info)
@@ -325,196 +258,6 @@ static enum bp_result bios_parser_get_i2c_info(struct dc_bios *dcb,
 	return BP_RESULT_NORECORD;
 }
 
-static enum bp_result get_voltage_ddc_info_v1(uint8_t *i2c_line,
-	ATOM_COMMON_TABLE_HEADER *header,
-	uint8_t *address)
-{
-	enum bp_result result = BP_RESULT_NORECORD;
-	ATOM_VOLTAGE_OBJECT_INFO *info =
-		(ATOM_VOLTAGE_OBJECT_INFO *) address;
-
-	uint8_t *voltage_current_object = (uint8_t *) &info->asVoltageObj[0];
-
-	while ((address + le16_to_cpu(header->usStructureSize)) > voltage_current_object) {
-		ATOM_VOLTAGE_OBJECT *object =
-			(ATOM_VOLTAGE_OBJECT *) voltage_current_object;
-
-		if ((object->ucVoltageType == SET_VOLTAGE_INIT_MODE) &&
-			(object->ucVoltageType &
-				VOLTAGE_CONTROLLED_BY_I2C_MASK)) {
-
-			*i2c_line = object->asControl.ucVoltageControlI2cLine
-					^ 0x90;
-			result = BP_RESULT_OK;
-			break;
-		}
-
-		voltage_current_object += object->ucSize;
-	}
-	return result;
-}
-
-static enum bp_result get_voltage_ddc_info_v3(uint8_t *i2c_line,
-	uint32_t index,
-	ATOM_COMMON_TABLE_HEADER *header,
-	uint8_t *address)
-{
-	enum bp_result result = BP_RESULT_NORECORD;
-	ATOM_VOLTAGE_OBJECT_INFO_V3_1 *info =
-		(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *) address;
-
-	uint8_t *voltage_current_object =
-		(uint8_t *) (&(info->asVoltageObj[0]));
-
-	while ((address + le16_to_cpu(header->usStructureSize)) > voltage_current_object) {
-		ATOM_I2C_VOLTAGE_OBJECT_V3 *object =
-			(ATOM_I2C_VOLTAGE_OBJECT_V3 *) voltage_current_object;
-
-		if (object->sHeader.ucVoltageMode ==
-			ATOM_INIT_VOLTAGE_REGULATOR) {
-			if (object->sHeader.ucVoltageType == index) {
-				*i2c_line = object->ucVoltageControlI2cLine
-						^ 0x90;
-				result = BP_RESULT_OK;
-				break;
-			}
-		}
-
-		voltage_current_object += le16_to_cpu(object->sHeader.usSize);
-	}
-	return result;
-}
-
-static enum bp_result bios_parser_get_thermal_ddc_info(
-	struct dc_bios *dcb,
-	uint32_t i2c_channel_id,
-	struct graphics_object_i2c_info *info)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-	ATOM_I2C_ID_CONFIG_ACCESS *config;
-	ATOM_I2C_RECORD record;
-
-	if (!info)
-		return BP_RESULT_BADINPUT;
-
-	config = (ATOM_I2C_ID_CONFIG_ACCESS *) &i2c_channel_id;
-
-	record.sucI2cId.bfHW_Capable = config->sbfAccess.bfHW_Capable;
-	record.sucI2cId.bfI2C_LineMux = config->sbfAccess.bfI2C_LineMux;
-	record.sucI2cId.bfHW_EngineID = config->sbfAccess.bfHW_EngineID;
-
-	return get_gpio_i2c_info(bp, &record, info);
-}
-
-static enum bp_result bios_parser_get_voltage_ddc_info(struct dc_bios *dcb,
-	uint32_t index,
-	struct graphics_object_i2c_info *info)
-{
-	uint8_t i2c_line = 0;
-	enum bp_result result = BP_RESULT_NORECORD;
-	uint8_t *voltage_info_address;
-	ATOM_COMMON_TABLE_HEADER *header;
-	struct atom_data_revision revision = {0};
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!DATA_TABLES(VoltageObjectInfo))
-		return result;
-
-	voltage_info_address = bios_get_image(&bp->base, DATA_TABLES(VoltageObjectInfo), sizeof(ATOM_COMMON_TABLE_HEADER));
-
-	header = (ATOM_COMMON_TABLE_HEADER *) voltage_info_address;
-
-	get_atom_data_table_revision(header, &revision);
-
-	switch (revision.major) {
-	case 1:
-	case 2:
-		result = get_voltage_ddc_info_v1(&i2c_line, header,
-			voltage_info_address);
-		break;
-	case 3:
-		if (revision.minor != 1)
-			break;
-		result = get_voltage_ddc_info_v3(&i2c_line, index, header,
-			voltage_info_address);
-		break;
-	}
-
-	if (result == BP_RESULT_OK)
-		result = bios_parser_get_thermal_ddc_info(dcb,
-			i2c_line, info);
-
-	return result;
-}
-
-/* TODO: temporary commented out to suppress 'defined but not used' warning */
-#if 0
-static enum bp_result bios_parser_get_ddc_info_for_i2c_line(
-	struct bios_parser *bp,
-	uint8_t i2c_line, struct graphics_object_i2c_info *info)
-{
-	uint32_t offset;
-	ATOM_OBJECT *object;
-	ATOM_OBJECT_TABLE *table;
-	uint32_t i;
-
-	if (!info)
-		return BP_RESULT_BADINPUT;
-
-	offset = le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);
-
-	offset += bp->object_info_tbl_offset;
-
-	table = GET_IMAGE(ATOM_OBJECT_TABLE, offset);
-
-	if (!table)
-		return BP_RESULT_BADBIOSTABLE;
-
-	for (i = 0; i < table->ucNumberOfObjects; i++) {
-		object = &table->asObjects[i];
-
-		if (!object) {
-			BREAK_TO_DEBUGGER(); /* Invalid object id */
-			return BP_RESULT_BADINPUT;
-		}
-
-		offset = le16_to_cpu(object->usRecordOffset)
-				+ bp->object_info_tbl_offset;
-
-		for (;;) {
-			ATOM_COMMON_RECORD_HEADER *header =
-				GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
-
-			if (!header)
-				return BP_RESULT_BADBIOSTABLE;
-
-			offset += header->ucRecordSize;
-
-			if (LAST_RECORD_TYPE == header->ucRecordType ||
-				!header->ucRecordSize)
-				break;
-
-			if (ATOM_I2C_RECORD_TYPE == header->ucRecordType
-				&& sizeof(ATOM_I2C_RECORD) <=
-				header->ucRecordSize) {
-				ATOM_I2C_RECORD *record =
-					(ATOM_I2C_RECORD *) header;
-
-				if (i2c_line != record->sucI2cId.bfI2C_LineMux)
-					continue;
-
-				/* get the I2C info */
-				if (get_gpio_i2c_info(bp, record, info) ==
-					BP_RESULT_OK)
-					return BP_RESULT_OK;
-			}
-		}
-	}
-
-	return BP_RESULT_NORECORD;
-}
-#endif
-
 static enum bp_result bios_parser_get_hpd_info(struct dc_bios *dcb,
 	struct graphics_object_id id,
 	struct graphics_object_hpd_info *info)
@@ -1129,62 +872,6 @@ static bool bios_parser_is_device_id_supported(
 	return (le16_to_cpu(bp->object_info_tbl.v1_1->usDeviceSupport) & mask) != 0;
 }
 
-static enum bp_result bios_parser_crt_control(
-	struct dc_bios *dcb,
-	enum engine_id engine_id,
-	bool enable,
-	uint32_t pixel_clock)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-	uint8_t standard;
-
-	if (!bp->cmd_tbl.dac1_encoder_control &&
-		engine_id == ENGINE_ID_DACA)
-		return BP_RESULT_FAILURE;
-	if (!bp->cmd_tbl.dac2_encoder_control &&
-		engine_id == ENGINE_ID_DACB)
-		return BP_RESULT_FAILURE;
-	/* validate params */
-	switch (engine_id) {
-	case ENGINE_ID_DACA:
-	case ENGINE_ID_DACB:
-		break;
-	default:
-		/* unsupported engine */
-		return BP_RESULT_FAILURE;
-	}
-
-	standard = ATOM_DAC1_PS2; /* == ATOM_DAC2_PS2 */
-
-	if (enable) {
-		if (engine_id == ENGINE_ID_DACA) {
-			bp->cmd_tbl.dac1_encoder_control(bp, enable,
-				pixel_clock, standard);
-			if (bp->cmd_tbl.dac1_output_control != NULL)
-				bp->cmd_tbl.dac1_output_control(bp, enable);
-		} else {
-			bp->cmd_tbl.dac2_encoder_control(bp, enable,
-				pixel_clock, standard);
-			if (bp->cmd_tbl.dac2_output_control != NULL)
-				bp->cmd_tbl.dac2_output_control(bp, enable);
-		}
-	} else {
-		if (engine_id == ENGINE_ID_DACA) {
-			if (bp->cmd_tbl.dac1_output_control != NULL)
-				bp->cmd_tbl.dac1_output_control(bp, enable);
-			bp->cmd_tbl.dac1_encoder_control(bp, enable,
-				pixel_clock, standard);
-		} else {
-			if (bp->cmd_tbl.dac2_output_control != NULL)
-				bp->cmd_tbl.dac2_output_control(bp, enable);
-			bp->cmd_tbl.dac2_encoder_control(bp, enable,
-				pixel_clock, standard);
-		}
-	}
-
-	return BP_RESULT_OK;
-}
-
 static ATOM_HPD_INT_RECORD *get_hpd_record(struct bios_parser *bp,
 	ATOM_OBJECT *object)
 {
@@ -1219,49 +906,6 @@ static ATOM_HPD_INT_RECORD *get_hpd_record(struct bios_parser *bp,
 	return NULL;
 }
 
-/**
- * Get I2C information of input object id
- *
- * search all records to find the ATOM_I2C_RECORD_TYPE record IR
- */
-static ATOM_I2C_RECORD *get_i2c_record(
-	struct bios_parser *bp,
-	ATOM_OBJECT *object)
-{
-	uint32_t offset;
-	ATOM_COMMON_RECORD_HEADER *record_header;
-
-	if (!object) {
-		BREAK_TO_DEBUGGER();
-		/* Invalid object */
-		return NULL;
-	}
-
-	offset = le16_to_cpu(object->usRecordOffset)
-			+ bp->object_info_tbl_offset;
-
-	for (;;) {
-		record_header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
-
-		if (!record_header)
-			return NULL;
-
-		if (LAST_RECORD_TYPE == record_header->ucRecordType ||
-			0 == record_header->ucRecordSize)
-			break;
-
-		if (ATOM_I2C_RECORD_TYPE == record_header->ucRecordType &&
-			sizeof(ATOM_I2C_RECORD) <=
-			record_header->ucRecordSize) {
-			return (ATOM_I2C_RECORD *)record_header;
-		}
-
-		offset += record_header->ucRecordSize;
-	}
-
-	return NULL;
-}
-
 static enum bp_result get_ss_info_from_ss_info_table(
 	struct bios_parser *bp,
 	uint32_t id,
@@ -2356,40 +2000,6 @@ static ATOM_OBJECT *get_bios_object(struct bios_parser *bp,
 	return NULL;
 }
 
-static uint32_t get_dest_obj_list(struct bios_parser *bp,
-	ATOM_OBJECT *object, uint16_t **id_list)
-{
-	uint32_t offset;
-	uint8_t *number;
-
-	if (!object) {
-		BREAK_TO_DEBUGGER(); /* Invalid object id */
-		return 0;
-	}
-
-	offset = le16_to_cpu(object->usSrcDstTableOffset)
-						+ bp->object_info_tbl_offset;
-
-	number = GET_IMAGE(uint8_t, offset);
-	if (!number)
-		return 0;
-
-	offset += sizeof(uint8_t);
-	offset += sizeof(uint16_t) * (*number);
-
-	number = GET_IMAGE(uint8_t, offset);
-	if ((!number) || (!*number))
-		return 0;
-
-	offset += sizeof(uint8_t);
-	*id_list = (uint16_t *)bios_get_image(&bp->base, offset, *number * sizeof(uint16_t));
-
-	if (!*id_list)
-		return 0;
-
-	return *number;
-}
-
 static uint32_t get_src_obj_list(struct bios_parser *bp, ATOM_OBJECT *object,
 	uint16_t **id_list)
 {
@@ -2417,35 +2027,6 @@ static uint32_t get_src_obj_list(struct bios_parser *bp, ATOM_OBJECT *object,
 	return *number;
 }
 
-static uint32_t get_dst_number_from_object(struct bios_parser *bp,
-	ATOM_OBJECT *object)
-{
-	uint32_t offset;
-	uint8_t *number;
-
-	if (!object) {
-		BREAK_TO_DEBUGGER(); /* Invalid encoder object id*/
-		return 0;
-	}
-
-	offset = le16_to_cpu(object->usSrcDstTableOffset)
-					+ bp->object_info_tbl_offset;
-
-	number = GET_IMAGE(uint8_t, offset);
-	if (!number)
-		return 0;
-
-	offset += sizeof(uint8_t);
-	offset += sizeof(uint16_t) * (*number);
-
-	number = GET_IMAGE(uint8_t, offset);
-
-	if (!number)
-		return 0;
-
-	return *number;
-}
-
 static struct device_id device_type_from_device_id(uint16_t device_id)
 {
 
@@ -2624,750 +2205,6 @@ static uint32_t get_support_mask_for_device_id(struct device_id device_id)
 	return 0;
 }
 
-/**
- *  HwContext interface for writing MM registers
- */
-
-static bool i2c_read(
-	struct bios_parser *bp,
-	struct graphics_object_i2c_info *i2c_info,
-	uint8_t *buffer,
-	uint32_t length)
-{
-	struct ddc *ddc;
-	uint8_t offset[2] = { 0, 0 };
-	bool result = false;
-	struct i2c_command cmd;
-	struct gpio_ddc_hw_info hw_info = {
-		i2c_info->i2c_hw_assist,
-		i2c_info->i2c_line };
-
-	ddc = dal_gpio_create_ddc(bp->base.ctx->gpio_service,
-		i2c_info->gpio_info.clk_a_register_index,
-		(1 << i2c_info->gpio_info.clk_a_shift), &hw_info);
-
-	if (!ddc)
-		return result;
-
-	/*Using SW engine */
-	cmd.engine = I2C_COMMAND_ENGINE_SW;
-	cmd.speed = ddc->ctx->dc->caps.i2c_speed_in_khz;
-
-	{
-		struct i2c_payload payloads[] = {
-				{
-						.address = i2c_info->i2c_slave_address >> 1,
-						.data = offset,
-						.length = sizeof(offset),
-						.write = true
-				},
-				{
-						.address = i2c_info->i2c_slave_address >> 1,
-						.data = buffer,
-						.length = length,
-						.write = false
-				}
-		};
-
-		cmd.payloads = payloads;
-		cmd.number_of_payloads = ARRAY_SIZE(payloads);
-		result = dc_submit_i2c(
-				ddc->ctx->dc,
-				ddc->hw_info.ddc_channel,
-				&cmd);
-	}
-
-	dal_gpio_destroy_ddc(&ddc);
-
-	return result;
-}
-
-/**
- * Read external display connection info table through i2c.
- * validate the GUID and checksum.
- *
- * @return enum bp_result whether all data was sucessfully read
- */
-static enum bp_result get_ext_display_connection_info(
-	struct bios_parser *bp,
-	ATOM_OBJECT *opm_object,
-	ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO *ext_display_connection_info_tbl)
-{
-	bool config_tbl_present = false;
-	ATOM_I2C_RECORD *i2c_record = NULL;
-	uint32_t i = 0;
-
-	if (opm_object == NULL)
-		return BP_RESULT_BADINPUT;
-
-	i2c_record = get_i2c_record(bp, opm_object);
-
-	if (i2c_record != NULL) {
-		ATOM_GPIO_I2C_INFO *gpio_i2c_header;
-		struct graphics_object_i2c_info i2c_info;
-
-		gpio_i2c_header = GET_IMAGE(ATOM_GPIO_I2C_INFO,
-				bp->master_data_tbl->ListOfDataTables.GPIO_I2C_Info);
-
-		if (NULL == gpio_i2c_header)
-			return BP_RESULT_BADBIOSTABLE;
-
-		if (get_gpio_i2c_info(bp, i2c_record, &i2c_info) !=
-				BP_RESULT_OK)
-			return BP_RESULT_BADBIOSTABLE;
-
-		if (i2c_read(bp,
-			     &i2c_info,
-			     (uint8_t *)ext_display_connection_info_tbl,
-			     sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO))) {
-			config_tbl_present = true;
-		}
-	}
-
-	/* Validate GUID */
-	if (config_tbl_present)
-		for (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; i++) {
-			if (ext_display_connection_info_tbl->ucGuid[i]
-			    != ext_display_connection_guid[i]) {
-				config_tbl_present = false;
-				break;
-			}
-		}
-
-	/* Validate checksum */
-	if (config_tbl_present) {
-		uint8_t check_sum = 0;
-		uint8_t *buf =
-				(uint8_t *)ext_display_connection_info_tbl;
-
-		for (i = 0; i < sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO);
-				i++) {
-			check_sum += buf[i];
-		}
-
-		if (check_sum != 0)
-			config_tbl_present = false;
-	}
-
-	if (config_tbl_present)
-		return BP_RESULT_OK;
-	else
-		return BP_RESULT_FAILURE;
-}
-
-/*
- * Gets the first device ID in the same group as the given ID for enumerating.
- * For instance, if any DFP device ID is passed, returns the device ID for DFP1.
- *
- * The first device ID in the same group as the passed device ID, or 0 if no
- * matching device group found.
- */
-static uint32_t enum_first_device_id(uint32_t dev_id)
-{
-	/* Return the first in the group that this ID belongs to. */
-	if (dev_id & ATOM_DEVICE_CRT_SUPPORT)
-		return ATOM_DEVICE_CRT1_SUPPORT;
-	else if (dev_id & ATOM_DEVICE_DFP_SUPPORT)
-		return ATOM_DEVICE_DFP1_SUPPORT;
-	else if (dev_id & ATOM_DEVICE_LCD_SUPPORT)
-		return ATOM_DEVICE_LCD1_SUPPORT;
-	else if (dev_id & ATOM_DEVICE_TV_SUPPORT)
-		return ATOM_DEVICE_TV1_SUPPORT;
-	else if (dev_id & ATOM_DEVICE_CV_SUPPORT)
-		return ATOM_DEVICE_CV_SUPPORT;
-
-	/* No group found for this device ID. */
-
-	dm_error("%s: incorrect input %d\n", __func__, dev_id);
-	/* No matching support flag for given device ID */
-	return 0;
-}
-
-/*
- * Gets the next device ID in the group for a given device ID.
- *
- * The current device ID being enumerated on.
- *
- * The next device ID in the group, or 0 if no device exists.
- */
-static uint32_t enum_next_dev_id(uint32_t dev_id)
-{
-	/* Get next device ID in the group. */
-	switch (dev_id) {
-	case ATOM_DEVICE_CRT1_SUPPORT:
-		return ATOM_DEVICE_CRT2_SUPPORT;
-	case ATOM_DEVICE_LCD1_SUPPORT:
-		return ATOM_DEVICE_LCD2_SUPPORT;
-	case ATOM_DEVICE_DFP1_SUPPORT:
-		return ATOM_DEVICE_DFP2_SUPPORT;
-	case ATOM_DEVICE_DFP2_SUPPORT:
-		return ATOM_DEVICE_DFP3_SUPPORT;
-	case ATOM_DEVICE_DFP3_SUPPORT:
-		return ATOM_DEVICE_DFP4_SUPPORT;
-	case ATOM_DEVICE_DFP4_SUPPORT:
-		return ATOM_DEVICE_DFP5_SUPPORT;
-	case ATOM_DEVICE_DFP5_SUPPORT:
-		return ATOM_DEVICE_DFP6_SUPPORT;
-	}
-
-	/* Done enumerating through devices. */
-	return 0;
-}
-
-/*
- * Returns the new device tag record for patched BIOS object.
- *
- * [IN] pExtDisplayPath - External display path to copy device tag from.
- * [IN] deviceSupport - Bit vector for device ID support flags.
- * [OUT] pDeviceTag - Device tag structure to fill with patched data.
- *
- * True if a compatible device ID was found, false otherwise.
- */
-static bool get_patched_device_tag(
-	struct bios_parser *bp,
-	EXT_DISPLAY_PATH *ext_display_path,
-	uint32_t device_support,
-	ATOM_CONNECTOR_DEVICE_TAG *device_tag)
-{
-	uint32_t dev_id;
-	/* Use fallback behaviour if not supported. */
-	if (!bp->remap_device_tags) {
-		device_tag->ulACPIDeviceEnum =
-				cpu_to_le32((uint32_t) le16_to_cpu(ext_display_path->usDeviceACPIEnum));
-		device_tag->usDeviceID =
-				cpu_to_le16(le16_to_cpu(ext_display_path->usDeviceTag));
-		return true;
-	}
-
-	/* Find the first unused in the same group. */
-	dev_id = enum_first_device_id(le16_to_cpu(ext_display_path->usDeviceTag));
-	while (dev_id != 0) {
-		/* Assign this device ID if supported. */
-		if ((device_support & dev_id) != 0) {
-			device_tag->ulACPIDeviceEnum =
-					cpu_to_le32((uint32_t) le16_to_cpu(ext_display_path->usDeviceACPIEnum));
-			device_tag->usDeviceID = cpu_to_le16((USHORT) dev_id);
-			return true;
-		}
-
-		dev_id = enum_next_dev_id(dev_id);
-	}
-
-	/* No compatible device ID found. */
-	return false;
-}
-
-/*
- * Adds a device tag to a BIOS object's device tag record if there is
- * matching device ID supported.
- *
- * pObject - Pointer to the BIOS object to add the device tag to.
- * pExtDisplayPath - Display path to retrieve base device ID from.
- * pDeviceSupport - Pointer to bit vector for supported device IDs.
- */
-static void add_device_tag_from_ext_display_path(
-	struct bios_parser *bp,
-	ATOM_OBJECT *object,
-	EXT_DISPLAY_PATH *ext_display_path,
-	uint32_t *device_support)
-{
-	/* Get device tag record for object. */
-	ATOM_CONNECTOR_DEVICE_TAG *device_tag = NULL;
-	ATOM_CONNECTOR_DEVICE_TAG_RECORD *device_tag_record = NULL;
-	enum bp_result result =
-			bios_parser_get_device_tag_record(
-					bp, object, &device_tag_record);
-
-	if ((le16_to_cpu(ext_display_path->usDeviceTag) != CONNECTOR_OBJECT_ID_NONE)
-			&& (result == BP_RESULT_OK)) {
-		uint8_t index;
-
-		if ((device_tag_record->ucNumberOfDevice == 1) &&
-				(le16_to_cpu(device_tag_record->asDeviceTag[0].usDeviceID) == 0)) {
-			/*Workaround bug in current VBIOS releases where
-			 * ucNumberOfDevice = 1 but there is no actual device
-			 * tag data. This w/a is temporary until the updated
-			 * VBIOS is distributed. */
-			device_tag_record->ucNumberOfDevice =
-					device_tag_record->ucNumberOfDevice - 1;
-		}
-
-		/* Attempt to find a matching device ID. */
-		index = device_tag_record->ucNumberOfDevice;
-		device_tag = &device_tag_record->asDeviceTag[index];
-		if (get_patched_device_tag(
-				bp,
-				ext_display_path,
-				*device_support,
-				device_tag)) {
-			/* Update cached device support to remove assigned ID.
-			 */
-			*device_support &= ~le16_to_cpu(device_tag->usDeviceID);
-			device_tag_record->ucNumberOfDevice++;
-		}
-	}
-}
-
-/*
- * Read out a single EXT_DISPLAY_PATH from the external display connection info
- * table. The specific entry in the table is determined by the enum_id passed
- * in.
- *
- * EXT_DISPLAY_PATH describing a single Configuration table entry
- */
-
-#define INVALID_CONNECTOR 0xffff
-
-static EXT_DISPLAY_PATH *get_ext_display_path_entry(
-	ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO *config_table,
-	uint32_t bios_object_id)
-{
-	EXT_DISPLAY_PATH *ext_display_path;
-	uint32_t ext_display_path_index =
-			((bios_object_id & ENUM_ID_MASK) >> ENUM_ID_SHIFT) - 1;
-
-	if (ext_display_path_index >= MAX_NUMBER_OF_EXT_DISPLAY_PATH)
-		return NULL;
-
-	ext_display_path = &config_table->sPath[ext_display_path_index];
-
-	if (le16_to_cpu(ext_display_path->usDeviceConnector) == INVALID_CONNECTOR)
-		ext_display_path->usDeviceConnector = cpu_to_le16(0);
-
-	return ext_display_path;
-}
-
-/*
- * Get AUX/DDC information of input object id
- *
- * search all records to find the ATOM_CONNECTOR_AUXDDC_LUT_RECORD_TYPE record
- * IR
- */
-static ATOM_CONNECTOR_AUXDDC_LUT_RECORD *get_ext_connector_aux_ddc_lut_record(
-	struct bios_parser *bp,
-	ATOM_OBJECT *object)
-{
-	uint32_t offset;
-	ATOM_COMMON_RECORD_HEADER *header;
-
-	if (!object) {
-		BREAK_TO_DEBUGGER();
-		/* Invalid object */
-		return NULL;
-	}
-
-	offset = le16_to_cpu(object->usRecordOffset)
-					+ bp->object_info_tbl_offset;
-
-	for (;;) {
-		header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
-
-		if (!header)
-			return NULL;
-
-		if (LAST_RECORD_TYPE == header->ucRecordType ||
-				0 == header->ucRecordSize)
-			break;
-
-		if (ATOM_CONNECTOR_AUXDDC_LUT_RECORD_TYPE ==
-				header->ucRecordType &&
-				sizeof(ATOM_CONNECTOR_AUXDDC_LUT_RECORD) <=
-				header->ucRecordSize)
-			return (ATOM_CONNECTOR_AUXDDC_LUT_RECORD *)(header);
-
-		offset += header->ucRecordSize;
-	}
-
-	return NULL;
-}
-
-/*
- * Get AUX/DDC information of input object id
- *
- * search all records to find the ATOM_CONNECTOR_AUXDDC_LUT_RECORD_TYPE record
- * IR
- */
-static ATOM_CONNECTOR_HPDPIN_LUT_RECORD *get_ext_connector_hpd_pin_lut_record(
-	struct bios_parser *bp,
-	ATOM_OBJECT *object)
-{
-	uint32_t offset;
-	ATOM_COMMON_RECORD_HEADER *header;
-
-	if (!object) {
-		BREAK_TO_DEBUGGER();
-		/* Invalid object */
-		return NULL;
-	}
-
-	offset = le16_to_cpu(object->usRecordOffset)
-					+ bp->object_info_tbl_offset;
-
-	for (;;) {
-		header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
-
-		if (!header)
-			return NULL;
-
-		if (LAST_RECORD_TYPE == header->ucRecordType ||
-				0 == header->ucRecordSize)
-			break;
-
-		if (ATOM_CONNECTOR_HPDPIN_LUT_RECORD_TYPE ==
-				header->ucRecordType &&
-				sizeof(ATOM_CONNECTOR_HPDPIN_LUT_RECORD) <=
-				header->ucRecordSize)
-			return (ATOM_CONNECTOR_HPDPIN_LUT_RECORD *)header;
-
-		offset += header->ucRecordSize;
-	}
-
-	return NULL;
-}
-
-/*
- * Check whether we need to patch the VBIOS connector info table with
- * data from an external display connection info table.  This is
- * necessary to support MXM boards with an OPM (output personality
- * module).  With these designs, the VBIOS connector info table
- * specifies an MXM_CONNECTOR with a unique ID.  The driver retrieves
- * the external connection info table through i2c and then looks up the
- * connector ID to find the real connector type (e.g. DFP1).
- *
- */
-static enum bp_result patch_bios_image_from_ext_display_connection_info(
-	struct bios_parser *bp)
-{
-	ATOM_OBJECT_TABLE *connector_tbl;
-	uint32_t connector_tbl_offset;
-	struct graphics_object_id object_id;
-	ATOM_OBJECT *object;
-	ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO ext_display_connection_info_tbl;
-	EXT_DISPLAY_PATH *ext_display_path;
-	ATOM_CONNECTOR_AUXDDC_LUT_RECORD *aux_ddc_lut_record = NULL;
-	ATOM_I2C_RECORD *i2c_record = NULL;
-	ATOM_CONNECTOR_HPDPIN_LUT_RECORD *hpd_pin_lut_record = NULL;
-	ATOM_HPD_INT_RECORD *hpd_record = NULL;
-	ATOM_OBJECT_TABLE *encoder_table;
-	uint32_t encoder_table_offset;
-	ATOM_OBJECT *opm_object = NULL;
-	uint32_t i = 0;
-	struct graphics_object_id opm_object_id =
-			dal_graphics_object_id_init(
-					GENERIC_ID_MXM_OPM,
-					ENUM_ID_1,
-					OBJECT_TYPE_GENERIC);
-	ATOM_CONNECTOR_DEVICE_TAG_RECORD *dev_tag_record;
-	uint32_t cached_device_support =
-			le16_to_cpu(bp->object_info_tbl.v1_1->usDeviceSupport);
-
-	uint32_t dst_number;
-	uint16_t *dst_object_id_list;
-
-	opm_object = get_bios_object(bp, opm_object_id);
-	if (!opm_object)
-		return BP_RESULT_UNSUPPORTED;
-
-	memset(&ext_display_connection_info_tbl, 0,
-			sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO));
-
-	connector_tbl_offset = bp->object_info_tbl_offset
-			+ le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);
-	connector_tbl = GET_IMAGE(ATOM_OBJECT_TABLE, connector_tbl_offset);
-
-	/* Read Connector info table from EEPROM through i2c */
-	if (get_ext_display_connection_info(bp,
-					    opm_object,
-					    &ext_display_connection_info_tbl) != BP_RESULT_OK) {
-
-		DC_LOG_WARNING("%s: Failed to read Connection Info Table", __func__);
-		return BP_RESULT_UNSUPPORTED;
-	}
-
-	/* Get pointer to AUX/DDC and HPD LUTs */
-	aux_ddc_lut_record =
-			get_ext_connector_aux_ddc_lut_record(bp, opm_object);
-	hpd_pin_lut_record =
-			get_ext_connector_hpd_pin_lut_record(bp, opm_object);
-
-	if ((aux_ddc_lut_record == NULL) || (hpd_pin_lut_record == NULL))
-		return BP_RESULT_UNSUPPORTED;
-
-	/* Cache support bits for currently unmapped device types. */
-	if (bp->remap_device_tags) {
-		for (i = 0; i < connector_tbl->ucNumberOfObjects; ++i) {
-			uint32_t j;
-			/* Remove support for all non-MXM connectors. */
-			object = &connector_tbl->asObjects[i];
-			object_id = object_id_from_bios_object_id(
-					le16_to_cpu(object->usObjectID));
-			if ((OBJECT_TYPE_CONNECTOR != object_id.type) ||
-					(CONNECTOR_ID_MXM == object_id.id))
-				continue;
-
-			/* Remove support for all device tags. */
-			if (bios_parser_get_device_tag_record(
-					bp, object, &dev_tag_record) != BP_RESULT_OK)
-				continue;
-
-			for (j = 0; j < dev_tag_record->ucNumberOfDevice; ++j) {
-				ATOM_CONNECTOR_DEVICE_TAG *device_tag =
-						&dev_tag_record->asDeviceTag[j];
-				cached_device_support &=
-						~le16_to_cpu(device_tag->usDeviceID);
-			}
-		}
-	}
-
-	/* Find all MXM connector objects and patch them with connector info
-	 * from the external display connection info table. */
-	for (i = 0; i < connector_tbl->ucNumberOfObjects; i++) {
-		uint32_t j;
-
-		object = &connector_tbl->asObjects[i];
-		object_id = object_id_from_bios_object_id(le16_to_cpu(object->usObjectID));
-		if ((OBJECT_TYPE_CONNECTOR != object_id.type) ||
-				(CONNECTOR_ID_MXM != object_id.id))
-			continue;
-
-		/* Get the correct connection info table entry based on the enum
-		 * id. */
-		ext_display_path = get_ext_display_path_entry(
-				&ext_display_connection_info_tbl,
-				le16_to_cpu(object->usObjectID));
-		if (!ext_display_path)
-			return BP_RESULT_FAILURE;
-
-		/* Patch device connector ID */
-		object->usObjectID =
-				cpu_to_le16(le16_to_cpu(ext_display_path->usDeviceConnector));
-
-		/* Patch device tag, ulACPIDeviceEnum. */
-		add_device_tag_from_ext_display_path(
-				bp,
-				object,
-				ext_display_path,
-				&cached_device_support);
-
-		/* Patch HPD info */
-		if (ext_display_path->ucExtHPDPINLutIndex <
-				MAX_NUMBER_OF_EXT_HPDPIN_LUT_ENTRIES) {
-			hpd_record = get_hpd_record(bp, object);
-			if (hpd_record) {
-				uint8_t index =
-						ext_display_path->ucExtHPDPINLutIndex;
-				hpd_record->ucHPDIntGPIOID =
-						hpd_pin_lut_record->ucHPDPINMap[index];
-			} else {
-				BREAK_TO_DEBUGGER();
-				/* Invalid hpd record */
-				return BP_RESULT_FAILURE;
-			}
-		}
-
-		/* Patch I2C/AUX info */
-		if (ext_display_path->ucExtHPDPINLutIndex <
-				MAX_NUMBER_OF_EXT_AUXDDC_LUT_ENTRIES) {
-			i2c_record = get_i2c_record(bp, object);
-			if (i2c_record) {
-				uint8_t index =
-						ext_display_path->ucExtAUXDDCLutIndex;
-				i2c_record->sucI2cId =
-						aux_ddc_lut_record->ucAUXDDCMap[index];
-			} else {
-				BREAK_TO_DEBUGGER();
-				/* Invalid I2C record */
-				return BP_RESULT_FAILURE;
-			}
-		}
-
-		/* Merge with other MXM connectors that map to the same physical
-		 * connector. */
-		for (j = i + 1;
-				j < connector_tbl->ucNumberOfObjects; j++) {
-			ATOM_OBJECT *next_object;
-			struct graphics_object_id next_object_id;
-			EXT_DISPLAY_PATH *next_ext_display_path;
-
-			next_object = &connector_tbl->asObjects[j];
-			next_object_id = object_id_from_bios_object_id(
-					le16_to_cpu(next_object->usObjectID));
-
-			if ((OBJECT_TYPE_CONNECTOR != next_object_id.type) &&
-					(CONNECTOR_ID_MXM == next_object_id.id))
-				continue;
-
-			next_ext_display_path = get_ext_display_path_entry(
-					&ext_display_connection_info_tbl,
-					le16_to_cpu(next_object->usObjectID));
-
-			if (next_ext_display_path == NULL)
-				return BP_RESULT_FAILURE;
-
-			/* Merge if using same connector. */
-			if ((le16_to_cpu(next_ext_display_path->usDeviceConnector) ==
-					le16_to_cpu(ext_display_path->usDeviceConnector)) &&
-					(le16_to_cpu(ext_display_path->usDeviceConnector) != 0)) {
-				/* Clear duplicate connector from table. */
-				next_object->usObjectID = cpu_to_le16(0);
-				add_device_tag_from_ext_display_path(
-						bp,
-						object,
-						ext_display_path,
-						&cached_device_support);
-			}
-		}
-	}
-
-	/* Find all encoders which have an MXM object as their destination.
-	 *  Replace the MXM object with the real connector Id from the external
-	 *  display connection info table */
-
-	encoder_table_offset = bp->object_info_tbl_offset
-			+ le16_to_cpu(bp->object_info_tbl.v1_1->usEncoderObjectTableOffset);
-	encoder_table = GET_IMAGE(ATOM_OBJECT_TABLE, encoder_table_offset);
-
-	for (i = 0; i < encoder_table->ucNumberOfObjects; i++) {
-		uint32_t j;
-
-		object = &encoder_table->asObjects[i];
-
-		dst_number = get_dest_obj_list(bp, object, &dst_object_id_list);
-
-		for (j = 0; j < dst_number; j++) {
-			object_id = object_id_from_bios_object_id(
-					dst_object_id_list[j]);
-
-			if ((OBJECT_TYPE_CONNECTOR != object_id.type) ||
-					(CONNECTOR_ID_MXM != object_id.id))
-				continue;
-
-			/* Get the correct connection info table entry based on
-			 * the enum id. */
-			ext_display_path =
-					get_ext_display_path_entry(
-							&ext_display_connection_info_tbl,
-							dst_object_id_list[j]);
-
-			if (ext_display_path == NULL)
-				return BP_RESULT_FAILURE;
-
-			dst_object_id_list[j] =
-					le16_to_cpu(ext_display_path->usDeviceConnector);
-		}
-	}
-
-	return BP_RESULT_OK;
-}
-
-/*
- * Check whether we need to patch the VBIOS connector info table with
- * data from an external display connection info table.  This is
- * necessary to support MXM boards with an OPM (output personality
- * module).  With these designs, the VBIOS connector info table
- * specifies an MXM_CONNECTOR with a unique ID.  The driver retrieves
- * the external connection info table through i2c and then looks up the
- * connector ID to find the real connector type (e.g. DFP1).
- *
- */
-
-static void process_ext_display_connection_info(struct bios_parser *bp)
-{
-	ATOM_OBJECT_TABLE *connector_tbl;
-	uint32_t connector_tbl_offset;
-	struct graphics_object_id object_id;
-	ATOM_OBJECT *object;
-	bool mxm_connector_found = false;
-	bool null_entry_found = false;
-	uint32_t i = 0;
-
-	connector_tbl_offset = bp->object_info_tbl_offset +
-			le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);
-	connector_tbl = GET_IMAGE(ATOM_OBJECT_TABLE, connector_tbl_offset);
-
-	/* Look for MXM connectors to determine whether we need patch the VBIOS
-	 * connector info table. Look for null entries to determine whether we
-	 * need to compact connector table. */
-	for (i = 0; i < connector_tbl->ucNumberOfObjects; i++) {
-		object = &connector_tbl->asObjects[i];
-		object_id = object_id_from_bios_object_id(le16_to_cpu(object->usObjectID));
-
-		if ((OBJECT_TYPE_CONNECTOR == object_id.type) &&
-				(CONNECTOR_ID_MXM == object_id.id)) {
-			/* Once we found MXM connector - we can break */
-			mxm_connector_found = true;
-			break;
-		} else if (OBJECT_TYPE_CONNECTOR != object_id.type) {
-			/* We need to continue looping - to check if MXM
-			 * connector present */
-			null_entry_found = true;
-		}
-	}
-
-	/* Patch BIOS image */
-	if (mxm_connector_found || null_entry_found) {
-		uint32_t connectors_num = 0;
-		uint8_t *original_bios;
-		/* Step 1: Replace bios image with the new copy which will be
-		 * patched */
-		bp->base.bios_local_image = kzalloc(bp->base.bios_size,
-						    GFP_KERNEL);
-		if (bp->base.bios_local_image == NULL) {
-			BREAK_TO_DEBUGGER();
-			/* Failed to alloc bp->base.bios_local_image */
-			return;
-		}
-
-		memmove(bp->base.bios_local_image, bp->base.bios, bp->base.bios_size);
-		original_bios = bp->base.bios;
-		bp->base.bios = bp->base.bios_local_image;
-		connector_tbl =
-				GET_IMAGE(ATOM_OBJECT_TABLE, connector_tbl_offset);
-
-		/* Step 2: (only if MXM connector found) Patch BIOS image with
-		 * info from external module */
-		if (mxm_connector_found &&
-		    patch_bios_image_from_ext_display_connection_info(bp) !=
-						BP_RESULT_OK) {
-			/* Patching the bios image has failed. We will copy
-			 * again original image provided and afterwards
-			 * only remove null entries */
-			memmove(
-					bp->base.bios_local_image,
-					original_bios,
-					bp->base.bios_size);
-		}
-
-		/* Step 3: Compact connector table (remove null entries, valid
-		 * entries moved to beginning) */
-		for (i = 0; i < connector_tbl->ucNumberOfObjects; i++) {
-			object = &connector_tbl->asObjects[i];
-			object_id = object_id_from_bios_object_id(
-					le16_to_cpu(object->usObjectID));
-
-			if (OBJECT_TYPE_CONNECTOR != object_id.type)
-				continue;
-
-			if (i != connectors_num) {
-				memmove(
-						&connector_tbl->
-						asObjects[connectors_num],
-						object,
-						sizeof(ATOM_OBJECT));
-			}
-			++connectors_num;
-		}
-		connector_tbl->ucNumberOfObjects = (uint8_t)connectors_num;
-	}
-}
-
-static void bios_parser_post_init(struct dc_bios *dcb)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	process_ext_display_connection_info(bp);
-}
-
 /**
  * bios_parser_set_scratch_critical_state
  *
@@ -3959,22 +2796,12 @@ static enum bp_result bios_get_board_layout_info(
 static const struct dc_vbios_funcs vbios_funcs = {
 	.get_connectors_number = bios_parser_get_connectors_number,
 
-	.get_encoder_id = bios_parser_get_encoder_id,
-
 	.get_connector_id = bios_parser_get_connector_id,
 
-	.get_dst_number = bios_parser_get_dst_number,
-
 	.get_src_obj = bios_parser_get_src_obj,
 
-	.get_dst_obj = bios_parser_get_dst_obj,
-
 	.get_i2c_info = bios_parser_get_i2c_info,
 
-	.get_voltage_ddc_info = bios_parser_get_voltage_ddc_info,
-
-	.get_thermal_ddc_info = bios_parser_get_thermal_ddc_info,
-
 	.get_hpd_info = bios_parser_get_hpd_info,
 
 	.get_device_tag = bios_parser_get_device_tag,
@@ -3993,7 +2820,6 @@ static const struct dc_vbios_funcs vbios_funcs = {
 
 	/* bios scratch register communication */
 	.is_accelerated_mode = bios_is_accelerated_mode,
-	.get_vga_enabled_displays = bios_get_vga_enabled_displays,
 
 	.set_scratch_critical_state = bios_parser_set_scratch_critical_state,
 
@@ -4004,8 +2830,6 @@ static const struct dc_vbios_funcs vbios_funcs = {
 
 	.transmitter_control = bios_parser_transmitter_control,
 
-	.crt_control = bios_parser_crt_control,  /* not used in DAL3.  keep for now in case we need to support VGA on Bonaire */
-
 	.enable_crtc = bios_parser_enable_crtc,
 
 	.adjust_pixel_clock = bios_parser_adjust_pixel_clock,
@@ -4025,7 +2849,6 @@ static const struct dc_vbios_funcs vbios_funcs = {
 	.enable_disp_power_gating = bios_parser_enable_disp_power_gating,
 
 	/* SW init and patch */
-	.post_init = bios_parser_post_init,  /* patch vbios table for mxm module by reading i2c */
 
 	.bios_parser_destroy = bios_parser_destroy,
 
diff --git a/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c b/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
index eab007e1793c..ff764da21b6f 100644
--- a/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
@@ -166,21 +166,6 @@ static uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb)
 	return count;
 }
 
-static struct graphics_object_id bios_parser_get_encoder_id(
-	struct dc_bios *dcb,
-	uint32_t i)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-	struct graphics_object_id object_id = dal_graphics_object_id_init(
-		0, ENUM_ID_UNKNOWN, OBJECT_TYPE_UNKNOWN);
-
-	if (bp->object_info_tbl.v1_4->number_of_path > i)
-		object_id = object_id_from_bios_object_id(
-		bp->object_info_tbl.v1_4->display_path[i].encoderobjid);
-
-	return object_id;
-}
-
 static struct graphics_object_id bios_parser_get_connector_id(
 	struct dc_bios *dcb,
 	uint8_t i)
@@ -204,26 +189,6 @@ static struct graphics_object_id bios_parser_get_connector_id(
 	return object_id;
 }
 
-
-/*  TODO:  GetNumberOfSrc*/
-
-static uint32_t bios_parser_get_dst_number(struct dc_bios *dcb,
-	struct graphics_object_id id)
-{
-	/* connector has 1 Dest, encoder has 0 Dest */
-	switch (id.type) {
-	case OBJECT_TYPE_ENCODER:
-		return 0;
-	case OBJECT_TYPE_CONNECTOR:
-		return 1;
-	default:
-		return 0;
-	}
-}
-
-/*  removed getSrcObjList, getDestObjList*/
-
-
 static enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,
 	struct graphics_object_id object_id, uint32_t index,
 	struct graphics_object_id *src_object_id)
@@ -283,52 +248,10 @@ static enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,
 	return bp_result;
 }
 
-static enum bp_result bios_parser_get_dst_obj(struct dc_bios *dcb,
-	struct graphics_object_id object_id, uint32_t index,
-	struct graphics_object_id *dest_object_id)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-	unsigned int i;
-	enum bp_result  bp_result = BP_RESULT_BADINPUT;
-	struct graphics_object_id obj_id = {0};
-	struct object_info_table *tbl = &bp->object_info_tbl;
-
-	if (!dest_object_id)
-		return BP_RESULT_BADINPUT;
-
-	switch (object_id.type) {
-	case OBJECT_TYPE_ENCODER:
-		/* TODO: since num of src must be less than 2.
-		 * If found in for loop, should break.
-		 * DAL2 implementation may be changed too
-		 */
-		for (i = 0; i < tbl->v1_4->number_of_path; i++) {
-			obj_id = object_id_from_bios_object_id(
-				tbl->v1_4->display_path[i].encoderobjid);
-			if (object_id.type == obj_id.type &&
-					object_id.id == obj_id.id &&
-						object_id.enum_id ==
-							obj_id.enum_id) {
-				*dest_object_id =
-					object_id_from_bios_object_id(
-				tbl->v1_4->display_path[i].display_objid);
-				/* break; */
-			}
-		}
-		bp_result = BP_RESULT_OK;
-		break;
-	default:
-		break;
-	}
-
-	return bp_result;
-}
-
-
 /* from graphics_object_id, find display path which includes the object_id */
 static struct atom_display_object_path_v2 *get_bios_object(
-	struct bios_parser *bp,
-	struct graphics_object_id id)
+		struct bios_parser *bp,
+		struct graphics_object_id id)
 {
 	unsigned int i;
 	struct graphics_object_id obj_id = {0};
@@ -337,27 +260,22 @@ static struct atom_display_object_path_v2 *get_bios_object(
 	case OBJECT_TYPE_ENCODER:
 		for (i = 0; i < bp->object_info_tbl.v1_4->number_of_path; i++) {
 			obj_id = object_id_from_bios_object_id(
-			bp->object_info_tbl.v1_4->display_path[i].encoderobjid);
-			if (id.type == obj_id.type &&
-					id.id == obj_id.id &&
-						id.enum_id == obj_id.enum_id)
-				return
-				&bp->object_info_tbl.v1_4->display_path[i];
+					bp->object_info_tbl.v1_4->display_path[i].encoderobjid);
+			if (id.type == obj_id.type && id.id == obj_id.id
+					&& id.enum_id == obj_id.enum_id)
+				return &bp->object_info_tbl.v1_4->display_path[i];
 		}
 	case OBJECT_TYPE_CONNECTOR:
 	case OBJECT_TYPE_GENERIC:
 		/* Both Generic and Connector Object ID
 		 * will be stored on display_objid
-		*/
+		 */
 		for (i = 0; i < bp->object_info_tbl.v1_4->number_of_path; i++) {
 			obj_id = object_id_from_bios_object_id(
-			bp->object_info_tbl.v1_4->display_path[i].display_objid
-			);
-			if (id.type == obj_id.type &&
-					id.id == obj_id.id &&
-						id.enum_id == obj_id.enum_id)
-				return
-				&bp->object_info_tbl.v1_4->display_path[i];
+					bp->object_info_tbl.v1_4->display_path[i].display_objid);
+			if (id.type == obj_id.type && id.id == obj_id.id
+					&& id.enum_id == obj_id.enum_id)
+				return &bp->object_info_tbl.v1_4->display_path[i];
 		}
 	default:
 		return NULL;
@@ -489,99 +407,6 @@ static enum bp_result get_gpio_i2c_info(
 	return BP_RESULT_OK;
 }
 
-static enum bp_result get_voltage_ddc_info_v4(
-	uint8_t *i2c_line,
-	uint32_t index,
-	struct atom_common_table_header *header,
-	uint8_t *address)
-{
-	enum bp_result result = BP_RESULT_NORECORD;
-	struct atom_voltage_objects_info_v4_1 *info =
-		(struct atom_voltage_objects_info_v4_1 *) address;
-
-	uint8_t *voltage_current_object =
-		(uint8_t *) (&(info->voltage_object[0]));
-
-	while ((address + le16_to_cpu(header->structuresize)) >
-						voltage_current_object) {
-		struct atom_i2c_voltage_object_v4 *object =
-			(struct atom_i2c_voltage_object_v4 *)
-						voltage_current_object;
-
-		if (object->header.voltage_mode ==
-			ATOM_INIT_VOLTAGE_REGULATOR) {
-			if (object->header.voltage_type == index) {
-				*i2c_line = object->i2c_id ^ 0x90;
-				result = BP_RESULT_OK;
-				break;
-			}
-		}
-
-		voltage_current_object +=
-				le16_to_cpu(object->header.object_size);
-	}
-	return result;
-}
-
-static enum bp_result bios_parser_get_thermal_ddc_info(
-	struct dc_bios *dcb,
-	uint32_t i2c_channel_id,
-	struct graphics_object_i2c_info *info)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-	struct i2c_id_config_access *config;
-	struct atom_i2c_record record;
-
-	if (!info)
-		return BP_RESULT_BADINPUT;
-
-	config = (struct i2c_id_config_access *) &i2c_channel_id;
-
-	record.i2c_id = config->bfHW_Capable;
-	record.i2c_id |= config->bfI2C_LineMux;
-	record.i2c_id |= config->bfHW_EngineID;
-
-	return get_gpio_i2c_info(bp, &record, info);
-}
-
-static enum bp_result bios_parser_get_voltage_ddc_info(struct dc_bios *dcb,
-	uint32_t index,
-	struct graphics_object_i2c_info *info)
-{
-	uint8_t i2c_line = 0;
-	enum bp_result result = BP_RESULT_NORECORD;
-	uint8_t *voltage_info_address;
-	struct atom_common_table_header *header;
-	struct atom_data_revision revision = {0};
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!DATA_TABLES(voltageobject_info))
-		return result;
-
-	voltage_info_address = bios_get_image(&bp->base,
-			DATA_TABLES(voltageobject_info),
-			sizeof(struct atom_common_table_header));
-
-	header = (struct atom_common_table_header *) voltage_info_address;
-
-	get_atom_data_table_revision(header, &revision);
-
-	switch (revision.major) {
-	case 4:
-		if (revision.minor != 1)
-			break;
-		result = get_voltage_ddc_info_v4(&i2c_line, index, header,
-			voltage_info_address);
-		break;
-	}
-
-	if (result == BP_RESULT_OK)
-		result = bios_parser_get_thermal_ddc_info(dcb,
-			i2c_line, info);
-
-	return result;
-}
-
 static enum bp_result bios_parser_get_hpd_info(
 	struct dc_bios *dcb,
 	struct graphics_object_id id,
@@ -997,8 +822,8 @@ static enum bp_result bios_parser_get_spread_spectrum_info(
 }
 
 static enum bp_result get_embedded_panel_info_v2_1(
-	struct bios_parser *bp,
-	struct embedded_panel_info *info)
+		struct bios_parser *bp,
+		struct embedded_panel_info *info)
 {
 	struct lcd_info_v2_1 *lvds;
 
@@ -1021,92 +846,78 @@ static enum bp_result get_embedded_panel_info_v2_1(
 	memset(info, 0, sizeof(struct embedded_panel_info));
 
 	/* We need to convert from 10KHz units into KHz units */
-	info->lcd_timing.pixel_clk =
-			le16_to_cpu(lvds->lcd_timing.pixclk) * 10;
+	info->lcd_timing.pixel_clk = le16_to_cpu(lvds->lcd_timing.pixclk) * 10;
 	/* usHActive does not include borders, according to VBIOS team */
-	info->lcd_timing.horizontal_addressable =
-			le16_to_cpu(lvds->lcd_timing.h_active);
+	info->lcd_timing.horizontal_addressable = le16_to_cpu(lvds->lcd_timing.h_active);
 	/* usHBlanking_Time includes borders, so we should really be
 	 * subtractingborders duing this translation, but LVDS generally
 	 * doesn't have borders, so we should be okay leaving this as is for
 	 * now.  May need to revisit if we ever have LVDS with borders
 	 */
-	info->lcd_timing.horizontal_blanking_time =
-		le16_to_cpu(lvds->lcd_timing.h_blanking_time);
+	info->lcd_timing.horizontal_blanking_time = le16_to_cpu(lvds->lcd_timing.h_blanking_time);
 	/* usVActive does not include borders, according to VBIOS team*/
-	info->lcd_timing.vertical_addressable =
-		le16_to_cpu(lvds->lcd_timing.v_active);
+	info->lcd_timing.vertical_addressable = le16_to_cpu(lvds->lcd_timing.v_active);
 	/* usVBlanking_Time includes borders, so we should really be
 	 * subtracting borders duing this translation, but LVDS generally
 	 * doesn't have borders, so we should be okay leaving this as is for
 	 * now. May need to revisit if we ever have LVDS with borders
 	 */
-	info->lcd_timing.vertical_blanking_time =
-		le16_to_cpu(lvds->lcd_timing.v_blanking_time);
-	info->lcd_timing.horizontal_sync_offset =
-		le16_to_cpu(lvds->lcd_timing.h_sync_offset);
-	info->lcd_timing.horizontal_sync_width =
-		le16_to_cpu(lvds->lcd_timing.h_sync_width);
-	info->lcd_timing.vertical_sync_offset =
-		le16_to_cpu(lvds->lcd_timing.v_sync_offset);
-	info->lcd_timing.vertical_sync_width =
-		le16_to_cpu(lvds->lcd_timing.v_syncwidth);
+	info->lcd_timing.vertical_blanking_time = le16_to_cpu(lvds->lcd_timing.v_blanking_time);
+	info->lcd_timing.horizontal_sync_offset = le16_to_cpu(lvds->lcd_timing.h_sync_offset);
+	info->lcd_timing.horizontal_sync_width = le16_to_cpu(lvds->lcd_timing.h_sync_width);
+	info->lcd_timing.vertical_sync_offset = le16_to_cpu(lvds->lcd_timing.v_sync_offset);
+	info->lcd_timing.vertical_sync_width = le16_to_cpu(lvds->lcd_timing.v_syncwidth);
 	info->lcd_timing.horizontal_border = lvds->lcd_timing.h_border;
 	info->lcd_timing.vertical_border = lvds->lcd_timing.v_border;
 
 	/* not provided by VBIOS */
 	info->lcd_timing.misc_info.HORIZONTAL_CUT_OFF = 0;
 
-	info->lcd_timing.misc_info.H_SYNC_POLARITY =
-		~(uint32_t)
-		(lvds->lcd_timing.miscinfo & ATOM_HSYNC_POLARITY);
-	info->lcd_timing.misc_info.V_SYNC_POLARITY =
-		~(uint32_t)
-		(lvds->lcd_timing.miscinfo & ATOM_VSYNC_POLARITY);
+	info->lcd_timing.misc_info.H_SYNC_POLARITY = ~(uint32_t) (lvds->lcd_timing.miscinfo
+			& ATOM_HSYNC_POLARITY);
+	info->lcd_timing.misc_info.V_SYNC_POLARITY = ~(uint32_t) (lvds->lcd_timing.miscinfo
+			& ATOM_VSYNC_POLARITY);
 
 	/* not provided by VBIOS */
 	info->lcd_timing.misc_info.VERTICAL_CUT_OFF = 0;
 
-	info->lcd_timing.misc_info.H_REPLICATION_BY2 =
-		!!(lvds->lcd_timing.miscinfo & ATOM_H_REPLICATIONBY2);
-	info->lcd_timing.misc_info.V_REPLICATION_BY2 =
-		!!(lvds->lcd_timing.miscinfo & ATOM_V_REPLICATIONBY2);
-	info->lcd_timing.misc_info.COMPOSITE_SYNC =
-		!!(lvds->lcd_timing.miscinfo & ATOM_COMPOSITESYNC);
-	info->lcd_timing.misc_info.INTERLACE =
-		!!(lvds->lcd_timing.miscinfo & ATOM_INTERLACE);
+	info->lcd_timing.misc_info.H_REPLICATION_BY2 = !!(lvds->lcd_timing.miscinfo
+			& ATOM_H_REPLICATIONBY2);
+	info->lcd_timing.misc_info.V_REPLICATION_BY2 = !!(lvds->lcd_timing.miscinfo
+			& ATOM_V_REPLICATIONBY2);
+	info->lcd_timing.misc_info.COMPOSITE_SYNC = !!(lvds->lcd_timing.miscinfo
+			& ATOM_COMPOSITESYNC);
+	info->lcd_timing.misc_info.INTERLACE = !!(lvds->lcd_timing.miscinfo & ATOM_INTERLACE);
 
 	/* not provided by VBIOS*/
 	info->lcd_timing.misc_info.DOUBLE_CLOCK = 0;
 	/* not provided by VBIOS*/
 	info->ss_id = 0;
 
-	info->realtek_eDPToLVDS =
-			!!(lvds->dplvdsrxid == eDP_TO_LVDS_REALTEK_ID);
+	info->realtek_eDPToLVDS = !!(lvds->dplvdsrxid == eDP_TO_LVDS_REALTEK_ID);
 
 	return BP_RESULT_OK;
 }
 
 static enum bp_result bios_parser_get_embedded_panel_info(
-	struct dc_bios *dcb,
-	struct embedded_panel_info *info)
+		struct dc_bios *dcb,
+		struct embedded_panel_info *info)
 {
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
+	struct bios_parser
+	*bp = BP_FROM_DCB(dcb);
 	struct atom_common_table_header *header;
 	struct atom_data_revision tbl_revision;
 
 	if (!DATA_TABLES(lcd_info))
 		return BP_RESULT_FAILURE;
 
-	header = GET_IMAGE(struct atom_common_table_header,
-					DATA_TABLES(lcd_info));
+	header = GET_IMAGE(struct atom_common_table_header, DATA_TABLES(lcd_info));
 
 	if (!header)
 		return BP_RESULT_BADBIOSTABLE;
 
 	get_atom_data_table_revision(header, &tbl_revision);
 
-
 	switch (tbl_revision.major) {
 	case 2:
 		switch (tbl_revision.minor) {
@@ -1174,12 +985,6 @@ static bool bios_parser_is_device_id_supported(
 								mask) != 0;
 }
 
-static void bios_parser_post_init(
-	struct dc_bios *dcb)
-{
-	/* TODO for OPM module. Need implement later */
-}
-
 static uint32_t bios_parser_get_ss_entry_number(
 	struct dc_bios *dcb,
 	enum as_signal_type signal)
@@ -1238,17 +1043,6 @@ static enum bp_result bios_parser_set_dce_clock(
 	return bp->cmd_tbl.set_dce_clock(bp, bp_params);
 }
 
-static unsigned int bios_parser_get_smu_clock_info(
-	struct dc_bios *dcb)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!bp->cmd_tbl.get_smu_clock_info)
-		return BP_RESULT_FAILURE;
-
-	return bp->cmd_tbl.get_smu_clock_info(bp, 0);
-}
-
 static enum bp_result bios_parser_program_crtc_timing(
 	struct dc_bios *dcb,
 	struct bp_hw_crtc_timing_parameters *bp_params)
@@ -1306,13 +1100,6 @@ static bool bios_parser_is_accelerated_mode(
 	return bios_is_accelerated_mode(dcb);
 }
 
-static uint32_t bios_parser_get_vga_enabled_displays(
-	struct dc_bios *bios)
-{
-	return bios_get_vga_enabled_displays(bios);
-}
-
-
 /**
  * bios_parser_set_scratch_critical_state
  *
@@ -2071,22 +1858,12 @@ static enum bp_result bios_get_board_layout_info(
 static const struct dc_vbios_funcs vbios_funcs = {
 	.get_connectors_number = bios_parser_get_connectors_number,
 
-	.get_encoder_id = bios_parser_get_encoder_id,
-
 	.get_connector_id = bios_parser_get_connector_id,
 
-	.get_dst_number = bios_parser_get_dst_number,
-
 	.get_src_obj = bios_parser_get_src_obj,
 
-	.get_dst_obj = bios_parser_get_dst_obj,
-
 	.get_i2c_info = bios_parser_get_i2c_info,
 
-	.get_voltage_ddc_info = bios_parser_get_voltage_ddc_info,
-
-	.get_thermal_ddc_info = bios_parser_get_thermal_ddc_info,
-
 	.get_hpd_info = bios_parser_get_hpd_info,
 
 	.get_device_tag = bios_parser_get_device_tag,
@@ -2105,10 +1882,7 @@ static const struct dc_vbios_funcs vbios_funcs = {
 
 	.is_device_id_supported = bios_parser_is_device_id_supported,
 
-
-
 	.is_accelerated_mode = bios_parser_is_accelerated_mode,
-	.get_vga_enabled_displays = bios_parser_get_vga_enabled_displays,
 
 	.set_scratch_critical_state = bios_parser_set_scratch_critical_state,
 
@@ -2126,20 +1900,12 @@ static const struct dc_vbios_funcs vbios_funcs = {
 
 	.program_crtc_timing = bios_parser_program_crtc_timing,
 
-	/* .blank_crtc = bios_parser_blank_crtc, */
-
 	.crtc_source_select = bios_parser_crtc_source_select,
 
-	/* .external_encoder_control = bios_parser_external_encoder_control, */
-
 	.enable_disp_power_gating = bios_parser_enable_disp_power_gating,
 
-	.post_init = bios_parser_post_init,
-
 	.bios_parser_destroy = firmware_parser_destroy,
 
-	.get_smu_clock_info = bios_parser_get_smu_clock_info,
-
 	.get_board_layout_info = bios_get_board_layout_info,
 };
 
diff --git a/drivers/gpu/drm/amd/display/dc/dc_bios_types.h b/drivers/gpu/drm/amd/display/dc/dc_bios_types.h
index 90082bab71f0..8130b95ccc53 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_bios_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_bios_types.h
@@ -41,38 +41,17 @@
 struct dc_vbios_funcs {
 	uint8_t (*get_connectors_number)(struct dc_bios *bios);
 
-	struct graphics_object_id (*get_encoder_id)(
-		struct dc_bios *bios,
-		uint32_t i);
 	struct graphics_object_id (*get_connector_id)(
 		struct dc_bios *bios,
 		uint8_t connector_index);
-	uint32_t (*get_dst_number)(
-		struct dc_bios *bios,
-		struct graphics_object_id id);
-
 	enum bp_result (*get_src_obj)(
 		struct dc_bios *bios,
 		struct graphics_object_id object_id, uint32_t index,
 		struct graphics_object_id *src_object_id);
-	enum bp_result (*get_dst_obj)(
-		struct dc_bios *bios,
-		struct graphics_object_id object_id, uint32_t index,
-		struct graphics_object_id *dest_object_id);
-
 	enum bp_result (*get_i2c_info)(
 		struct dc_bios *dcb,
 		struct graphics_object_id id,
 		struct graphics_object_i2c_info *info);
-
-	enum bp_result (*get_voltage_ddc_info)(
-		struct dc_bios *bios,
-		uint32_t index,
-		struct graphics_object_i2c_info *info);
-	enum bp_result (*get_thermal_ddc_info)(
-		struct dc_bios *bios,
-		uint32_t i2c_channel_id,
-		struct graphics_object_i2c_info *info);
 	enum bp_result (*get_hpd_info)(
 		struct dc_bios *bios,
 		struct graphics_object_id id,
@@ -105,35 +84,8 @@ struct dc_vbios_funcs {
 		struct graphics_object_id object_id,
 		struct bp_encoder_cap_info *info);
 
-	bool (*is_lid_status_changed)(
-		struct dc_bios *bios);
-	bool (*is_display_config_changed)(
-		struct dc_bios *bios);
 	bool (*is_accelerated_mode)(
 		struct dc_bios *bios);
-	uint32_t (*get_vga_enabled_displays)(
-		struct dc_bios *bios);
-	void (*get_bios_event_info)(
-		struct dc_bios *bios,
-		struct bios_event_info *info);
-	void (*update_requested_backlight_level)(
-		struct dc_bios *bios,
-		uint32_t backlight_8bit);
-	uint32_t (*get_requested_backlight_level)(
-		struct dc_bios *bios);
-	void (*take_backlight_control)(
-		struct dc_bios *bios,
-		bool cntl);
-
-	bool (*is_active_display)(
-		struct dc_bios *bios,
-		enum signal_type signal,
-		const struct connector_device_tag_info *device_tag);
-	enum controller_id (*get_embedded_display_controller_id)(
-		struct dc_bios *bios);
-	uint32_t (*get_embedded_display_refresh_rate)(
-		struct dc_bios *bios);
-
 	void (*set_scratch_critical_state)(
 		struct dc_bios *bios,
 		bool state);
@@ -149,11 +101,6 @@ struct dc_vbios_funcs {
 	enum bp_result (*transmitter_control)(
 		struct dc_bios *bios,
 		struct bp_transmitter_control *cntl);
-	enum bp_result (*crt_control)(
-		struct dc_bios *bios,
-		enum engine_id engine_id,
-		bool enable,
-		uint32_t pixel_clock);
 	enum bp_result (*enable_crtc)(
 		struct dc_bios *bios,
 		enum controller_id id,
@@ -167,8 +114,6 @@ struct dc_vbios_funcs {
 	enum bp_result (*set_dce_clock)(
 		struct dc_bios *bios,
 		struct bp_set_dce_clock_parameters *bp_params);
-	unsigned int (*get_smu_clock_info)(
-		struct dc_bios *bios);
 	enum bp_result (*enable_spread_spectrum_on_ppll)(
 		struct dc_bios *bios,
 		struct bp_spread_spectrum_parameters *bp_params,
@@ -183,20 +128,11 @@ struct dc_vbios_funcs {
 	enum bp_result (*program_display_engine_pll)(
 		struct dc_bios *bios,
 		struct bp_pixel_clock_parameters *bp_params);
-
-	enum signal_type (*dac_load_detect)(
-		struct dc_bios *bios,
-		struct graphics_object_id encoder,
-		struct graphics_object_id connector,
-		enum signal_type display_signal);
-
 	enum bp_result (*enable_disp_power_gating)(
 		struct dc_bios *bios,
 		enum controller_id controller_id,
 		enum bp_pipe_control_action action);
 
-	void (*post_init)(struct dc_bios *bios);
-
 	void (*bios_parser_destroy)(struct dc_bios **dcb);
 
 	enum bp_result (*get_board_layout_info)(
-- 
2.17.1

