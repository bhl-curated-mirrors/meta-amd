From 40ddd444b3736d757647ae7cfbc36924147c3ed6 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Fri, 28 Sep 2018 07:46:42 -0400
Subject: [PATCH 0548/2940] drm/amd/display: rename dccg to clk_mgr

In preparation for adding the actual dccg block since the
current implementation of dccg is mor eof a clock manager
than a hw block

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
---
 .../gpu/drm/amd/display/dc/core/dc_resource.c |   2 +-
 drivers/gpu/drm/amd/display/dc/dce/Makefile   |   2 +-
 .../dc/dce/{dce_dccg.c => dce_clk_mgr.c}      | 350 +++++++++---------
 .../dc/dce/{dce_dccg.h => dce_clk_mgr.h}      |  58 +--
 .../display/dc/dce100/dce100_hw_sequencer.c   |   4 +-
 .../amd/display/dc/dce100/dce100_resource.c   |  16 +-
 .../display/dc/dce110/dce110_hw_sequencer.c   |   4 +-
 .../amd/display/dc/dce110/dce110_resource.c   |  16 +-
 .../amd/display/dc/dce112/dce112_resource.c   |  16 +-
 .../amd/display/dc/dce120/dce120_resource.c   |  10 +-
 .../drm/amd/display/dc/dce80/dce80_resource.c |  24 +-
 drivers/gpu/drm/amd/display/dc/dcn10/Makefile |   2 +-
 .../dcn10/{dcn10_dccg.c => dcn10_clk_mgr.c}   | 131 ++++---
 .../dcn10/{dcn10_dccg.h => dcn10_clk_mgr.h}   |  10 +-
 .../amd/display/dc/dcn10/dcn10_hw_sequencer.c |  18 +-
 .../drm/amd/display/dc/dcn10/dcn10_resource.c |  28 +-
 .../gpu/drm/amd/display/dc/inc/core_types.h   |   6 +-
 .../gpu/drm/amd/display/dc/inc/dcn_calcs.h    |   2 +-
 .../display/dc/inc/hw/{dccg.h => clk_mgr.h}   |  16 +-
 19 files changed, 357 insertions(+), 358 deletions(-)
 rename drivers/gpu/drm/amd/display/dc/dce/{dce_dccg.c => dce_clk_mgr.c} (68%)
 rename drivers/gpu/drm/amd/display/dc/dce/{dce_dccg.h => dce_clk_mgr.h} (78%)
 rename drivers/gpu/drm/amd/display/dc/dcn10/{dcn10_dccg.c => dcn10_clk_mgr.c} (69%)
 rename drivers/gpu/drm/amd/display/dc/dcn10/{dcn10_dccg.h => dcn10_clk_mgr.h} (87%)
 rename drivers/gpu/drm/amd/display/dc/inc/hw/{dccg.h => clk_mgr.h} (83%)

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index cd1aa9dc6287..40d6f099615b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2071,7 +2071,7 @@ void dc_resource_state_construct(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)
 {
-	dst_ctx->dccg = dc->res_pool->dccg;
+	dst_ctx->dccg = dc->res_pool->clk_mgr;
 }
 
 enum dc_status dc_validate_global_state(
diff --git a/drivers/gpu/drm/amd/display/dc/dce/Makefile b/drivers/gpu/drm/amd/display/dc/dce/Makefile
index f4ce7f502094..6d7b64a743ca 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dce/Makefile
@@ -28,7 +28,7 @@
 
 DCE = dce_audio.o dce_stream_encoder.o dce_link_encoder.o dce_hwseq.o \
 dce_mem_input.o dce_clock_source.o dce_scl_filters.o dce_transform.o \
-dce_dccg.o dce_opp.o dce_dmcu.o dce_abm.o dce_ipp.o dce_aux.o \
+dce_clk_mgr.o dce_opp.o dce_dmcu.o dce_abm.o dce_ipp.o dce_aux.o \
 dce_i2c.o dce_i2c_hw.o dce_i2c_sw.o
 
 AMD_DAL_DCE = $(addprefix $(AMDDALPATH)/dc/dce/,$(DCE))
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_dccg.c b/drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c
similarity index 68%
rename from drivers/gpu/drm/amd/display/dc/dce/dce_dccg.c
rename to drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c
index 97c143b90edf..02ddc94a9930 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_dccg.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c
@@ -23,27 +23,27 @@
  *
  */
 
-#include "dce_dccg.h"
+#include "dce_clk_mgr.h"
 
 #include "reg_helper.h"
 #include "dmcu.h"
 #include "core_types.h"
 #include "dal_asic_id.h"
 
-#define TO_DCE_DCCG(clocks)\
-	container_of(clocks, struct dce_dccg, base)
+#define TO_DCE_CLK_MGR(clocks)\
+	container_of(clocks, struct dce_clk_mgr, base)
 
 #define REG(reg) \
-	(dccg_dce->regs->reg)
+	(clk_mgr_dce->regs->reg)
 
 #undef FN
 #define FN(reg_name, field_name) \
-	dccg_dce->dccg_shift->field_name, dccg_dce->dccg_mask->field_name
+	clk_mgr_dce->clk_mgr_shift->field_name, clk_mgr_dce->clk_mgr_mask->field_name
 
 #define CTX \
-	dccg_dce->base.ctx
+	clk_mgr_dce->base.ctx
 #define DC_LOGGER \
-	dccg->ctx->logger
+	clk_mgr->ctx->logger
 
 /* Max clock values for each state indexed by "enum clocks_state": */
 static const struct state_dependent_clocks dce80_max_clks_by_state[] = {
@@ -125,12 +125,12 @@ static int dentist_get_divider_from_did(int did)
  (should not be case with CIK) then SW should program all rates
  generated according to average value (case as with previous ASICs)
   */
-static int dccg_adjust_dp_ref_freq_for_ss(struct dce_dccg *dccg_dce, int dp_ref_clk_khz)
+static int clk_mgr_adjust_dp_ref_freq_for_ss(struct dce_clk_mgr *clk_mgr_dce, int dp_ref_clk_khz)
 {
-	if (dccg_dce->ss_on_dprefclk && dccg_dce->dprefclk_ss_divider != 0) {
+	if (clk_mgr_dce->ss_on_dprefclk && clk_mgr_dce->dprefclk_ss_divider != 0) {
 		struct fixed31_32 ss_percentage = dc_fixpt_div_int(
-				dc_fixpt_from_fraction(dccg_dce->dprefclk_ss_percentage,
-							dccg_dce->dprefclk_ss_divider), 200);
+				dc_fixpt_from_fraction(clk_mgr_dce->dprefclk_ss_percentage,
+							clk_mgr_dce->dprefclk_ss_divider), 200);
 		struct fixed31_32 adj_dp_ref_clk_khz;
 
 		ss_percentage = dc_fixpt_sub(dc_fixpt_one, ss_percentage);
@@ -140,9 +140,9 @@ static int dccg_adjust_dp_ref_freq_for_ss(struct dce_dccg *dccg_dce, int dp_ref_
 	return dp_ref_clk_khz;
 }
 
-static int dce_get_dp_ref_freq_khz(struct dccg *dccg)
+static int dce_get_dp_ref_freq_khz(struct clk_mgr *clk_mgr)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 	int dprefclk_wdivider;
 	int dprefclk_src_sel;
 	int dp_ref_clk_khz = 600000;
@@ -161,16 +161,16 @@ static int dce_get_dp_ref_freq_khz(struct dccg *dccg)
 
 	/* Calculate the current DFS clock, in kHz.*/
 	dp_ref_clk_khz = (DENTIST_DIVIDER_RANGE_SCALE_FACTOR
-		* dccg_dce->dentist_vco_freq_khz) / target_div;
+		* clk_mgr_dce->dentist_vco_freq_khz) / target_div;
 
-	return dccg_adjust_dp_ref_freq_for_ss(dccg_dce, dp_ref_clk_khz);
+	return clk_mgr_adjust_dp_ref_freq_for_ss(clk_mgr_dce, dp_ref_clk_khz);
 }
 
-int dce12_get_dp_ref_freq_khz(struct dccg *dccg)
+int dce12_get_dp_ref_freq_khz(struct clk_mgr *clk_mgr)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 
-	return dccg_adjust_dp_ref_freq_for_ss(dccg_dce, dccg_dce->dprefclk_khz);
+	return clk_mgr_adjust_dp_ref_freq_for_ss(clk_mgr_dce, clk_mgr_dce->dprefclk_khz);
 }
 
 /* unit: in_khz before mode set, get pixel clock from context. ASIC register
@@ -206,10 +206,10 @@ static uint32_t get_max_pixel_clock_for_all_paths(struct dc_state *context)
 }
 
 static enum dm_pp_clocks_state dce_get_required_clocks_state(
-	struct dccg *dccg,
+	struct clk_mgr *clk_mgr,
 	struct dc_state *context)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 	int i;
 	enum dm_pp_clocks_state low_req_clk;
 	int max_pix_clk = get_max_pixel_clock_for_all_paths(context);
@@ -218,53 +218,53 @@ static enum dm_pp_clocks_state dce_get_required_clocks_state(
 	 * lowest RequiredState with the lowest state that satisfies
 	 * all required clocks
 	 */
-	for (i = dccg_dce->max_clks_state; i >= DM_PP_CLOCKS_STATE_ULTRA_LOW; i--)
+	for (i = clk_mgr_dce->max_clks_state; i >= DM_PP_CLOCKS_STATE_ULTRA_LOW; i--)
 		if (context->bw.dce.dispclk_khz >
-				dccg_dce->max_clks_by_state[i].display_clk_khz
+				clk_mgr_dce->max_clks_by_state[i].display_clk_khz
 			|| max_pix_clk >
-				dccg_dce->max_clks_by_state[i].pixel_clk_khz)
+				clk_mgr_dce->max_clks_by_state[i].pixel_clk_khz)
 			break;
 
 	low_req_clk = i + 1;
-	if (low_req_clk > dccg_dce->max_clks_state) {
+	if (low_req_clk > clk_mgr_dce->max_clks_state) {
 		/* set max clock state for high phyclock, invalid on exceeding display clock */
-		if (dccg_dce->max_clks_by_state[dccg_dce->max_clks_state].display_clk_khz
+		if (clk_mgr_dce->max_clks_by_state[clk_mgr_dce->max_clks_state].display_clk_khz
 				< context->bw.dce.dispclk_khz)
 			low_req_clk = DM_PP_CLOCKS_STATE_INVALID;
 		else
-			low_req_clk = dccg_dce->max_clks_state;
+			low_req_clk = clk_mgr_dce->max_clks_state;
 	}
 
 	return low_req_clk;
 }
 
 static int dce_set_clock(
-	struct dccg *dccg,
+	struct clk_mgr *clk_mgr,
 	int requested_clk_khz)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 	struct bp_pixel_clock_parameters pxl_clk_params = { 0 };
-	struct dc_bios *bp = dccg->ctx->dc_bios;
+	struct dc_bios *bp = clk_mgr->ctx->dc_bios;
 	int actual_clock = requested_clk_khz;
-	struct dmcu *dmcu = dccg_dce->base.ctx->dc->res_pool->dmcu;
+	struct dmcu *dmcu = clk_mgr_dce->base.ctx->dc->res_pool->dmcu;
 
 	/* Make sure requested clock isn't lower than minimum threshold*/
 	if (requested_clk_khz > 0)
 		requested_clk_khz = max(requested_clk_khz,
-				dccg_dce->dentist_vco_freq_khz / 64);
+				clk_mgr_dce->dentist_vco_freq_khz / 64);
 
 	/* Prepare to program display clock*/
 	pxl_clk_params.target_pixel_clock = requested_clk_khz;
 	pxl_clk_params.pll_id = CLOCK_SOURCE_ID_DFS;
 
-	if (dccg_dce->dfs_bypass_active)
+	if (clk_mgr_dce->dfs_bypass_active)
 		pxl_clk_params.flags.SET_DISPCLK_DFS_BYPASS = true;
 
 	bp->funcs->program_display_engine_pll(bp, &pxl_clk_params);
 
-	if (dccg_dce->dfs_bypass_active) {
+	if (clk_mgr_dce->dfs_bypass_active) {
 		/* Cache the fixed display clock*/
-		dccg_dce->dfs_bypass_disp_clk =
+		clk_mgr_dce->dfs_bypass_disp_clk =
 			pxl_clk_params.dfs_bypass_display_clock;
 		actual_clock = pxl_clk_params.dfs_bypass_display_clock;
 	}
@@ -272,19 +272,19 @@ static int dce_set_clock(
 	/* from power down, we need mark the clock state as ClocksStateNominal
 	 * from HWReset, so when resume we will call pplib voltage regulator.*/
 	if (requested_clk_khz == 0)
-		dccg_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;
+		clk_mgr_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;
 
 	dmcu->funcs->set_psr_wait_loop(dmcu, actual_clock / 1000 / 7);
 
 	return actual_clock;
 }
 
-int dce112_set_clock(struct dccg *dccg, int requested_clk_khz)
+int dce112_set_clock(struct clk_mgr *clk_mgr, int requested_clk_khz)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 	struct bp_set_dce_clock_parameters dce_clk_params;
-	struct dc_bios *bp = dccg->ctx->dc_bios;
-	struct dc *core_dc = dccg->ctx->dc;
+	struct dc_bios *bp = clk_mgr->ctx->dc_bios;
+	struct dc *core_dc = clk_mgr->ctx->dc;
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
 	int actual_clock = requested_clk_khz;
 	/* Prepare to program display clock*/
@@ -293,7 +293,7 @@ int dce112_set_clock(struct dccg *dccg, int requested_clk_khz)
 	/* Make sure requested clock isn't lower than minimum threshold*/
 	if (requested_clk_khz > 0)
 		requested_clk_khz = max(requested_clk_khz,
-				dccg_dce->dentist_vco_freq_khz / 62);
+				clk_mgr_dce->dentist_vco_freq_khz / 62);
 
 	dce_clk_params.target_clock_frequency = requested_clk_khz;
 	dce_clk_params.pll_id = CLOCK_SOURCE_ID_DFS;
@@ -305,13 +305,13 @@ int dce112_set_clock(struct dccg *dccg, int requested_clk_khz)
 	/* from power down, we need mark the clock state as ClocksStateNominal
 	 * from HWReset, so when resume we will call pplib voltage regulator.*/
 	if (requested_clk_khz == 0)
-		dccg_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;
+		clk_mgr_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;
 
 	/*Program DP ref Clock*/
 	/*VBIOS will determine DPREFCLK frequency, so we don't set it*/
 	dce_clk_params.target_clock_frequency = 0;
 	dce_clk_params.clock_type = DCECLOCK_TYPE_DPREFCLK;
-	if (!ASICREV_IS_VEGA20_P(dccg->ctx->asic_id.hw_internal_rev))
+	if (!ASICREV_IS_VEGA20_P(clk_mgr->ctx->asic_id.hw_internal_rev))
 		dce_clk_params.flags.USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK =
 			(dce_clk_params.pll_id ==
 					CLOCK_SOURCE_COMBO_DISPLAY_PLL0);
@@ -321,19 +321,19 @@ int dce112_set_clock(struct dccg *dccg, int requested_clk_khz)
 	bp->funcs->set_dce_clock(bp, &dce_clk_params);
 
 	if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
-		if (dccg_dce->dfs_bypass_disp_clk != actual_clock)
+		if (clk_mgr_dce->dfs_bypass_disp_clk != actual_clock)
 			dmcu->funcs->set_psr_wait_loop(dmcu,
 					actual_clock / 1000 / 7);
 	}
 
-	dccg_dce->dfs_bypass_disp_clk = actual_clock;
+	clk_mgr_dce->dfs_bypass_disp_clk = actual_clock;
 	return actual_clock;
 }
 
-static void dce_clock_read_integrated_info(struct dce_dccg *dccg_dce)
+static void dce_clock_read_integrated_info(struct dce_clk_mgr *clk_mgr_dce)
 {
-	struct dc_debug_options *debug = &dccg_dce->base.ctx->dc->debug;
-	struct dc_bios *bp = dccg_dce->base.ctx->dc_bios;
+	struct dc_debug_options *debug = &clk_mgr_dce->base.ctx->dc->debug;
+	struct dc_bios *bp = clk_mgr_dce->base.ctx->dc_bios;
 	struct integrated_info info = { { { 0 } } };
 	struct dc_firmware_info fw_info = { { 0 } };
 	int i;
@@ -341,13 +341,13 @@ static void dce_clock_read_integrated_info(struct dce_dccg *dccg_dce)
 	if (bp->integrated_info)
 		info = *bp->integrated_info;
 
-	dccg_dce->dentist_vco_freq_khz = info.dentist_vco_freq;
-	if (dccg_dce->dentist_vco_freq_khz == 0) {
+	clk_mgr_dce->dentist_vco_freq_khz = info.dentist_vco_freq;
+	if (clk_mgr_dce->dentist_vco_freq_khz == 0) {
 		bp->funcs->get_firmware_info(bp, &fw_info);
-		dccg_dce->dentist_vco_freq_khz =
+		clk_mgr_dce->dentist_vco_freq_khz =
 			fw_info.smu_gpu_pll_output_freq;
-		if (dccg_dce->dentist_vco_freq_khz == 0)
-			dccg_dce->dentist_vco_freq_khz = 3600000;
+		if (clk_mgr_dce->dentist_vco_freq_khz == 0)
+			clk_mgr_dce->dentist_vco_freq_khz = 3600000;
 	}
 
 	/*update the maximum display clock for each power state*/
@@ -379,18 +379,18 @@ static void dce_clock_read_integrated_info(struct dce_dccg *dccg_dce)
 		/*Do not allow bad VBIOS/SBIOS to override with invalid values,
 		 * check for > 100MHz*/
 		if (info.disp_clk_voltage[i].max_supported_clk >= 100000)
-			dccg_dce->max_clks_by_state[clk_state].display_clk_khz =
+			clk_mgr_dce->max_clks_by_state[clk_state].display_clk_khz =
 				info.disp_clk_voltage[i].max_supported_clk;
 	}
 
 	if (!debug->disable_dfs_bypass && bp->integrated_info)
 		if (bp->integrated_info->gpu_cap_info & DFS_BYPASS_ENABLE)
-			dccg_dce->dfs_bypass_enabled = true;
+			clk_mgr_dce->dfs_bypass_enabled = true;
 }
 
-void dce_clock_read_ss_info(struct dce_dccg *dccg_dce)
+void dce_clock_read_ss_info(struct dce_clk_mgr *clk_mgr_dce)
 {
-	struct dc_bios *bp = dccg_dce->base.ctx->dc_bios;
+	struct dc_bios *bp = clk_mgr_dce->base.ctx->dc_bios;
 	int ss_info_num = bp->funcs->get_ss_entry_number(
 			bp, AS_SIGNAL_TYPE_GPU_PLL);
 
@@ -406,14 +406,14 @@ void dce_clock_read_ss_info(struct dce_dccg *dccg_dce)
 		 */
 		if (result == BP_RESULT_OK &&
 				info.spread_spectrum_percentage != 0) {
-			dccg_dce->ss_on_dprefclk = true;
-			dccg_dce->dprefclk_ss_divider = info.spread_percentage_divider;
+			clk_mgr_dce->ss_on_dprefclk = true;
+			clk_mgr_dce->dprefclk_ss_divider = info.spread_percentage_divider;
 
 			if (info.type.CENTER_MODE == 0) {
 				/* TODO: Currently for DP Reference clock we
 				 * need only SS percentage for
 				 * downspread */
-				dccg_dce->dprefclk_ss_percentage =
+				clk_mgr_dce->dprefclk_ss_percentage =
 						info.spread_spectrum_percentage;
 			}
 
@@ -430,14 +430,14 @@ void dce_clock_read_ss_info(struct dce_dccg *dccg_dce)
 		 */
 		if (result == BP_RESULT_OK &&
 				info.spread_spectrum_percentage != 0) {
-			dccg_dce->ss_on_dprefclk = true;
-			dccg_dce->dprefclk_ss_divider = info.spread_percentage_divider;
+			clk_mgr_dce->ss_on_dprefclk = true;
+			clk_mgr_dce->dprefclk_ss_divider = info.spread_percentage_divider;
 
 			if (info.type.CENTER_MODE == 0) {
 				/* Currently for DP Reference clock we
 				 * need only SS percentage for
 				 * downspread */
-				dccg_dce->dprefclk_ss_percentage =
+				clk_mgr_dce->dprefclk_ss_percentage =
 						info.spread_spectrum_percentage;
 			}
 		}
@@ -593,7 +593,7 @@ static void dce11_pplib_apply_display_requirements(
 	/* TODO: dce11.2*/
 	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
 
-	pp_display_cfg->disp_clk_khz = dc->res_pool->dccg->clks.dispclk_khz;
+	pp_display_cfg->disp_clk_khz = dc->res_pool->clk_mgr->clks.dispclk_khz;
 
 	dce110_fill_display_configs(context, pp_display_cfg);
 
@@ -611,266 +611,266 @@ static void dce11_pplib_apply_display_requirements(
 		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
 }
 
-static void dce_update_clocks(struct dccg *dccg,
+static void dce_update_clocks(struct clk_mgr *clk_mgr,
 			struct dc_state *context,
 			bool safe_to_lower)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 	struct dm_pp_power_level_change_request level_change_req;
 	int unpatched_disp_clk = context->bw.dce.dispclk_khz;
 
 	/*TODO: W/A for dal3 linux, investigate why this works */
-	if (!dccg_dce->dfs_bypass_active)
+	if (!clk_mgr_dce->dfs_bypass_active)
 		context->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz * 115 / 100;
 
-	level_change_req.power_level = dce_get_required_clocks_state(dccg, context);
+	level_change_req.power_level = dce_get_required_clocks_state(clk_mgr, context);
 	/* get max clock state from PPLIB */
-	if ((level_change_req.power_level < dccg_dce->cur_min_clks_state && safe_to_lower)
-			|| level_change_req.power_level > dccg_dce->cur_min_clks_state) {
-		if (dm_pp_apply_power_level_change_request(dccg->ctx, &level_change_req))
-			dccg_dce->cur_min_clks_state = level_change_req.power_level;
+	if ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)
+			|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {
+		if (dm_pp_apply_power_level_change_request(clk_mgr->ctx, &level_change_req))
+			clk_mgr_dce->cur_min_clks_state = level_change_req.power_level;
 	}
 
-	if (should_set_clock(safe_to_lower, context->bw.dce.dispclk_khz, dccg->clks.dispclk_khz)) {
-		context->bw.dce.dispclk_khz = dce_set_clock(dccg, context->bw.dce.dispclk_khz);
-		dccg->clks.dispclk_khz = context->bw.dce.dispclk_khz; 
+	if (should_set_clock(safe_to_lower, context->bw.dce.dispclk_khz, clk_mgr->clks.dispclk_khz)) {
+		context->bw.dce.dispclk_khz = dce_set_clock(clk_mgr, context->bw.dce.dispclk_khz);
+		clk_mgr->clks.dispclk_khz = context->bw.dce.dispclk_khz; 
 	}
-	dce_pplib_apply_display_requirements(dccg->ctx->dc, context);
+	dce_pplib_apply_display_requirements(clk_mgr->ctx->dc, context);
 
 	context->bw.dce.dispclk_khz = unpatched_disp_clk;
 }
 
-static void dce11_update_clocks(struct dccg *dccg,
+static void dce11_update_clocks(struct clk_mgr *clk_mgr,
 			struct dc_state *context,
 			bool safe_to_lower)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 	struct dm_pp_power_level_change_request level_change_req;
 
-	level_change_req.power_level = dce_get_required_clocks_state(dccg, context);
+	level_change_req.power_level = dce_get_required_clocks_state(clk_mgr, context);
 	/* get max clock state from PPLIB */
-	if ((level_change_req.power_level < dccg_dce->cur_min_clks_state && safe_to_lower)
-			|| level_change_req.power_level > dccg_dce->cur_min_clks_state) {
-		if (dm_pp_apply_power_level_change_request(dccg->ctx, &level_change_req))
-			dccg_dce->cur_min_clks_state = level_change_req.power_level;
+	if ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)
+			|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {
+		if (dm_pp_apply_power_level_change_request(clk_mgr->ctx, &level_change_req))
+			clk_mgr_dce->cur_min_clks_state = level_change_req.power_level;
 	}
 
-	if (should_set_clock(safe_to_lower, context->bw.dce.dispclk_khz, dccg->clks.dispclk_khz)) {
-		context->bw.dce.dispclk_khz = dce_set_clock(dccg, context->bw.dce.dispclk_khz);
-		dccg->clks.dispclk_khz = context->bw.dce.dispclk_khz;
+	if (should_set_clock(safe_to_lower, context->bw.dce.dispclk_khz, clk_mgr->clks.dispclk_khz)) {
+		context->bw.dce.dispclk_khz = dce_set_clock(clk_mgr, context->bw.dce.dispclk_khz);
+		clk_mgr->clks.dispclk_khz = context->bw.dce.dispclk_khz;
 	}
-	dce11_pplib_apply_display_requirements(dccg->ctx->dc, context);
+	dce11_pplib_apply_display_requirements(clk_mgr->ctx->dc, context);
 }
 
-static void dce112_update_clocks(struct dccg *dccg,
+static void dce112_update_clocks(struct clk_mgr *clk_mgr,
 			struct dc_state *context,
 			bool safe_to_lower)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 	struct dm_pp_power_level_change_request level_change_req;
 
-	level_change_req.power_level = dce_get_required_clocks_state(dccg, context);
+	level_change_req.power_level = dce_get_required_clocks_state(clk_mgr, context);
 	/* get max clock state from PPLIB */
-	if ((level_change_req.power_level < dccg_dce->cur_min_clks_state && safe_to_lower)
-			|| level_change_req.power_level > dccg_dce->cur_min_clks_state) {
-		if (dm_pp_apply_power_level_change_request(dccg->ctx, &level_change_req))
-			dccg_dce->cur_min_clks_state = level_change_req.power_level;
+	if ((level_change_req.power_level < clk_mgr_dce->cur_min_clks_state && safe_to_lower)
+			|| level_change_req.power_level > clk_mgr_dce->cur_min_clks_state) {
+		if (dm_pp_apply_power_level_change_request(clk_mgr->ctx, &level_change_req))
+			clk_mgr_dce->cur_min_clks_state = level_change_req.power_level;
 	}
 
-	if (should_set_clock(safe_to_lower, context->bw.dce.dispclk_khz, dccg->clks.dispclk_khz)) {
-		context->bw.dce.dispclk_khz = dce112_set_clock(dccg, context->bw.dce.dispclk_khz);
-		dccg->clks.dispclk_khz = context->bw.dce.dispclk_khz;
+	if (should_set_clock(safe_to_lower, context->bw.dce.dispclk_khz, clk_mgr->clks.dispclk_khz)) {
+		context->bw.dce.dispclk_khz = dce112_set_clock(clk_mgr, context->bw.dce.dispclk_khz);
+		clk_mgr->clks.dispclk_khz = context->bw.dce.dispclk_khz;
 	}
-	dce11_pplib_apply_display_requirements(dccg->ctx->dc, context);
+	dce11_pplib_apply_display_requirements(clk_mgr->ctx->dc, context);
 }
 
-static void dce12_update_clocks(struct dccg *dccg,
+static void dce12_update_clocks(struct clk_mgr *clk_mgr,
 			struct dc_state *context,
 			bool safe_to_lower)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(clk_mgr);
 	struct dm_pp_clock_for_voltage_req clock_voltage_req = {0};
 	int max_pix_clk = get_max_pixel_clock_for_all_paths(context);
 	int unpatched_disp_clk = context->bw.dce.dispclk_khz;
 
 	/*TODO: W/A for dal3 linux, investigate why this works */
-	if (!dccg_dce->dfs_bypass_active)
+	if (!clk_mgr_dce->dfs_bypass_active)
 		context->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz * 115 / 100;
 
-	if (should_set_clock(safe_to_lower, context->bw.dce.dispclk_khz, dccg->clks.dispclk_khz)) {
+	if (should_set_clock(safe_to_lower, context->bw.dce.dispclk_khz, clk_mgr->clks.dispclk_khz)) {
 		clock_voltage_req.clk_type = DM_PP_CLOCK_TYPE_DISPLAY_CLK;
 		clock_voltage_req.clocks_in_khz = context->bw.dce.dispclk_khz;
-		context->bw.dce.dispclk_khz = dce112_set_clock(dccg, context->bw.dce.dispclk_khz);
-		dccg->clks.dispclk_khz = context->bw.dce.dispclk_khz;
+		context->bw.dce.dispclk_khz = dce112_set_clock(clk_mgr, context->bw.dce.dispclk_khz);
+		clk_mgr->clks.dispclk_khz = context->bw.dce.dispclk_khz;
 
-		dm_pp_apply_clock_for_voltage_request(dccg->ctx, &clock_voltage_req);
+		dm_pp_apply_clock_for_voltage_request(clk_mgr->ctx, &clock_voltage_req);
 	}
 
-	if (should_set_clock(safe_to_lower, max_pix_clk, dccg->clks.phyclk_khz)) {
+	if (should_set_clock(safe_to_lower, max_pix_clk, clk_mgr->clks.phyclk_khz)) {
 		clock_voltage_req.clk_type = DM_PP_CLOCK_TYPE_DISPLAYPHYCLK;
 		clock_voltage_req.clocks_in_khz = max_pix_clk;
-		dccg->clks.phyclk_khz = max_pix_clk;
+		clk_mgr->clks.phyclk_khz = max_pix_clk;
 
-		dm_pp_apply_clock_for_voltage_request(dccg->ctx, &clock_voltage_req);
+		dm_pp_apply_clock_for_voltage_request(clk_mgr->ctx, &clock_voltage_req);
 	}
-	dce11_pplib_apply_display_requirements(dccg->ctx->dc, context);
+	dce11_pplib_apply_display_requirements(clk_mgr->ctx->dc, context);
 
 	context->bw.dce.dispclk_khz = unpatched_disp_clk;
 }
 
-static const struct dccg_funcs dce120_funcs = {
+static const struct clk_mgr_funcs dce120_funcs = {
 	.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,
 	.update_clocks = dce12_update_clocks
 };
 
-static const struct dccg_funcs dce112_funcs = {
+static const struct clk_mgr_funcs dce112_funcs = {
 	.get_dp_ref_clk_frequency = dce_get_dp_ref_freq_khz,
 	.update_clocks = dce112_update_clocks
 };
 
-static const struct dccg_funcs dce110_funcs = {
+static const struct clk_mgr_funcs dce110_funcs = {
 	.get_dp_ref_clk_frequency = dce_get_dp_ref_freq_khz,
 	.update_clocks = dce11_update_clocks,
 };
 
-static const struct dccg_funcs dce_funcs = {
+static const struct clk_mgr_funcs dce_funcs = {
 	.get_dp_ref_clk_frequency = dce_get_dp_ref_freq_khz,
 	.update_clocks = dce_update_clocks
 };
 
-static void dce_dccg_construct(
-	struct dce_dccg *dccg_dce,
+static void dce_clk_mgr_construct(
+	struct dce_clk_mgr *clk_mgr_dce,
 	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *clk_shift,
-	const struct dccg_mask *clk_mask)
+	const struct clk_mgr_registers *regs,
+	const struct clk_mgr_shift *clk_shift,
+	const struct clk_mgr_mask *clk_mask)
 {
-	struct dccg *base = &dccg_dce->base;
+	struct clk_mgr *base = &clk_mgr_dce->base;
 	struct dm_pp_static_clock_info static_clk_info = {0};
 
 	base->ctx = ctx;
 	base->funcs = &dce_funcs;
 
-	dccg_dce->regs = regs;
-	dccg_dce->dccg_shift = clk_shift;
-	dccg_dce->dccg_mask = clk_mask;
+	clk_mgr_dce->regs = regs;
+	clk_mgr_dce->clk_mgr_shift = clk_shift;
+	clk_mgr_dce->clk_mgr_mask = clk_mask;
 
-	dccg_dce->dfs_bypass_disp_clk = 0;
+	clk_mgr_dce->dfs_bypass_disp_clk = 0;
 
-	dccg_dce->dprefclk_ss_percentage = 0;
-	dccg_dce->dprefclk_ss_divider = 1000;
-	dccg_dce->ss_on_dprefclk = false;
+	clk_mgr_dce->dprefclk_ss_percentage = 0;
+	clk_mgr_dce->dprefclk_ss_divider = 1000;
+	clk_mgr_dce->ss_on_dprefclk = false;
 
 
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
-		dccg_dce->max_clks_state = static_clk_info.max_clocks_state;
+		clk_mgr_dce->max_clks_state = static_clk_info.max_clocks_state;
 	else
-		dccg_dce->max_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;
-	dccg_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_INVALID;
+		clk_mgr_dce->max_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;
+	clk_mgr_dce->cur_min_clks_state = DM_PP_CLOCKS_STATE_INVALID;
 
-	dce_clock_read_integrated_info(dccg_dce);
-	dce_clock_read_ss_info(dccg_dce);
+	dce_clock_read_integrated_info(clk_mgr_dce);
+	dce_clock_read_ss_info(clk_mgr_dce);
 }
 
-struct dccg *dce_dccg_create(
+struct clk_mgr *dce_clk_mgr_create(
 	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *clk_shift,
-	const struct dccg_mask *clk_mask)
+	const struct clk_mgr_registers *regs,
+	const struct clk_mgr_shift *clk_shift,
+	const struct clk_mgr_mask *clk_mask)
 {
-	struct dce_dccg *dccg_dce = kzalloc(sizeof(*dccg_dce), GFP_KERNEL);
+	struct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);
 
-	if (dccg_dce == NULL) {
+	if (clk_mgr_dce == NULL) {
 		BREAK_TO_DEBUGGER();
 		return NULL;
 	}
 
-	memcpy(dccg_dce->max_clks_by_state,
+	memcpy(clk_mgr_dce->max_clks_by_state,
 		dce80_max_clks_by_state,
 		sizeof(dce80_max_clks_by_state));
 
-	dce_dccg_construct(
-		dccg_dce, ctx, regs, clk_shift, clk_mask);
+	dce_clk_mgr_construct(
+		clk_mgr_dce, ctx, regs, clk_shift, clk_mask);
 
-	return &dccg_dce->base;
+	return &clk_mgr_dce->base;
 }
 
-struct dccg *dce110_dccg_create(
+struct clk_mgr *dce110_clk_mgr_create(
 	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *clk_shift,
-	const struct dccg_mask *clk_mask)
+	const struct clk_mgr_registers *regs,
+	const struct clk_mgr_shift *clk_shift,
+	const struct clk_mgr_mask *clk_mask)
 {
-	struct dce_dccg *dccg_dce = kzalloc(sizeof(*dccg_dce), GFP_KERNEL);
+	struct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);
 
-	if (dccg_dce == NULL) {
+	if (clk_mgr_dce == NULL) {
 		BREAK_TO_DEBUGGER();
 		return NULL;
 	}
 
-	memcpy(dccg_dce->max_clks_by_state,
+	memcpy(clk_mgr_dce->max_clks_by_state,
 		dce110_max_clks_by_state,
 		sizeof(dce110_max_clks_by_state));
 
-	dce_dccg_construct(
-		dccg_dce, ctx, regs, clk_shift, clk_mask);
+	dce_clk_mgr_construct(
+		clk_mgr_dce, ctx, regs, clk_shift, clk_mask);
 
-	dccg_dce->base.funcs = &dce110_funcs;
+	clk_mgr_dce->base.funcs = &dce110_funcs;
 
-	return &dccg_dce->base;
+	return &clk_mgr_dce->base;
 }
 
-struct dccg *dce112_dccg_create(
+struct clk_mgr *dce112_clk_mgr_create(
 	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *clk_shift,
-	const struct dccg_mask *clk_mask)
+	const struct clk_mgr_registers *regs,
+	const struct clk_mgr_shift *clk_shift,
+	const struct clk_mgr_mask *clk_mask)
 {
-	struct dce_dccg *dccg_dce = kzalloc(sizeof(*dccg_dce), GFP_KERNEL);
+	struct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);
 
-	if (dccg_dce == NULL) {
+	if (clk_mgr_dce == NULL) {
 		BREAK_TO_DEBUGGER();
 		return NULL;
 	}
 
-	memcpy(dccg_dce->max_clks_by_state,
+	memcpy(clk_mgr_dce->max_clks_by_state,
 		dce112_max_clks_by_state,
 		sizeof(dce112_max_clks_by_state));
 
-	dce_dccg_construct(
-		dccg_dce, ctx, regs, clk_shift, clk_mask);
+	dce_clk_mgr_construct(
+		clk_mgr_dce, ctx, regs, clk_shift, clk_mask);
 
-	dccg_dce->base.funcs = &dce112_funcs;
+	clk_mgr_dce->base.funcs = &dce112_funcs;
 
-	return &dccg_dce->base;
+	return &clk_mgr_dce->base;
 }
 
-struct dccg *dce120_dccg_create(struct dc_context *ctx)
+struct clk_mgr *dce120_clk_mgr_create(struct dc_context *ctx)
 {
-	struct dce_dccg *dccg_dce = kzalloc(sizeof(*dccg_dce), GFP_KERNEL);
+	struct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);
 
-	if (dccg_dce == NULL) {
+	if (clk_mgr_dce == NULL) {
 		BREAK_TO_DEBUGGER();
 		return NULL;
 	}
 
-	memcpy(dccg_dce->max_clks_by_state,
+	memcpy(clk_mgr_dce->max_clks_by_state,
 		dce120_max_clks_by_state,
 		sizeof(dce120_max_clks_by_state));
 
-	dce_dccg_construct(
-		dccg_dce, ctx, NULL, NULL, NULL);
+	dce_clk_mgr_construct(
+		clk_mgr_dce, ctx, NULL, NULL, NULL);
 
-	dccg_dce->dprefclk_khz = 600000;
-	dccg_dce->base.funcs = &dce120_funcs;
+	clk_mgr_dce->dprefclk_khz = 600000;
+	clk_mgr_dce->base.funcs = &dce120_funcs;
 
-	return &dccg_dce->base;
+	return &clk_mgr_dce->base;
 }
 
-void dce_dccg_destroy(struct dccg **dccg)
+void dce_clk_mgr_destroy(struct clk_mgr **clk_mgr)
 {
-	struct dce_dccg *dccg_dce = TO_DCE_DCCG(*dccg);
+	struct dce_clk_mgr *clk_mgr_dce = TO_DCE_CLK_MGR(*clk_mgr);
 
-	kfree(dccg_dce);
-	*dccg = NULL;
+	kfree(clk_mgr_dce);
+	*clk_mgr = NULL;
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_dccg.h b/drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.h
similarity index 78%
rename from drivers/gpu/drm/amd/display/dc/dce/dce_dccg.h
rename to drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.h
index 786d96319e7a..2668d5645daa 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_dccg.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.h
@@ -24,10 +24,10 @@
  */
 
 
-#ifndef _DCE_DCCG_H_
-#define _DCE_DCCG_H_
+#ifndef _DCE_CLK_MGR_H_
+#define _DCE_CLK_MGR_H_
 
-#include "dccg.h"
+#include "../inc/hw/clk_mgr.h"
 
 #define MEMORY_TYPE_MULTIPLIER_CZ 4
 
@@ -55,15 +55,15 @@
 	type DENTIST_DISPCLK_WDIVIDER; \
 	type DENTIST_DISPCLK_CHG_DONE;
 
-struct dccg_shift {
+struct clk_mgr_shift {
 	CLK_REG_FIELD_LIST(uint8_t)
 };
 
-struct dccg_mask {
+struct clk_mgr_mask {
 	CLK_REG_FIELD_LIST(uint32_t)
 };
 
-struct dccg_registers {
+struct clk_mgr_registers {
 	uint32_t DPREFCLK_CNTL;
 	uint32_t DENTIST_DISPCLK_CNTL;
 };
@@ -73,11 +73,11 @@ struct state_dependent_clocks {
 	int pixel_clk_khz;
 };
 
-struct dce_dccg {
-	struct dccg base;
-	const struct dccg_registers *regs;
-	const struct dccg_shift *dccg_shift;
-	const struct dccg_mask *dccg_mask;
+struct dce_clk_mgr {
+	struct clk_mgr base;
+	const struct clk_mgr_registers *regs;
+	const struct clk_mgr_shift *clk_mgr_shift;
+	const struct clk_mgr_mask *clk_mgr_mask;
 
 	struct state_dependent_clocks max_clks_by_state[DM_PP_CLOCKS_MAX_STATES];
 
@@ -130,36 +130,36 @@ static inline bool should_set_clock(bool safe_to_lower, int calc_clk, int cur_cl
 	return ((safe_to_lower && calc_clk < cur_clk) || calc_clk > cur_clk);
 }
 
-void dce_clock_read_ss_info(struct dce_dccg *dccg_dce);
+void dce_clock_read_ss_info(struct dce_clk_mgr *dccg_dce);
 
-int dce12_get_dp_ref_freq_khz(struct dccg *dccg);
+int dce12_get_dp_ref_freq_khz(struct clk_mgr *dccg);
 
 void dce110_fill_display_configs(
 	const struct dc_state *context,
 	struct dm_pp_display_configuration *pp_display_cfg);
 
-int dce112_set_clock(struct dccg *dccg, int requested_clk_khz);
+int dce112_set_clock(struct clk_mgr *dccg, int requested_clk_khz);
 
-struct dccg *dce_dccg_create(
+struct clk_mgr *dce_clk_mgr_create(
 	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *clk_shift,
-	const struct dccg_mask *clk_mask);
+	const struct clk_mgr_registers *regs,
+	const struct clk_mgr_shift *clk_shift,
+	const struct clk_mgr_mask *clk_mask);
 
-struct dccg *dce110_dccg_create(
+struct clk_mgr *dce110_clk_mgr_create(
 	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *clk_shift,
-	const struct dccg_mask *clk_mask);
+	const struct clk_mgr_registers *regs,
+	const struct clk_mgr_shift *clk_shift,
+	const struct clk_mgr_mask *clk_mask);
 
-struct dccg *dce112_dccg_create(
+struct clk_mgr *dce112_clk_mgr_create(
 	struct dc_context *ctx,
-	const struct dccg_registers *regs,
-	const struct dccg_shift *clk_shift,
-	const struct dccg_mask *clk_mask);
+	const struct clk_mgr_registers *regs,
+	const struct clk_mgr_shift *clk_shift,
+	const struct clk_mgr_mask *clk_mask);
 
-struct dccg *dce120_dccg_create(struct dc_context *ctx);
+struct clk_mgr *dce120_clk_mgr_create(struct dc_context *ctx);
 
-void dce_dccg_destroy(struct dccg **dccg);
+void dce_clk_mgr_destroy(struct clk_mgr **dccg);
 
-#endif /* _DCE_DCCG_H_ */
+#endif /* _DCE_CLK_MGR_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
index 5055026e553f..bc50a8e25f4f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
@@ -111,8 +111,8 @@ void dce100_prepare_bandwidth(
 {
 	dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
-	dc->res_pool->dccg->funcs->update_clocks(
-			dc->res_pool->dccg,
+	dc->res_pool->clk_mgr->funcs->update_clocks(
+			dc->res_pool->clk_mgr,
 			context,
 			false);
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
index 36015f7cfb96..6ae51a5dfc04 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
@@ -22,7 +22,6 @@
  * Authors: AMD
  *
  */
-#include "../dce/dce_dccg.h"
 #include "dm_services.h"
 
 #include "link_encoder.h"
@@ -37,6 +36,7 @@
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
 
+#include "dce/dce_clk_mgr.h"
 #include "dce/dce_mem_input.h"
 #include "dce/dce_ipp.h"
 #include "dce/dce_transform.h"
@@ -137,15 +137,15 @@ static const struct dce110_timing_generator_offsets dce100_tg_offsets[] = {
 	.reg_name = mm ## block ## id ## _ ## reg_name
 
 
-static const struct dccg_registers disp_clk_regs = {
+static const struct clk_mgr_registers disp_clk_regs = {
 		CLK_COMMON_REG_LIST_DCE_BASE()
 };
 
-static const struct dccg_shift disp_clk_shift = {
+static const struct clk_mgr_shift disp_clk_shift = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
 };
 
-static const struct dccg_mask disp_clk_mask = {
+static const struct clk_mgr_mask disp_clk_mask = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
 };
 
@@ -722,8 +722,8 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce_aud_destroy(&pool->base.audios[i]);
 	}
 
-	if (pool->base.dccg != NULL)
-		dce_dccg_destroy(&pool->base.dccg);
+	if (pool->base.clk_mgr != NULL)
+		dce_clk_mgr_destroy(&pool->base.clk_mgr);
 
 	if (pool->base.abm != NULL)
 				dce_abm_destroy(&pool->base.abm);
@@ -907,11 +907,11 @@ static bool construct(
 		}
 	}
 
-	pool->base.dccg = dce_dccg_create(ctx,
+	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 70923f16dd9b..3376b4436b7f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2357,7 +2357,7 @@ void dce110_prepare_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
-	struct dccg *dccg = dc->res_pool->dccg;
+	struct clk_mgr *dccg = dc->res_pool->clk_mgr;
 
 	dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
@@ -2371,7 +2371,7 @@ void dce110_optimize_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
-	struct dccg *dccg = dc->res_pool->dccg;
+	struct clk_mgr *dccg = dc->res_pool->clk_mgr;
 
 	dce110_set_displaymarks(dc, context);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index d78b06470865..c5714ebb9cea 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -31,7 +31,7 @@
 #include "resource.h"
 #include "dce110/dce110_resource.h"
 
-#include "../dce/dce_dccg.h"
+#include "dce/dce_clk_mgr.h"
 #include "include/irq_service_interface.h"
 #include "dce/dce_audio.h"
 #include "dce110/dce110_timing_generator.h"
@@ -148,15 +148,15 @@ static const struct dce110_timing_generator_offsets dce110_tg_offsets[] = {
 #define SRI(reg_name, block, id)\
 	.reg_name = mm ## block ## id ## _ ## reg_name
 
-static const struct dccg_registers disp_clk_regs = {
+static const struct clk_mgr_registers disp_clk_regs = {
 		CLK_COMMON_REG_LIST_DCE_BASE()
 };
 
-static const struct dccg_shift disp_clk_shift = {
+static const struct clk_mgr_shift disp_clk_shift = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
 };
 
-static const struct dccg_mask disp_clk_mask = {
+static const struct clk_mgr_mask disp_clk_mask = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
 };
 
@@ -760,8 +760,8 @@ static void destruct(struct dce110_resource_pool *pool)
 	if (pool->base.dmcu != NULL)
 		dce_dmcu_destroy(&pool->base.dmcu);
 
-	if (pool->base.dccg != NULL)
-		dce_dccg_destroy(&pool->base.dccg);
+	if (pool->base.clk_mgr != NULL)
+		dce_clk_mgr_destroy(&pool->base.clk_mgr);
 
 	if (pool->base.irqs != NULL) {
 		dal_irq_service_destroy(&pool->base.irqs);
@@ -1256,11 +1256,11 @@ static bool construct(
 		}
 	}
 
-	pool->base.dccg = dce110_dccg_create(ctx,
+	pool->base.clk_mgr = dce110_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
index e73b1392bed9..969d4e72dc94 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -23,7 +23,6 @@
  *
  */
 
-#include "../dce/dce_dccg.h"
 #include "dm_services.h"
 
 #include "link_encoder.h"
@@ -36,6 +35,7 @@
 
 #include "irq/dce110/irq_service_dce110.h"
 
+#include "dce/dce_clk_mgr.h"
 #include "dce/dce_mem_input.h"
 #include "dce/dce_transform.h"
 #include "dce/dce_link_encoder.h"
@@ -148,15 +148,15 @@ static const struct dce110_timing_generator_offsets dce112_tg_offsets[] = {
 	.reg_name = mm ## block ## id ## _ ## reg_name
 
 
-static const struct dccg_registers disp_clk_regs = {
+static const struct clk_mgr_registers disp_clk_regs = {
 		CLK_COMMON_REG_LIST_DCE_BASE()
 };
 
-static const struct dccg_shift disp_clk_shift = {
+static const struct clk_mgr_shift disp_clk_shift = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
 };
 
-static const struct dccg_mask disp_clk_mask = {
+static const struct clk_mgr_mask disp_clk_mask = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
 };
 
@@ -750,8 +750,8 @@ static void destruct(struct dce110_resource_pool *pool)
 	if (pool->base.dmcu != NULL)
 		dce_dmcu_destroy(&pool->base.dmcu);
 
-	if (pool->base.dccg != NULL)
-		dce_dccg_destroy(&pool->base.dccg);
+	if (pool->base.clk_mgr != NULL)
+		dce_clk_mgr_destroy(&pool->base.clk_mgr);
 
 	if (pool->base.irqs != NULL) {
 		dal_irq_service_destroy(&pool->base.irqs);
@@ -1199,11 +1199,11 @@ static bool construct(
 		}
 	}
 
-	pool->base.dccg = dce112_dccg_create(ctx,
+	pool->base.clk_mgr = dce112_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
index a69e89f779de..f12696674eb0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
@@ -32,7 +32,6 @@
 #include "include/irq_service_interface.h"
 #include "dce120_resource.h"
 
-#include "../dce/dce_dccg.h"
 #include "dce112/dce112_resource.h"
 
 #include "dce110/dce110_resource.h"
@@ -48,6 +47,7 @@
 #include "dce120/dce120_hw_sequencer.h"
 #include "dce/dce_transform.h"
 
+#include "dce/dce_clk_mgr.h"
 #include "dce/dce_audio.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
@@ -574,8 +574,8 @@ static void destruct(struct dce110_resource_pool *pool)
 	if (pool->base.dmcu != NULL)
 		dce_dmcu_destroy(&pool->base.dmcu);
 
-	if (pool->base.dccg != NULL)
-		dce_dccg_destroy(&pool->base.dccg);
+	if (pool->base.clk_mgr != NULL)
+		dce_clk_mgr_destroy(&pool->base.clk_mgr);
 }
 
 static void read_dce_straps(
@@ -975,8 +975,8 @@ static bool construct(
 		}
 	}
 
-	pool->base.dccg = dce120_dccg_create(ctx);
-	if (pool->base.dccg == NULL) {
+	pool->base.clk_mgr = dce120_clk_mgr_create(ctx);
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto dccg_create_fail;
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 1fccb5230296..6d40b3d54ac1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -23,7 +23,6 @@
  *
  */
 
-#include "../dce/dce_dccg.h"
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 
@@ -38,6 +37,7 @@
 #include "dce110/dce110_timing_generator.h"
 #include "dce110/dce110_resource.h"
 #include "dce80/dce80_timing_generator.h"
+#include "dce/dce_clk_mgr.h"
 #include "dce/dce_mem_input.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
@@ -155,15 +155,15 @@ static const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {
 	.reg_name = mm ## block ## id ## _ ## reg_name
 
 
-static const struct dccg_registers disp_clk_regs = {
+static const struct clk_mgr_registers disp_clk_regs = {
 		CLK_COMMON_REG_LIST_DCE_BASE()
 };
 
-static const struct dccg_shift disp_clk_shift = {
+static const struct clk_mgr_shift disp_clk_shift = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
 };
 
-static const struct dccg_mask disp_clk_mask = {
+static const struct clk_mgr_mask disp_clk_mask = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
 };
 
@@ -779,8 +779,8 @@ static void destruct(struct dce110_resource_pool *pool)
 		}
 	}
 
-	if (pool->base.dccg != NULL)
-		dce_dccg_destroy(&pool->base.dccg);
+	if (pool->base.clk_mgr != NULL)
+		dce_clk_mgr_destroy(&pool->base.clk_mgr);
 
 	if (pool->base.irqs != NULL) {
 		dal_irq_service_destroy(&pool->base.irqs);
@@ -917,11 +917,11 @@ static bool dce80_construct(
 		}
 	}
 
-	pool->base.dccg = dce_dccg_create(ctx,
+	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
@@ -1122,11 +1122,11 @@ static bool dce81_construct(
 		}
 	}
 
-	pool->base.dccg = dce_dccg_create(ctx,
+	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
@@ -1323,11 +1323,11 @@ static bool dce83_construct(
 		}
 	}
 
-	pool->base.dccg = dce_dccg_create(ctx,
+	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/Makefile b/drivers/gpu/drm/amd/display/dc/dcn10/Makefile
index e13ab66a161a..55f293c8a3c0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/Makefile
@@ -24,7 +24,7 @@
 
 DCN10 = dcn10_resource.o dcn10_ipp.o dcn10_hw_sequencer.o dcn10_hw_sequencer_debug.o \
 		dcn10_dpp.o dcn10_opp.o dcn10_optc.o \
-		dcn10_hubp.o dcn10_mpc.o dcn10_dccg.o \
+		dcn10_hubp.o dcn10_mpc.o dcn10_clk_mgr.o \
 		dcn10_dpp_dscl.o dcn10_dpp_cm.o dcn10_cm_common.o \
 		dcn10_hubbub.o dcn10_stream_encoder.o dcn10_link_encoder.o
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dccg.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_clk_mgr.c
similarity index 69%
rename from drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dccg.c
rename to drivers/gpu/drm/amd/display/dc/dcn10/dcn10_clk_mgr.c
index 5ffc36753668..6f329d1e8fd3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dccg.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_clk_mgr.c
@@ -23,25 +23,25 @@
  *
  */
 
-#include "dcn10_dccg.h"
+#include "dcn10_clk_mgr.h"
 
 #include "reg_helper.h"
 #include "core_types.h"
 
-#define TO_DCE_DCCG(clocks)\
-	container_of(clocks, struct dce_dccg, base)
+#define TO_DCE_CLK_MGR(clocks)\
+	container_of(clocks, struct dce_clk_mgr, base)
 
 #define REG(reg) \
-	(dccg_dce->regs->reg)
+	(clk_mgr_dce->regs->reg)
 
 #undef FN
 #define FN(reg_name, field_name) \
-	dccg_dce->dccg_shift->field_name, dccg_dce->dccg_mask->field_name
+	clk_mgr_dce->clk_mgr_shift->field_name, clk_mgr_dce->clk_mgr_mask->field_name
 
 #define CTX \
-	dccg_dce->base.ctx
+	clk_mgr_dce->base.ctx
 #define DC_LOGGER \
-	dccg->ctx->logger
+	clk_mgr->ctx->logger
 
 void dcn1_pplib_apply_display_requirements(
 	struct dc *dc,
@@ -49,24 +49,24 @@ void dcn1_pplib_apply_display_requirements(
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
-	pp_display_cfg->min_engine_clock_khz = dc->res_pool->dccg->clks.dcfclk_khz;
-	pp_display_cfg->min_memory_clock_khz = dc->res_pool->dccg->clks.fclk_khz;
-	pp_display_cfg->min_engine_clock_deep_sleep_khz = dc->res_pool->dccg->clks.dcfclk_deep_sleep_khz;
-	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = dc->res_pool->dccg->clks.dcfclk_deep_sleep_khz;
-	pp_display_cfg->min_dcfclock_khz = dc->res_pool->dccg->clks.dcfclk_khz;
-	pp_display_cfg->disp_clk_khz = dc->res_pool->dccg->clks.dispclk_khz;
+	pp_display_cfg->min_engine_clock_khz = dc->res_pool->clk_mgr->clks.dcfclk_khz;
+	pp_display_cfg->min_memory_clock_khz = dc->res_pool->clk_mgr->clks.fclk_khz;
+	pp_display_cfg->min_engine_clock_deep_sleep_khz = dc->res_pool->clk_mgr->clks.dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = dc->res_pool->clk_mgr->clks.dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_dcfclock_khz = dc->res_pool->clk_mgr->clks.dcfclk_khz;
+	pp_display_cfg->disp_clk_khz = dc->res_pool->clk_mgr->clks.dispclk_khz;
 	dce110_fill_display_configs(context, pp_display_cfg);
 
 	if (memcmp(&dc->current_state->pp_display_cfg, pp_display_cfg, sizeof(*pp_display_cfg)) !=  0)
 		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
 }
 
-static int dcn1_determine_dppclk_threshold(struct dccg *dccg, struct dc_clocks *new_clocks)
+static int dcn1_determine_dppclk_threshold(struct clk_mgr *clk_mgr, struct dc_clocks *new_clocks)
 {
 	bool request_dpp_div = new_clocks->dispclk_khz > new_clocks->dppclk_khz;
-	bool dispclk_increase = new_clocks->dispclk_khz > dccg->clks.dispclk_khz;
+	bool dispclk_increase = new_clocks->dispclk_khz > clk_mgr->clks.dispclk_khz;
 	int disp_clk_threshold = new_clocks->max_supported_dppclk_khz;
-	bool cur_dpp_div = dccg->clks.dispclk_khz > dccg->clks.dppclk_khz;
+	bool cur_dpp_div = clk_mgr->clks.dispclk_khz > clk_mgr->clks.dppclk_khz;
 
 	/* increase clock, looking for div is 0 for current, request div is 1*/
 	if (dispclk_increase) {
@@ -96,7 +96,7 @@ static int dcn1_determine_dppclk_threshold(struct dccg *dccg, struct dc_clocks *
 		/* current disp clk is lower than current maximum dpp clk,
 		 * no need to ramp
 		 */
-		if (dccg->clks.dispclk_khz <= disp_clk_threshold)
+		if (clk_mgr->clks.dispclk_khz <= disp_clk_threshold)
 			return new_clocks->dispclk_khz;
 
 		/* request dpp clk need to be divided by 2 */
@@ -107,15 +107,15 @@ static int dcn1_determine_dppclk_threshold(struct dccg *dccg, struct dc_clocks *
 	return disp_clk_threshold;
 }
 
-static void dcn1_ramp_up_dispclk_with_dpp(struct dccg *dccg, struct dc_clocks *new_clocks)
+static void dcn1_ramp_up_dispclk_with_dpp(struct clk_mgr *clk_mgr, struct dc_clocks *new_clocks)
 {
-	struct dc *dc = dccg->ctx->dc;
-	int dispclk_to_dpp_threshold = dcn1_determine_dppclk_threshold(dccg, new_clocks);
+	struct dc *dc = clk_mgr->ctx->dc;
+	int dispclk_to_dpp_threshold = dcn1_determine_dppclk_threshold(clk_mgr, new_clocks);
 	bool request_dpp_div = new_clocks->dispclk_khz > new_clocks->dppclk_khz;
 	int i;
 
 	/* set disp clk to dpp clk threshold */
-	dce112_set_clock(dccg, dispclk_to_dpp_threshold);
+	dce112_set_clock(clk_mgr, dispclk_to_dpp_threshold);
 
 	/* update request dpp clk division option */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -132,11 +132,11 @@ static void dcn1_ramp_up_dispclk_with_dpp(struct dccg *dccg, struct dc_clocks *n
 
 	/* If target clk not same as dppclk threshold, set to target clock */
 	if (dispclk_to_dpp_threshold != new_clocks->dispclk_khz)
-		dce112_set_clock(dccg, new_clocks->dispclk_khz);
+		dce112_set_clock(clk_mgr, new_clocks->dispclk_khz);
 
-	dccg->clks.dispclk_khz = new_clocks->dispclk_khz;
-	dccg->clks.dppclk_khz = new_clocks->dppclk_khz;
-	dccg->clks.max_supported_dppclk_khz = new_clocks->max_supported_dppclk_khz;
+	clk_mgr->clks.dispclk_khz = new_clocks->dispclk_khz;
+	clk_mgr->clks.dppclk_khz = new_clocks->dppclk_khz;
+	clk_mgr->clks.max_supported_dppclk_khz = new_clocks->max_supported_dppclk_khz;
 }
 
 static int get_active_display_cnt(
@@ -196,11 +196,11 @@ static void notify_hard_min_dcfclk_to_smu(
 	pp_smu->set_hard_min_dcfclk_by_freq(&pp_smu->pp_smu, min_dcf_clk_mhz);
 }
 
-static void dcn1_update_clocks(struct dccg *dccg,
+static void dcn1_update_clocks(struct clk_mgr *clk_mgr,
 			struct dc_state *context,
 			bool safe_to_lower)
 {
-	struct dc *dc = dccg->ctx->dc;
+	struct dc *dc = clk_mgr->ctx->dc;
 	struct dc_clocks *new_clocks = &context->bw.dcn.clk;
 	struct pp_smu_display_requirement_rv *smu_req_cur =
 			&dc->res_pool->pp_smu_req;
@@ -231,40 +231,40 @@ static void dcn1_update_clocks(struct dccg *dccg,
 
 	}
 
-	if (new_clocks->dispclk_khz > dccg->clks.dispclk_khz
-			|| new_clocks->phyclk_khz > dccg->clks.phyclk_khz
-			|| new_clocks->fclk_khz > dccg->clks.fclk_khz
-			|| new_clocks->dcfclk_khz > dccg->clks.dcfclk_khz)
+	if (new_clocks->dispclk_khz > clk_mgr->clks.dispclk_khz
+			|| new_clocks->phyclk_khz > clk_mgr->clks.phyclk_khz
+			|| new_clocks->fclk_khz > clk_mgr->clks.fclk_khz
+			|| new_clocks->dcfclk_khz > clk_mgr->clks.dcfclk_khz)
 		send_request_to_increase = true;
 
-	if (should_set_clock(safe_to_lower, new_clocks->phyclk_khz, dccg->clks.phyclk_khz)) {
-		dccg->clks.phyclk_khz = new_clocks->phyclk_khz;
+	if (should_set_clock(safe_to_lower, new_clocks->phyclk_khz, clk_mgr->clks.phyclk_khz)) {
+		clk_mgr->clks.phyclk_khz = new_clocks->phyclk_khz;
 
 		send_request_to_lower = true;
 	}
 
 	// F Clock
-	if (should_set_clock(safe_to_lower, new_clocks->fclk_khz, dccg->clks.fclk_khz)) {
-		dccg->clks.fclk_khz = new_clocks->fclk_khz;
+	if (should_set_clock(safe_to_lower, new_clocks->fclk_khz, clk_mgr->clks.fclk_khz)) {
+		clk_mgr->clks.fclk_khz = new_clocks->fclk_khz;
 		clock_voltage_req.clk_type = DM_PP_CLOCK_TYPE_FCLK;
 		clock_voltage_req.clocks_in_khz = new_clocks->fclk_khz;
 		smu_req.hard_min_fclk_khz = new_clocks->fclk_khz;
 
-		dm_pp_apply_clock_for_voltage_request(dccg->ctx, &clock_voltage_req);
+		dm_pp_apply_clock_for_voltage_request(clk_mgr->ctx, &clock_voltage_req);
 		send_request_to_lower = true;
 	}
 
 	//DCF Clock
-	if (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, dccg->clks.dcfclk_khz)) {
-		dccg->clks.dcfclk_khz = new_clocks->dcfclk_khz;
+	if (should_set_clock(safe_to_lower, new_clocks->dcfclk_khz, clk_mgr->clks.dcfclk_khz)) {
+		clk_mgr->clks.dcfclk_khz = new_clocks->dcfclk_khz;
 		smu_req.hard_min_dcefclk_khz = new_clocks->dcfclk_khz;
 
 		send_request_to_lower = true;
 	}
 
 	if (should_set_clock(safe_to_lower,
-			new_clocks->dcfclk_deep_sleep_khz, dccg->clks.dcfclk_deep_sleep_khz)) {
-		dccg->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;
+			new_clocks->dcfclk_deep_sleep_khz, clk_mgr->clks.dcfclk_deep_sleep_khz)) {
+		clk_mgr->clks.dcfclk_deep_sleep_khz = new_clocks->dcfclk_deep_sleep_khz;
 		smu_req.min_deep_sleep_dcefclk_mhz = new_clocks->dcfclk_deep_sleep_khz;
 
 		send_request_to_lower = true;
@@ -279,20 +279,19 @@ static void dcn1_update_clocks(struct dccg *dccg,
 		clock_voltage_req.clocks_in_khz = dcn_find_dcfclk_suits_all(dc, new_clocks);
 
 		notify_hard_min_dcfclk_to_smu(pp_smu, clock_voltage_req.clocks_in_khz);
-
 		if (pp_smu->set_display_requirement)
 			pp_smu->set_display_requirement(&pp_smu->pp_smu, &smu_req);
 
-		notify_deep_sleep_dcfclk_to_smu(pp_smu, dccg->clks.dcfclk_deep_sleep_khz);
+		notify_deep_sleep_dcfclk_to_smu(pp_smu, clk_mgr->clks.dcfclk_deep_sleep_khz);
 		dcn1_pplib_apply_display_requirements(dc, context);
 	}
 
 	/* dcn1 dppclk is tied to dispclk */
 	/* program dispclk on = as a w/a for sleep resume clock ramping issues */
-	if (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, dccg->clks.dispclk_khz)
-			|| new_clocks->dispclk_khz == dccg->clks.dispclk_khz) {
-		dcn1_ramp_up_dispclk_with_dpp(dccg, new_clocks);
-		dccg->clks.dispclk_khz = new_clocks->dispclk_khz;
+	if (should_set_clock(safe_to_lower, new_clocks->dispclk_khz, clk_mgr->clks.dispclk_khz)
+			|| new_clocks->dispclk_khz == clk_mgr->clks.dispclk_khz) {
+		dcn1_ramp_up_dispclk_with_dpp(clk_mgr, new_clocks);
+		clk_mgr->clks.dispclk_khz = new_clocks->dispclk_khz;
 
 		send_request_to_lower = true;
 	}
@@ -307,7 +306,7 @@ static void dcn1_update_clocks(struct dccg *dccg,
 		if (pp_smu->set_display_requirement)
 			pp_smu->set_display_requirement(&pp_smu->pp_smu, &smu_req);
 
-		notify_deep_sleep_dcfclk_to_smu(pp_smu, dccg->clks.dcfclk_deep_sleep_khz);
+		notify_deep_sleep_dcfclk_to_smu(pp_smu, clk_mgr->clks.dcfclk_deep_sleep_khz);
 		dcn1_pplib_apply_display_requirements(dc, context);
 	}
 
@@ -315,47 +314,47 @@ static void dcn1_update_clocks(struct dccg *dccg,
 	*smu_req_cur = smu_req;
 }
 
-static const struct dccg_funcs dcn1_funcs = {
+static const struct clk_mgr_funcs dcn1_funcs = {
 	.get_dp_ref_clk_frequency = dce12_get_dp_ref_freq_khz,
 	.update_clocks = dcn1_update_clocks
 };
 
-struct dccg *dcn1_dccg_create(struct dc_context *ctx)
+struct clk_mgr *dcn1_clk_mgr_create(struct dc_context *ctx)
 {
 	struct dc_debug_options *debug = &ctx->dc->debug;
 	struct dc_bios *bp = ctx->dc_bios;
 	struct dc_firmware_info fw_info = { { 0 } };
-	struct dce_dccg *dccg_dce = kzalloc(sizeof(*dccg_dce), GFP_KERNEL);
+	struct dce_clk_mgr *clk_mgr_dce = kzalloc(sizeof(*clk_mgr_dce), GFP_KERNEL);
 
-	if (dccg_dce == NULL) {
+	if (clk_mgr_dce == NULL) {
 		BREAK_TO_DEBUGGER();
 		return NULL;
 	}
 
-	dccg_dce->base.ctx = ctx;
-	dccg_dce->base.funcs = &dcn1_funcs;
+	clk_mgr_dce->base.ctx = ctx;
+	clk_mgr_dce->base.funcs = &dcn1_funcs;
 
-	dccg_dce->dfs_bypass_disp_clk = 0;
+	clk_mgr_dce->dfs_bypass_disp_clk = 0;
 
-	dccg_dce->dprefclk_ss_percentage = 0;
-	dccg_dce->dprefclk_ss_divider = 1000;
-	dccg_dce->ss_on_dprefclk = false;
+	clk_mgr_dce->dprefclk_ss_percentage = 0;
+	clk_mgr_dce->dprefclk_ss_divider = 1000;
+	clk_mgr_dce->ss_on_dprefclk = false;
 
-	dccg_dce->dprefclk_khz = 600000;
+	clk_mgr_dce->dprefclk_khz = 600000;
 	if (bp->integrated_info)
-		dccg_dce->dentist_vco_freq_khz = bp->integrated_info->dentist_vco_freq;
-	if (dccg_dce->dentist_vco_freq_khz == 0) {
+		clk_mgr_dce->dentist_vco_freq_khz = bp->integrated_info->dentist_vco_freq;
+	if (clk_mgr_dce->dentist_vco_freq_khz == 0) {
 		bp->funcs->get_firmware_info(bp, &fw_info);
-		dccg_dce->dentist_vco_freq_khz = fw_info.smu_gpu_pll_output_freq;
-		if (dccg_dce->dentist_vco_freq_khz == 0)
-			dccg_dce->dentist_vco_freq_khz = 3600000;
+		clk_mgr_dce->dentist_vco_freq_khz = fw_info.smu_gpu_pll_output_freq;
+		if (clk_mgr_dce->dentist_vco_freq_khz == 0)
+			clk_mgr_dce->dentist_vco_freq_khz = 3600000;
 	}
 
 	if (!debug->disable_dfs_bypass && bp->integrated_info)
 		if (bp->integrated_info->gpu_cap_info & DFS_BYPASS_ENABLE)
-			dccg_dce->dfs_bypass_enabled = true;
+			clk_mgr_dce->dfs_bypass_enabled = true;
 
-	dce_clock_read_ss_info(dccg_dce);
+	dce_clock_read_ss_info(clk_mgr_dce);
 
-	return &dccg_dce->base;
+	return &clk_mgr_dce->base;
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dccg.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_clk_mgr.h
similarity index 87%
rename from drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dccg.h
rename to drivers/gpu/drm/amd/display/dc/dcn10/dcn10_clk_mgr.h
index 7f3dd84be872..9dbaf6578006 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dccg.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_clk_mgr.h
@@ -23,15 +23,15 @@
  *
  */
 
-#ifndef __DCN10_DCCG_H__
-#define __DCN10_DCCG_H__
+#ifndef __DCN10_CLK_MGR_H__
+#define __DCN10_CLK_MGR_H__
 
-#include "../dce/dce_dccg.h"
+#include "../dce/dce_clk_mgr.h"
 
 void dcn1_pplib_apply_display_requirements(
 	struct dc *dc,
 	struct dc_state *context);
 
-struct dccg *dcn1_dccg_create(struct dc_context *ctx);
+struct clk_mgr *dcn1_clk_mgr_create(struct dc_context *ctx);
 
-#endif //__DCN10_DCCG_H__
+#endif //__DCN10_CLK_MGR_H__
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d1f8c8e0b4c3..5c4a4f68b8a0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1126,7 +1126,7 @@ static void dcn10_init_hw(struct dc *dc)
 
 	enable_power_gating_plane(dc->hwseq, true);
 
-	memset(&dc->res_pool->dccg->clks, 0, sizeof(dc->res_pool->dccg->clks));
+	memset(&dc->res_pool->clk_mgr->clks, 0, sizeof(dc->res_pool->clk_mgr->clks));
 }
 
 static void reset_hw_ctx_wrap(
@@ -2052,16 +2052,16 @@ void update_dchubp_dpp(
 	 */
 	if (plane_state->update_flags.bits.full_update) {
 		bool should_divided_by_2 = context->bw.dcn.clk.dppclk_khz <=
-				dc->res_pool->dccg->clks.dispclk_khz / 2;
+				dc->res_pool->clk_mgr->clks.dispclk_khz / 2;
 
 		dpp->funcs->dpp_dppclk_control(
 				dpp,
 				should_divided_by_2,
 				true);
 
-		dc->res_pool->dccg->clks.dppclk_khz = should_divided_by_2 ?
-						dc->res_pool->dccg->clks.dispclk_khz / 2 :
-							dc->res_pool->dccg->clks.dispclk_khz;
+		dc->res_pool->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
+						dc->res_pool->clk_mgr->clks.dispclk_khz / 2 :
+							dc->res_pool->clk_mgr->clks.dispclk_khz;
 	}
 
 	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
@@ -2369,8 +2369,8 @@ static void dcn10_prepare_bandwidth(
 		if (context->stream_count == 0)
 			context->bw.dcn.clk.phyclk_khz = 0;
 
-		dc->res_pool->dccg->funcs->update_clocks(
-				dc->res_pool->dccg,
+		dc->res_pool->clk_mgr->funcs->update_clocks(
+				dc->res_pool->clk_mgr,
 				context,
 				false);
 	}
@@ -2398,8 +2398,8 @@ static void dcn10_optimize_bandwidth(
 		if (context->stream_count == 0)
 			context->bw.dcn.clk.phyclk_khz = 0;
 
-		dc->res_pool->dccg->funcs->update_clocks(
-				dc->res_pool->dccg,
+		dc->res_pool->clk_mgr->funcs->update_clocks(
+				dc->res_pool->clk_mgr,
 				context,
 				true);
 	}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
index 3d9118e1ee10..acb917ddaba9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -28,23 +28,23 @@
 
 #include "resource.h"
 #include "include/irq_service_interface.h"
-#include "dcn10/dcn10_resource.h"
+#include "dcn10_resource.h"
 
-#include "dcn10/dcn10_ipp.h"
-#include "dcn10/dcn10_mpc.h"
+#include "dcn10_ipp.h"
+#include "dcn10_mpc.h"
 #include "irq/dcn10/irq_service_dcn10.h"
-#include "dcn10/dcn10_dpp.h"
+#include "dcn10_dpp.h"
 #include "dcn10_optc.h"
-#include "dcn10/dcn10_hw_sequencer.h"
+#include "dcn10_hw_sequencer.h"
 #include "dce110/dce110_hw_sequencer.h"
-#include "dcn10/dcn10_opp.h"
-#include "dcn10/dcn10_link_encoder.h"
-#include "dcn10/dcn10_stream_encoder.h"
-#include "dcn10/dcn10_dccg.h"
+#include "dcn10_opp.h"
+#include "dcn10_link_encoder.h"
+#include "dcn10_stream_encoder.h"
+#include "dcn10_clk_mgr.h"
 #include "dce/dce_clock_source.h"
 #include "dce/dce_audio.h"
 #include "dce/dce_hwseq.h"
-#include "../virtual/virtual_stream_encoder.h"
+#include "virtual/virtual_stream_encoder.h"
 #include "dce110/dce110_resource.h"
 #include "dce112/dce112_resource.h"
 #include "dcn10_hubp.h"
@@ -950,8 +950,8 @@ static void destruct(struct dcn10_resource_pool *pool)
 	if (pool->base.dmcu != NULL)
 		dce_dmcu_destroy(&pool->base.dmcu);
 
-	if (pool->base.dccg != NULL)
-		dce_dccg_destroy(&pool->base.dccg);
+	if (pool->base.clk_mgr != NULL)
+		dce_clk_mgr_destroy(&pool->base.clk_mgr);
 
 	kfree(pool->base.pp_smu);
 }
@@ -1277,8 +1277,8 @@ static bool construct(
 		}
 	}
 
-	pool->base.dccg = dcn1_dccg_create(ctx);
-	if (pool->base.dccg == NULL) {
+	pool->base.clk_mgr = dcn1_clk_mgr_create(ctx);
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto fail;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index 3a394a5e56a6..ca6818f8eb60 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -82,7 +82,7 @@ void core_link_disable_stream(struct pipe_ctx *pipe_ctx, int option);
 
 void core_link_set_avmute(struct pipe_ctx *pipe_ctx, bool enable);
 /********** DAL Core*********************/
-#include "hw/dccg.h"
+#include "hw/clk_mgr.h"
 #include "transform.h"
 #include "dpp.h"
 
@@ -169,7 +169,7 @@ struct resource_pool {
 	unsigned int audio_count;
 	struct audio_support audio_support;
 
-	struct dccg *dccg;
+	struct clk_mgr *clk_mgr;
 	struct irq_service *irqs;
 
 	struct abm *abm;
@@ -287,7 +287,7 @@ struct dc_state {
 	struct dcn_bw_internal_vars dcn_bw_vars;
 #endif
 
-	struct dccg *dccg;
+	struct clk_mgr *dccg;
 
 	struct kref refcount;
 };
diff --git a/drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h b/drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h
index ac9b4906dd05..ece954a40a8e 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h
@@ -32,7 +32,7 @@
 
 #include "bw_fixed.h"
 #include "../dml/display_mode_lib.h"
-#include "hw/dccg.h"
+#include "hw/clk_mgr.h"
 
 struct dc;
 struct dc_state;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dccg.h b/drivers/gpu/drm/amd/display/dc/inc/hw/clk_mgr.h
similarity index 83%
rename from drivers/gpu/drm/amd/display/dc/inc/hw/dccg.h
rename to drivers/gpu/drm/amd/display/dc/inc/hw/clk_mgr.h
index 6fd923d876dc..23a4b18e5fee 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dccg.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/clk_mgr.h
@@ -23,25 +23,25 @@
  *
  */
 
-#ifndef __DAL_DCCG_H__
-#define __DAL_DCCG_H__
+#ifndef __DAL_CLK_MGR_H__
+#define __DAL_CLK_MGR_H__
 
 #include "dm_services_types.h"
 #include "dc.h"
 
-struct dccg {
+struct clk_mgr {
 	struct dc_context *ctx;
-	const struct dccg_funcs *funcs;
+	const struct clk_mgr_funcs *funcs;
 
 	struct dc_clocks clks;
 };
 
-struct dccg_funcs {
-	void (*update_clocks)(struct dccg *dccg,
+struct clk_mgr_funcs {
+	void (*update_clocks)(struct clk_mgr *clk_mgr,
 			struct dc_state *context,
 			bool safe_to_lower);
 
-	int (*get_dp_ref_clk_frequency)(struct dccg *dccg);
+	int (*get_dp_ref_clk_frequency)(struct clk_mgr *clk_mgr);
 };
 
-#endif /* __DAL_DCCG_H__ */
+#endif /* __DAL_CLK_MGR_H__ */
-- 
2.17.1

