From 00a3e0a369c55fcc8fa511076362056ca0807128 Mon Sep 17 00:00:00 2001
From: Likun Gao <Likun.Gao@amd.com>
Date: Thu, 24 Jan 2019 19:53:40 +0800
Subject: [PATCH 1466/2940] drm/amd/powerplay: Unify smu handle task function
 (v2)

Unify power stade adjust function into smu_handle_task by the judgment
of task_id.
Move functions which have no relationship with smu version into the file
of amdgpu_smu.
Modified the function of smu_display_config_changed into two part.
Unify some similiar function.

v2: Correct the operation of upload dpm level when force dpm limit value.

Signed-off-by: Likun Gao <Likun.Gao@amd.com>
Reviewed-by: Huang Rui <ray.huang@amd.com>
Acked-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c        |  46 ++--
 drivers/gpu/drm/amd/powerplay/amdgpu_smu.c    | 127 +++++++++
 .../gpu/drm/amd/powerplay/inc/amdgpu_smu.h    |  31 +++
 drivers/gpu/drm/amd/powerplay/vega20_ppt.c    | 258 +++++-------------
 4 files changed, 250 insertions(+), 212 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c
index b83981284a7c..47d2ba528a0f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c
@@ -2608,28 +2608,38 @@ void amdgpu_pm_compute_clocks(struct amdgpu_device *adev)
 			amdgpu_fence_wait_empty(ring);
 	}
 
-	if (adev->powerplay.pp_funcs->dispatch_tasks) {
-		if (!amdgpu_device_has_dc_support(adev)) {
+	if (is_support_sw_smu(adev)) {
+		struct smu_context *smu = &adev->smu;
+		struct smu_dpm_context *smu_dpm = &adev->smu.smu_dpm;
+		mutex_lock(&(smu->mutex));
+		smu_handle_task(&adev->smu,
+				smu_dpm->dpm_level,
+				AMD_PP_TASK_DISPLAY_CONFIG_CHANGE);
+		mutex_unlock(&(smu->mutex));
+	} else {
+		if (adev->powerplay.pp_funcs->dispatch_tasks) {
+			if (!amdgpu_device_has_dc_support(adev)) {
+				mutex_lock(&adev->pm.mutex);
+				amdgpu_dpm_get_active_displays(adev);
+				adev->pm.pm_display_cfg.num_display = adev->pm.dpm.new_active_crtc_count;
+				adev->pm.pm_display_cfg.vrefresh = amdgpu_dpm_get_vrefresh(adev);
+				adev->pm.pm_display_cfg.min_vblank_time = amdgpu_dpm_get_vblank_time(adev);
+				/* we have issues with mclk switching with refresh rates over 120 hz on the non-DC code. */
+				if (adev->pm.pm_display_cfg.vrefresh > 120)
+					adev->pm.pm_display_cfg.min_vblank_time = 0;
+				if (adev->powerplay.pp_funcs->display_configuration_change)
+					adev->powerplay.pp_funcs->display_configuration_change(
+									adev->powerplay.pp_handle,
+									&adev->pm.pm_display_cfg);
+				mutex_unlock(&adev->pm.mutex);
+			}
+			amdgpu_dpm_dispatch_task(adev, AMD_PP_TASK_DISPLAY_CONFIG_CHANGE, NULL);
+		} else {
 			mutex_lock(&adev->pm.mutex);
 			amdgpu_dpm_get_active_displays(adev);
-			adev->pm.pm_display_cfg.num_display = adev->pm.dpm.new_active_crtc_count;
-			adev->pm.pm_display_cfg.vrefresh = amdgpu_dpm_get_vrefresh(adev);
-			adev->pm.pm_display_cfg.min_vblank_time = amdgpu_dpm_get_vblank_time(adev);
-			/* we have issues with mclk switching with refresh rates over 120 hz on the non-DC code. */
-			if (adev->pm.pm_display_cfg.vrefresh > 120)
-				adev->pm.pm_display_cfg.min_vblank_time = 0;
-			if (adev->powerplay.pp_funcs->display_configuration_change)
-				adev->powerplay.pp_funcs->display_configuration_change(
-								adev->powerplay.pp_handle,
-								&adev->pm.pm_display_cfg);
+			amdgpu_dpm_change_power_state_locked(adev);
 			mutex_unlock(&adev->pm.mutex);
 		}
-		amdgpu_dpm_dispatch_task(adev, AMD_PP_TASK_DISPLAY_CONFIG_CHANGE, NULL);
-	} else {
-		mutex_lock(&adev->pm.mutex);
-		amdgpu_dpm_get_active_displays(adev);
-		amdgpu_dpm_change_power_state_locked(adev);
-		mutex_unlock(&adev->pm.mutex);
 	}
 }
 
diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d6578be92196..48b346f95cd6 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1041,6 +1041,133 @@ static int smu_enable_umd_pstate(void *handle,
 	return 0;
 }
 
+int smu_unforce_dpm_levels(struct smu_context *smu)
+{
+	int ret = 0;
+
+	ret = smu_upload_dpm_level(smu, false);
+	if (ret) {
+		pr_err("Failed to upload DPM Bootup Levels!");
+		return ret;
+	}
+
+	ret = smu_upload_dpm_level(smu, true);
+	if (ret) {
+		pr_err("Failed to upload DPM Max Levels!");
+		return ret;
+	}
+
+	return ret;
+}
+
+int smu_adjust_power_state_dynamic(struct smu_context *smu,
+				   enum amd_dpm_forced_level level,
+				   bool skip_display_settings)
+{
+	int ret = 0;
+	int index = 0;
+	uint32_t sclk_mask, mclk_mask, soc_mask;
+	long workload;
+	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+
+	if (!skip_display_settings) {
+		ret = smu_display_config_changed(smu);
+		if (ret) {
+			pr_err("Failed to change display config!");
+			return ret;
+		}
+	}
+
+	ret = smu_apply_clocks_adjust_rules(smu);
+	if (ret) {
+		pr_err("Failed to apply clocks adjust rules!");
+		return ret;
+	}
+
+	if (!skip_display_settings) {
+		ret = smu_notify_smc_dispaly_config(smu);
+		if (ret) {
+			pr_err("Failed to notify smc display config!");
+			return ret;
+		}
+	}
+
+	if (smu_dpm_ctx->dpm_level != level) {
+		switch (level) {
+		case AMD_DPM_FORCED_LEVEL_HIGH:
+			ret = smu_force_dpm_limit_value(smu, true);
+			break;
+		case AMD_DPM_FORCED_LEVEL_LOW:
+			ret = smu_force_dpm_limit_value(smu, false);
+			break;
+
+		case AMD_DPM_FORCED_LEVEL_AUTO:
+			ret = smu_unforce_dpm_levels(smu);
+			break;
+
+		case AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:
+			ret = smu_get_profiling_clk_mask(smu, level,
+							 &sclk_mask,
+							 &mclk_mask,
+							 &soc_mask);
+			if (ret)
+				return ret;
+			smu_force_clk_levels(smu, PP_SCLK, 1 << sclk_mask);
+			smu_force_clk_levels(smu, PP_MCLK, 1 << mclk_mask);
+			break;
+
+		case AMD_DPM_FORCED_LEVEL_MANUAL:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:
+		default:
+			break;
+		}
+
+		if (!ret)
+			smu_dpm_ctx->dpm_level = level;
+	}
+
+	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
+		index = fls(smu->workload_mask);
+		index = index > 0 && index <= WORKLOAD_POLICY_MAX ? index - 1 : 0;
+		workload = smu->workload_setting[index];
+
+		if (smu->power_profile_mode != workload)
+			smu_set_power_profile_mode(smu, &workload, 0);
+	}
+
+	return ret;
+}
+
+int smu_handle_task(struct smu_context *smu,
+		    enum amd_dpm_forced_level level,
+		    enum amd_pp_task task_id)
+{
+	int ret = 0;
+
+	switch (task_id) {
+	case AMD_PP_TASK_DISPLAY_CONFIG_CHANGE:
+		ret = smu_pre_display_config_changed(smu);
+		if (ret)
+			return ret;
+		ret = smu_set_cpu_power_state(smu);
+		if (ret)
+			return ret;
+		ret = smu_adjust_power_state_dynamic(smu, level, false);
+		break;
+	case AMD_PP_TASK_COMPLETE_INIT:
+	case AMD_PP_TASK_READJUST_POWER_STATE:
+		ret = smu_adjust_power_state_dynamic(smu, level, true);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,
diff --git a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
index 53ca9530ed1f..db050978020f 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/amdgpu_smu.h
@@ -437,6 +437,18 @@ struct pptable_funcs {
 	int (*set_power_profile_mode)(struct smu_context *smu, long *input, uint32_t size);
 	enum amd_dpm_forced_level (*get_performance_level)(struct smu_context *smu);
 	int (*force_performance_level)(struct smu_context *smu, enum amd_dpm_forced_level level);
+	int (*pre_display_config_changed)(struct smu_context *smu);
+	int (*display_config_changed)(struct smu_context *smu);
+	int (*apply_clocks_adjust_rules)(struct smu_context *smu);
+	int (*notify_smc_dispaly_config)(struct smu_context *smu);
+	int (*force_dpm_limit_value)(struct smu_context *smu, bool highest);
+	int (*upload_dpm_level)(struct smu_context *smu, bool max);
+	int (*get_profiling_clk_mask)(struct smu_context *smu,
+				      enum amd_dpm_forced_level level,
+				      uint32_t *sclk_mask,
+				      uint32_t *mclk_mask,
+				      uint32_t *soc_mask);
+	int (*set_cpu_power_state)(struct smu_context *smu);
 };
 
 struct smu_funcs
@@ -628,6 +640,22 @@ struct smu_funcs
 	((smu)->ppt_funcs->get_performance_level ? (smu)->ppt_funcs->get_performance_level((smu)) : 0)
 #define smu_force_performance_level(smu, level) \
 	((smu)->ppt_funcs->force_performance_level ? (smu)->ppt_funcs->force_performance_level((smu), (level)) : 0)
+#define smu_pre_display_config_changed(smu) \
+	((smu)->ppt_funcs->pre_display_config_changed ? (smu)->ppt_funcs->pre_display_config_changed((smu)) : 0)
+#define smu_display_config_changed(smu) \
+	((smu)->ppt_funcs->display_config_changed ? (smu)->ppt_funcs->display_config_changed((smu)) : 0)
+#define smu_apply_clocks_adjust_rules(smu) \
+	((smu)->ppt_funcs->apply_clocks_adjust_rules ? (smu)->ppt_funcs->apply_clocks_adjust_rules((smu)) : 0)
+#define smu_notify_smc_dispaly_config(smu) \
+	((smu)->ppt_funcs->notify_smc_dispaly_config ? (smu)->ppt_funcs->notify_smc_dispaly_config((smu)) : 0)
+#define smu_force_dpm_limit_value(smu, highest) \
+	((smu)->ppt_funcs->force_dpm_limit_value ? (smu)->ppt_funcs->force_dpm_limit_value((smu), (highest)) : 0)
+#define smu_upload_dpm_level(smu, max) \
+	((smu)->ppt_funcs->upload_dpm_level ? (smu)->ppt_funcs->upload_dpm_level((smu), (max)) : 0)
+#define smu_get_profiling_clk_mask(smu, level, sclk_mask, mclk_mask, soc_mask) \
+	((smu)->ppt_funcs->get_profiling_clk_mask ? (smu)->ppt_funcs->get_profiling_clk_mask((smu), (level), (sclk_mask), (mclk_mask), (soc_mask)) : 0)
+#define smu_set_cpu_power_state(smu) \
+	((smu)->ppt_funcs->set_cpu_power_state ? (smu)->ppt_funcs->set_cpu_power_state((smu)) : 0)
 
 #define smu_msg_get_index(smu, msg) \
 	((smu)->ppt_funcs? ((smu)->ppt_funcs->get_smu_msg_index? (smu)->ppt_funcs->get_smu_msg_index((smu), (msg)) : -EINVAL) : -EINVAL)
@@ -699,4 +727,7 @@ extern int smu_display_configuration_change(struct smu_context *smu, const
 extern int smu_get_current_clocks(struct smu_context *smu,
 				  struct amd_pp_clock_info *clocks);
 extern int smu_dpm_set_power_gate(struct smu_context *smu,uint32_t block_type, bool gate);
+extern int smu_handle_task(struct smu_context *smu,
+			   enum amd_dpm_forced_level level,
+			   enum amd_pp_task task_id);
 #endif
diff --git a/drivers/gpu/drm/amd/powerplay/vega20_ppt.c b/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
index a90bf77dd9eb..300462aff83a 100644
--- a/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/vega20_ppt.c
@@ -877,71 +877,39 @@ static int vega20_print_clk_levels(struct smu_context *smu,
 	return size;
 }
 
-static int vega20_upload_dpm_min_level(struct smu_context *smu)
+static int vega20_upload_dpm_level(struct smu_context *smu, bool max)
 {
 	struct vega20_dpm_table *dpm_table;
 	struct vega20_single_dpm_table *single_dpm_table;
-	uint32_t min_freq;
+	uint32_t freq;
 	int ret = 0;
 
 	dpm_table = smu->smu_dpm.dpm_context;
 
 	if (smu_feature_is_enabled(smu, FEATURE_DPM_GFXCLK_BIT)) {
 		single_dpm_table = &(dpm_table->gfx_table);
-		min_freq = single_dpm_table->dpm_state.soft_min_level;
+		freq = max ? single_dpm_table->dpm_state.soft_max_level :
+			single_dpm_table->dpm_state.soft_min_level;
 		ret = smu_send_smc_msg_with_param(smu,
-			SMU_MSG_SetSoftMinByFreq,
-			(PPCLK_GFXCLK << 16) | (min_freq & 0xffff));
+			(max ? SMU_MSG_SetSoftMaxByFreq : SMU_MSG_SetSoftMinByFreq),
+			(PPCLK_GFXCLK << 16) | (freq & 0xffff));
 		if (ret) {
-			pr_err("Failed to set soft min gfxclk !\n");
+			pr_err("Failed to set soft %s gfxclk !\n",
+						max ? "max" : "min");
 			return ret;
 		}
 	}
 
 	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT)) {
 		single_dpm_table = &(dpm_table->mem_table);
-		min_freq = single_dpm_table->dpm_state.soft_min_level;
+		freq = max ? single_dpm_table->dpm_state.soft_max_level :
+			single_dpm_table->dpm_state.soft_min_level;
 		ret = smu_send_smc_msg_with_param(smu,
-			SMU_MSG_SetSoftMinByFreq,
-			(PPCLK_UCLK << 16) | (min_freq & 0xffff));
+			(max ? SMU_MSG_SetSoftMaxByFreq : SMU_MSG_SetSoftMinByFreq),
+			(PPCLK_UCLK << 16) | (freq & 0xffff));
 		if (ret) {
-			pr_err("Failed to set soft min memclk !\n");
-			return ret;
-		}
-	}
-
-	return ret;
-}
-
-static int vega20_upload_dpm_max_level(struct smu_context *smu)
-{
-	struct vega20_dpm_table *dpm_table;
-	struct vega20_single_dpm_table *single_dpm_table;
-	uint32_t max_freq;
-	int ret = 0;
-
-	dpm_table = smu->smu_dpm.dpm_context;
-
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_GFXCLK_BIT)) {
-		single_dpm_table = &(dpm_table->gfx_table);
-		max_freq = single_dpm_table->dpm_state.soft_max_level;
-		ret = smu_send_smc_msg_with_param(smu,
-			SMU_MSG_SetSoftMaxByFreq,
-			(PPCLK_GFXCLK << 16) | (max_freq & 0xffff));
-		if (ret) {
-			pr_err("Failed to set soft max gfxclk !\n");
-			return ret;
-		}
-	}
-
-	if (smu_feature_is_enabled(smu, FEATURE_DPM_UCLK_BIT)) {
-		single_dpm_table = &(dpm_table->mem_table);
-		max_freq = single_dpm_table->dpm_state.soft_max_level;
-		ret = smu_send_smc_msg_with_param(smu,
-			SMU_MSG_SetSoftMaxByFreq,
-			(PPCLK_UCLK << 16) | (max_freq & 0xffff));
-		if (ret) {
-			pr_err("Failed to set soft max memclk !\n");
+			pr_err("Failed to set soft %s memclk !\n",
+						max ? "max" : "min");
 			return ret;
 		}
 	}
@@ -986,13 +954,13 @@ static int vega20_force_clk_levels(struct smu_context *smu,
 		single_dpm_table->dpm_state.soft_max_level =
 			single_dpm_table->dpm_levels[soft_max_level].value;
 
-		ret = vega20_upload_dpm_min_level(smu);
+		ret = vega20_upload_dpm_level(smu, false);
 		if (ret) {
 			pr_err("Failed to upload boot level to lowest!\n");
 			break;
 		}
 
-		ret = vega20_upload_dpm_max_level(smu);
+		ret = vega20_upload_dpm_level(smu, true);
 		if (ret)
 			pr_err("Failed to upload dpm max level to highest!\n");
 
@@ -1013,13 +981,13 @@ static int vega20_force_clk_levels(struct smu_context *smu,
 		single_dpm_table->dpm_state.soft_max_level =
 			single_dpm_table->dpm_levels[soft_max_level].value;
 
-		ret = vega20_upload_dpm_min_level(smu);
+		ret = vega20_upload_dpm_level(smu, false);
 		if (ret) {
 			pr_err("Failed to upload boot level to lowest!\n");
 			break;
 		}
 
-		ret = vega20_upload_dpm_max_level(smu);
+		ret = vega20_upload_dpm_level(smu, true);
 		if (ret)
 			pr_err("Failed to upload dpm max level to highest!\n");
 
@@ -1389,11 +1357,26 @@ vega20_set_uclk_to_highest_dpm_level(struct smu_context *smu,
 	return ret;
 }
 
-static int vega20_display_config_changed(struct smu_context *smu)
+static int vega20_pre_display_config_changed(struct smu_context *smu)
 {
 	int ret = 0;
 	struct vega20_dpm_table *dpm_table = smu->smu_dpm.dpm_context;
 
+	if (!smu->smu_dpm.dpm_context)
+		return -EINVAL;
+
+	smu_send_smc_msg_with_param(smu, SMU_MSG_NumOfDisplays, 0);
+	ret = vega20_set_uclk_to_highest_dpm_level(smu,
+						   &dpm_table->mem_table);
+	if (ret)
+		pr_err("Failed to set uclk to highest dpm level");
+	return ret;
+}
+
+static int vega20_display_config_changed(struct smu_context *smu)
+{
+	int ret = 0;
+
 	if (!smu->funcs)
 		return -EINVAL;
 
@@ -1402,14 +1385,6 @@ static int vega20_display_config_changed(struct smu_context *smu)
 	    !smu->smu_table.tables[TABLE_WATERMARKS].cpu_addr)
 		return -EINVAL;
 
-	smu_send_smc_msg_with_param(smu, SMU_MSG_NumOfDisplays, 0);
-	ret = vega20_set_uclk_to_highest_dpm_level(smu,
-						   &dpm_table->mem_table);
-	if (ret) {
-		pr_err("Failed to set uclk to highest dpm level");
-		return ret;
-	}
-
 	if ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&
 	    !(smu->watermarks_bitmap & WATERMARKS_LOADED)) {
 		ret = smu->funcs->write_watermarks_table(smu);
@@ -1672,85 +1647,42 @@ static uint32_t vega20_find_highest_dpm_level(struct vega20_single_dpm_table *ta
 	return i;
 }
 
-static int vega20_force_dpm_highest(struct smu_context *smu)
+static int vega20_force_dpm_limit_value(struct smu_context *smu, bool highest)
 {
 	uint32_t soft_level;
 	int ret = 0;
-	struct vega20_dpm_table *dpm_table = (struct vega20_dpm_table *)smu->smu_dpm.dpm_context;
+	struct vega20_dpm_table *dpm_table =
+		(struct vega20_dpm_table *)smu->smu_dpm.dpm_context;
 
-	soft_level = vega20_find_highest_dpm_level(&(dpm_table->gfx_table));
+	if (highest)
+		soft_level = vega20_find_highest_dpm_level(&(dpm_table->gfx_table));
+	else
+		soft_level = vega20_find_lowest_dpm_level(&(dpm_table->gfx_table));
 
 	dpm_table->gfx_table.dpm_state.soft_min_level =
 		dpm_table->gfx_table.dpm_state.soft_max_level =
 		dpm_table->gfx_table.dpm_levels[soft_level].value;
 
-	soft_level = vega20_find_highest_dpm_level(&(dpm_table->mem_table));
+	if (highest)
+		soft_level = vega20_find_highest_dpm_level(&(dpm_table->mem_table));
+	else
+		soft_level = vega20_find_lowest_dpm_level(&(dpm_table->mem_table));
 
 	dpm_table->mem_table.dpm_state.soft_min_level =
 		dpm_table->mem_table.dpm_state.soft_max_level =
 		dpm_table->mem_table.dpm_levels[soft_level].value;
 
-	ret = vega20_upload_dpm_min_level(smu);
+	ret = vega20_upload_dpm_level(smu, false);
 	if (ret) {
-		pr_err("Failed to upload boot level to highest!");
+		pr_err("Failed to upload boot level to %s!\n",
+				highest ? "highest" : "lowest");
 		return ret;
 	}
 
-	ret = vega20_upload_dpm_max_level(smu);
+	ret = vega20_upload_dpm_level(smu, true);
 	if (ret) {
-		pr_err("Failed to upload dpm max level to highest!");
-		return ret;
-	}
-
-	return ret;
-}
-
-static int vega20_force_dpm_lowest(struct smu_context *smu)
-{
-	uint32_t soft_level;
-	int ret = 0;
-	struct vega20_dpm_table *dpm_table = (struct vega20_dpm_table *)smu->smu_dpm.dpm_context;
-
-	soft_level = vega20_find_lowest_dpm_level(&(dpm_table->gfx_table));
-
-	dpm_table->gfx_table.dpm_state.soft_min_level =
-		dpm_table->gfx_table.dpm_state.soft_max_level =
-		dpm_table->gfx_table.dpm_levels[soft_level].value;
-
-	soft_level = vega20_find_lowest_dpm_level(&(dpm_table->mem_table));
-
-	dpm_table->mem_table.dpm_state.soft_min_level =
-		dpm_table->mem_table.dpm_state.soft_max_level =
-		dpm_table->mem_table.dpm_levels[soft_level].value;
-
-	ret = vega20_upload_dpm_min_level(smu);
-	if (ret) {
-		pr_err("Failed to upload boot level to lowest!");
-		return ret;
-	}
-
-	ret = vega20_upload_dpm_max_level(smu);
-	if (ret) {
-		pr_err("Failed to upload dpm max level to lowest!");
-		return ret;
-	}
-
-	return ret;
-}
-
-static int vega20_unforce_dpm_levels(struct smu_context *smu)
-{
-	int ret = 0;
-
-	ret = vega20_upload_dpm_min_level(smu);
-	if (ret) {
-		pr_err("Failed to upload DPM Bootup Levels!");
-		return ret;
-	}
-
-	ret = vega20_upload_dpm_max_level(smu);
-	if (ret) {
-		pr_err("Failed to upload DPM Max Levels!");
+		pr_err("Failed to upload dpm max level to %s!\n!",
+				highest ? "highest" : "lowest");
 		return ret;
 	}
 
@@ -1771,78 +1703,6 @@ static enum amd_dpm_forced_level vega20_get_performance_level(struct smu_context
 	return smu_dpm_ctx->dpm_level;
 }
 
-static int vega20_adjust_power_state_dynamic(struct smu_context *smu,
-					     enum amd_dpm_forced_level level)
-{
-	int ret = 0;
-	int index = 0;
-	uint32_t sclk_mask, mclk_mask, soc_mask;
-	long workload;
-	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
-
-	ret = vega20_display_config_changed(smu);
-	if (ret) {
-		pr_err("Failed to change display config!");
-		return ret;
-	}
-	ret = vega20_apply_clocks_adjust_rules(smu);
-	if (ret) {
-		pr_err("Failed to apply clocks adjust rules!");
-		return ret;
-	}
-	ret = vega20_notify_smc_dispaly_config(smu);
-	if (ret) {
-		pr_err("Failed to notify smc display config!");
-		return ret;
-	}
-
-	switch (level) {
-	case AMD_DPM_FORCED_LEVEL_HIGH:
-		ret = vega20_force_dpm_highest(smu);
-		break;
-	case AMD_DPM_FORCED_LEVEL_LOW:
-		ret = vega20_force_dpm_lowest(smu);
-		break;
-
-	case AMD_DPM_FORCED_LEVEL_AUTO:
-		ret = vega20_unforce_dpm_levels(smu);
-		break;
-
-	case AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:
-	case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:
-	case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:
-	case AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:
-		ret = vega20_get_profiling_clk_mask(smu, level,
-						    &sclk_mask,
-						    &mclk_mask,
-						    &soc_mask);
-		if (ret)
-			return ret;
-		vega20_force_clk_levels(smu, PP_SCLK, 1 << sclk_mask);
-		vega20_force_clk_levels(smu, PP_MCLK, 1 << mclk_mask);
-		break;
-
-	case AMD_DPM_FORCED_LEVEL_MANUAL:
-	case AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:
-	default:
-		break;
-	}
-
-	if (!ret)
-		smu_dpm_ctx->dpm_level = level;
-
-	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
-		index = fls(smu->workload_mask);
-		index = index > 0 && index <= WORKLOAD_POLICY_MAX ? index - 1 : 0;
-		workload = smu->workload_setting[index];
-
-		if (smu->power_profile_mode != workload)
-			smu->funcs->set_power_profile_mode(smu, &workload, 0);
-	}
-
-	return ret;
-}
-
 static int
 vega20_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_level level)
 {
@@ -1861,7 +1721,8 @@ vega20_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_leve
 	mutex_lock(&smu->mutex);
 
 	smu->adev->ip_blocks[i].version->funcs->enable_umd_pstate(smu, &level);
-	ret = vega20_adjust_power_state_dynamic(smu, level);
+	ret = smu_handle_task(smu, level,
+			      AMD_PP_TASK_READJUST_POWER_STATE);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2009,7 +1870,8 @@ static int vega20_set_od_percentage(struct smu_context *smu,
 		single_dpm_table->dpm_levels[0].value = smu->smu_table.boot_values.gfxclk / 100;
 	}
 
-	ret = vega20_adjust_power_state_dynamic(smu, smu_dpm->dpm_level);
+	ret = smu_handle_task(smu, smu_dpm->dpm_level,
+			      AMD_PP_TASK_READJUST_POWER_STATE);
 
 set_od_failed:
 	mutex_unlock(&(smu->mutex));
@@ -2239,7 +2101,8 @@ static int vega20_odn_edit_dpm_table(struct smu_context *smu,
 
 	if (type == PP_OD_COMMIT_DPM_TABLE) {
 		mutex_lock(&(smu->mutex));
-		ret = vega20_adjust_power_state_dynamic(smu, smu_dpm->dpm_level);
+		ret = smu_handle_task(smu, smu_dpm->dpm_level,
+				      AMD_PP_TASK_READJUST_POWER_STATE);
 		mutex_unlock(&(smu->mutex));
 	}
 
@@ -2268,6 +2131,13 @@ static const struct pptable_funcs vega20_ppt_funcs = {
 	.update_specified_od8_value = vega20_update_specified_od8_value,
 	.set_od_percentage = vega20_set_od_percentage,
 	.od_edit_dpm_table = vega20_odn_edit_dpm_table,
+	.pre_display_config_changed = vega20_pre_display_config_changed,
+	.display_config_changed = vega20_display_config_changed,
+	.apply_clocks_adjust_rules = vega20_apply_clocks_adjust_rules,
+	.notify_smc_dispaly_config = vega20_notify_smc_dispaly_config,
+	.force_dpm_limit_value = vega20_force_dpm_limit_value,
+	.upload_dpm_level = vega20_upload_dpm_level,
+	.get_profiling_clk_mask = vega20_get_profiling_clk_mask,
 };
 
 void vega20_set_ppt_funcs(struct smu_context *smu)
-- 
2.17.1

